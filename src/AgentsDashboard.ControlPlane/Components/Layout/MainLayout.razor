@inherits LayoutComponentBase
@inject IRunStore RunStore
@inject IRuntimeStore RuntimeStore
@inject ITaskRuntimeLifecycleManager TaskRuntimeLifecycleManager
@inject IGlobalSelectionService SelectionService
@inject IJSRuntime JS
@inject IUiRealtimeBroker UiRealtimeBroker
@inject INotificationService NotificationService
@inject IBackgroundWorkCoordinator BackgroundWorkCoordinator
@inject ISnackbar Snackbar

@implements IAsyncDisposable

<MudThemeProvider IsDarkMode="true" Theme="_theme" />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

<MudLayout Class="codex-shell">
    <MudAppBar Elevation="0" Dense="true" Class="codex-appbar">
        <MudText Typo="Typo.subtitle1" Class="codex-brand">Agents Dashboard</MudText>

        <div class="codex-appbar-nav" role="navigation" aria-label="Primary">
            <MudNavLink Href="/workspace" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Dashboard" Class="codex-appbar-nav-link codex-parent-workspace-link"><span data-testid="codex-nav-workspace">Workspace</span></MudNavLink>
            <MudNavLink Href="/overview" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Chat" Class="codex-appbar-nav-link"><span data-testid="codex-nav-overview">Overview</span></MudNavLink>
            <MudNavLink Href="/search" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.TravelExplore" Class="codex-appbar-nav-link codex-parent-search-link"><span data-testid="codex-nav-search">Search</span></MudNavLink>
            <MudNavLink Href="/settings" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Tune" Class="codex-appbar-nav-link codex-parent-settings-link"><span data-testid="codex-nav-settings">Settings</span></MudNavLink>
        </div>

        <MudSpacer />

        @if (SelectionService.IsInitialized)
        {
            <div class="codex-context-selectors">
                <MudSelect T="string"
                           Value="@SelectionService.SelectedRepositoryId"
                           ValueChanged="OnRepositoryChanged"
                           Label="Repository"
                           Variant="Variant.Outlined"
                           Margin="Margin.Dense"
                           Class="codex-context-select"
                           Style="max-width: 220px;">
                    @foreach (var repo in SelectionService.Repositories)
                    {
                        <MudSelectItem Value="@repo.Id">@repo.Name</MudSelectItem>
                    }
                </MudSelect>

                <MudTooltip Text="Refresh" Placement="Placement.Bottom">
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                                   Color="Color.Inherit"
                                   OnClick="RefreshSelectionAsync" />
                </MudTooltip>
            </div>
        }

        @if (_healthLoaded)
        {
            <div class="codex-health-strip">
                <MudChip T="string" Size="Size.Small" Color="@GetWorkerHealthColor()">
                    <MudIcon Icon="@Icons.Material.Filled.Dns" Size="Size.Small" Class="mr-1" />
                    @(_onlineWorkers)/@_totalWorkers Task Runtimes
                </MudChip>
                <MudChip T="string" Size="Size.Small" Color="@GetRunHealthColor()">
                    <MudIcon Icon="@Icons.Material.Filled.PlayCircle" Size="Size.Small" Class="mr-1" />
                    @_activeRuns Active
                </MudChip>
            </div>
        }

        <MudTooltip Text="System Activity" Placement="Placement.Bottom">
            @if (_unreadNotificationCount > 0)
            {
                <MudBadge Content="@_unreadNotificationCount"
                          Color="Color.Error"
                          Overlap="true"
                          Bordered="true">
                    <MudIconButton Icon="@Icons.Material.Filled.Notifications"
                                   Color="Color.Inherit"
                                   OnClick="ToggleActivityDrawer" />
                </MudBadge>
            }
            else
            {
                <MudIconButton Icon="@Icons.Material.Filled.Notifications"
                               Color="Color.Inherit"
                               OnClick="ToggleActivityDrawer" />
            }
        </MudTooltip>
    </MudAppBar>

    <MudDrawer Anchor="Anchor.End"
               Variant="DrawerVariant.Temporary"
               Open="@_activityDrawerOpen"
               OpenChanged="OnActivityDrawerOpenChanged"
               Elevation="2"
               Width="420px"
               Class="codex-activity-drawer">
        <MudStack Spacing="2" Class="pa-3">
            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                <MudText Typo="Typo.h6">System Activity</MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close"
                               Color="Color.Inherit"
                               OnClick="@(() => _activityDrawerOpen = false)" />
            </MudStack>

            <MudPaper Elevation="0" Class="pa-2">
                <MudText Typo="Typo.subtitle2" Class="mb-2">Active Background Work</MudText>
                @if (_activeBackgroundWork.Count == 0)
                {
                    <MudText Typo="Typo.caption">No active background tasks.</MudText>
                }
                else
                {
                    <MudStack Spacing="1">
                        @foreach (var snapshot in _activeBackgroundWork)
                        {
                            <MudPaper Elevation="0" Class="pa-2">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                    <MudText Typo="Typo.caption">@snapshot.Kind</MudText>
                                    <MudChip T="string" Size="Size.Small" Color="@MapBackgroundWorkColor(snapshot.State)">
                                        @snapshot.State
                                    </MudChip>
                                </MudStack>
                                <MudText Typo="Typo.caption">@snapshot.Message</MudText>
                                @if (snapshot.PercentComplete.HasValue)
                                {
                                    <MudProgressLinear Value="@snapshot.PercentComplete.Value" Class="mt-1" />
                                }
                                else
                                {
                                    <MudProgressLinear Indeterminate="true" Class="mt-1" />
                                }
                            </MudPaper>
                        }
                    </MudStack>
                }
            </MudPaper>

            <MudPaper Elevation="0" Class="pa-2">
                <MudText Typo="Typo.subtitle2" Class="mb-2">Notifications</MudText>
                @if (_notificationFeed.Count == 0)
                {
                    <MudText Typo="Typo.caption">No notifications yet.</MudText>
                }
                else
                {
                    <MudList T="NotificationMessage" Dense="true">
                        @foreach (var notification in _notificationFeed)
                        {
                            <MudListItem>
                                <MudStack Spacing="0" Style="width: 100%;">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                        <MudText Typo="Typo.caption">@notification.Title</MudText>
                                        <MudChip T="string" Size="Size.Small" Color="@MapNotificationColor(notification.Severity)">
                                            @notification.Severity
                                        </MudChip>
                                    </MudStack>
                                    @if (!string.IsNullOrWhiteSpace(notification.Body))
                                    {
                                        <MudText Typo="Typo.caption">@notification.Body</MudText>
                                    }
                                    <MudText Typo="Typo.caption">@notification.Timestamp.LocalDateTime.ToString("g")</MudText>
                                </MudStack>
                            </MudListItem>
                        }
                    </MudList>
                }
            </MudPaper>
        </MudStack>
    </MudDrawer>

    <MudMainContent Class="codex-main">
        <MudContainer MaxWidth="MaxWidth.False" Class="codex-main-container">
            @Body
        </MudContainer>
    </MudMainContent>
</MudLayout>

@code {
    private bool _healthLoaded;
    private int _onlineWorkers;
    private int _totalWorkers;
    private int _activeRuns;
    private readonly Dictionary<string, string> _runCompletionStates = new(StringComparer.OrdinalIgnoreCase);
    private readonly object _runCompletionStateLock = new();
    private CancellationTokenSource? _cts;
    private IDisposable? _runStatusSubscription;
    private IDisposable? _selectionSubscription;
    private Task? _notificationPumpTask;
    private Action<BackgroundWorkSnapshot>? _backgroundWorkUpdatedHandler;
    private bool _activityDrawerOpen;
    private int _unreadNotificationCount;
    private IReadOnlyList<NotificationMessage> _notificationFeed = [];
    private IReadOnlyList<BackgroundWorkSnapshot> _backgroundWorkSnapshots = [];

    private readonly MudTheme _theme = new()
    {
        PaletteDark = new PaletteDark
        {
            Primary = "#7CC4FF",
            Secondary = "#4CE0C4",
            Tertiary = "#9A8CFF",
            Info = "#53B1FD",
            Success = "#32D583",
            Warning = "#F79009",
            Error = "#F97066",
            Background = "#07090D",
            BackgroundGray = "#0E1118",
            Surface = "#0E131C",
            AppbarBackground = "#0B0F17",
            AppbarText = "#F4F7FB",
            DrawerBackground = "#0A0E15",
            DrawerText = "#C9D2E3",
            DrawerIcon = "#91A4BD",
            TextPrimary = "#F4F7FB",
            TextSecondary = "#A5B1C1",
            ActionDefault = "#A5B1C1",
            ActionDisabled = "#5F6C7E",
            ActionDisabledBackground = "#141920",
            LinesDefault = "#1A2230",
            LinesInputs = "#2A3446",
            TableLines = "#1A2230",
            TableStriped = "#0F1218",
            Divider = "#1A2230"
        }
    };

    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        _notificationFeed = NotificationService.Snapshot().Take(40).ToArray();
        _backgroundWorkSnapshots = BuildBackgroundWorkSnapshotCache(BackgroundWorkCoordinator.Snapshot());
        _backgroundWorkUpdatedHandler = OnBackgroundWorkUpdated;
        BackgroundWorkCoordinator.Updated += _backgroundWorkUpdatedHandler;

        _selectionSubscription = SelectionService.Subscribe(_ => InvokeAsync(StateHasChanged));
        _runStatusSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunStatusChangedEvent>(async runStatus =>
        {
            var runCompletionState = GetRunCompletionState(runStatus.State);
            if (runCompletionState is null)
            {
                return;
            }

            lock (_runCompletionStateLock)
            {
                if (_runCompletionStates.ContainsKey(runStatus.RunId))
                {
                    return;
                }

                _runCompletionStates[runStatus.RunId] = runCompletionState;
            }

            await InvokeAsync(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("agentsDashboard.playRunCompletedSound", runCompletionState);
                }
                catch
                {
                }
            });
        });

        _ = Task.Run(async () =>
        {
            while (!_cts.Token.IsCancellationRequested)
            {
                try
                {
                    await LoadCheckHealthAsync();
                    await InvokeAsync(StateHasChanged);
                }
                catch
                {
                }

                await Task.Delay(TimeSpan.FromSeconds(30), _cts.Token);
            }
        }, _cts.Token);

        _notificationPumpTask = Task.Run(
            async () =>
            {
                try
                {
                    await foreach (var notification in NotificationService.StreamAsync(_cts.Token))
                    {
                        await InvokeAsync(() =>
                        {
                            _notificationFeed = PrependNotification(notification, _notificationFeed);
                            if (!_activityDrawerOpen)
                            {
                                _unreadNotificationCount++;
                            }

                            if (!notification.Title.Contains(": running", StringComparison.OrdinalIgnoreCase))
                            {
                                var message = string.IsNullOrWhiteSpace(notification.Body)
                                    ? notification.Title
                                    : $"{notification.Title}: {notification.Body}";
                                Snackbar.Add(message, MapSnackbarSeverity(notification.Severity));
                            }

                            StateHasChanged();
                        });
                    }
                }
                catch (OperationCanceledException)
                {
                }
            },
            _cts.Token);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await SelectionService.InitializeAsync(_cts?.Token ?? CancellationToken.None);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnRepositoryChanged(string? repositoryId)
    {
        await SelectionService.SelectRepositoryAsync(repositoryId, _cts?.Token ?? CancellationToken.None);
    }

    private async Task RefreshSelectionAsync()
    {
        await SelectionService.RefreshAsync(_cts?.Token ?? CancellationToken.None);
        StateHasChanged();
    }

    private async Task LoadCheckHealthAsync()
    {
        var runtimeInstances = await TaskRuntimeLifecycleManager.ListTaskRuntimesAsync(CancellationToken.None);
        var runningRuntimeIds = runtimeInstances
            .Where(runtime => runtime.IsRunning)
            .Select(runtime => runtime.TaskRuntimeId)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        _totalWorkers = runningRuntimeIds.Count;
        if (_totalWorkers == 0)
        {
            _onlineWorkers = 0;
        }
        else
        {
            var registrations = await RuntimeStore.ListTaskRuntimeRegistrationsAsync(CancellationToken.None);
            _onlineWorkers = registrations.Count(registration =>
                registration.Online &&
                runningRuntimeIds.Contains(registration.RuntimeId));
        }

        var runs = await RunStore.ListRecentRunsAsync(CancellationToken.None);
        _activeRuns = runs.Count(r => r.State is RunState.Running or RunState.Queued);

        _healthLoaded = true;
    }

    private Color GetWorkerHealthColor()
    {
        if (_totalWorkers == 0) return Color.Error;
        if (_onlineWorkers == _totalWorkers) return Color.Success;
        if (_onlineWorkers > 0) return Color.Warning;
        return Color.Error;
    }

    private Color GetRunHealthColor()
    {
        if (_activeRuns == 0) return Color.Default;
        if (_activeRuns > 10) return Color.Warning;
        return Color.Info;
    }

    private static string? GetRunCompletionState(string? state)
    {
        return state switch
        {
            not null when string.Equals(state, "Succeeded", StringComparison.OrdinalIgnoreCase) => "succeeded",
            not null when string.Equals(state, "Failed", StringComparison.OrdinalIgnoreCase) => "failed",
            not null when string.Equals(state, "Cancelled", StringComparison.OrdinalIgnoreCase) => "cancelled",
            _ => null
        };
    }

    private IReadOnlyList<BackgroundWorkSnapshot> _activeBackgroundWork => _backgroundWorkSnapshots
        .Where(snapshot => snapshot.State is BackgroundWorkState.Pending or BackgroundWorkState.Running)
        .OrderByDescending(snapshot => snapshot.UpdatedAt ?? snapshot.StartedAt ?? DateTimeOffset.MinValue)
        .Take(12)
        .ToArray();

    private void ToggleActivityDrawer()
    {
        _activityDrawerOpen = !_activityDrawerOpen;
        if (_activityDrawerOpen)
        {
            _unreadNotificationCount = 0;
        }
    }

    private Task OnActivityDrawerOpenChanged(bool isOpen)
    {
        _activityDrawerOpen = isOpen;
        if (isOpen)
        {
            _unreadNotificationCount = 0;
        }

        return Task.CompletedTask;
    }

    private void OnBackgroundWorkUpdated(BackgroundWorkSnapshot snapshot)
    {
        _ = InvokeAsync(() =>
        {
            var snapshots = _backgroundWorkSnapshots
                .Where(existing => !string.Equals(existing.WorkId, snapshot.WorkId, StringComparison.OrdinalIgnoreCase))
                .Append(snapshot);
            _backgroundWorkSnapshots = BuildBackgroundWorkSnapshotCache(snapshots);
            StateHasChanged();
        });
    }

    private static IReadOnlyList<BackgroundWorkSnapshot> BuildBackgroundWorkSnapshotCache(IEnumerable<BackgroundWorkSnapshot> snapshots)
    {
        return snapshots
            .OrderByDescending(snapshot => snapshot.UpdatedAt ?? snapshot.StartedAt ?? DateTimeOffset.MinValue)
            .Take(80)
            .ToArray();
    }

    private static IReadOnlyList<NotificationMessage> PrependNotification(
        NotificationMessage message,
        IReadOnlyList<NotificationMessage> existing)
    {
        var list = new List<NotificationMessage>(capacity: Math.Min(existing.Count + 1, 60))
        {
            message
        };

        foreach (var item in existing)
        {
            if (list.Count >= 60)
            {
                break;
            }

            list.Add(item);
        }

        return list;
    }

    private static Severity MapSnackbarSeverity(NotificationSeverity severity)
    {
        return severity switch
        {
            NotificationSeverity.Info => Severity.Info,
            NotificationSeverity.Success => Severity.Success,
            NotificationSeverity.Warning => Severity.Warning,
            NotificationSeverity.Error => Severity.Error,
            _ => Severity.Info,
        };
    }

    private static Color MapNotificationColor(NotificationSeverity severity)
    {
        return severity switch
        {
            NotificationSeverity.Info => Color.Info,
            NotificationSeverity.Success => Color.Success,
            NotificationSeverity.Warning => Color.Warning,
            NotificationSeverity.Error => Color.Error,
            _ => Color.Default,
        };
    }

    private static Color MapBackgroundWorkColor(BackgroundWorkState state)
    {
        return state switch
        {
            BackgroundWorkState.Pending => Color.Info,
            BackgroundWorkState.Running => Color.Primary,
            BackgroundWorkState.Succeeded => Color.Success,
            BackgroundWorkState.Failed => Color.Error,
            BackgroundWorkState.Cancelled => Color.Warning,
            _ => Color.Default,
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_backgroundWorkUpdatedHandler is not null)
        {
            BackgroundWorkCoordinator.Updated -= _backgroundWorkUpdatedHandler;
            _backgroundWorkUpdatedHandler = null;
        }

        _selectionSubscription?.Dispose();
        _runStatusSubscription?.Dispose();
        _cts?.Cancel();

        if (_notificationPumpTask is not null)
        {
            try
            {
                await _notificationPumpTask;
            }
            catch (OperationCanceledException)
            {
            }
        }

        _cts?.Dispose();
    }
}

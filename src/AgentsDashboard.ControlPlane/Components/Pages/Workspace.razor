@page "/workspace"
@rendermode InteractiveServer
@using System.Text.Json
@using AgentsDashboard.ControlPlane.Components.Shared
@using AgentsDashboard.ControlPlane.Services
@inject Data.IOrchestratorStore Store
@inject Services.IGlobalSelectionService SelectionService
@inject Services.IWorkspaceService WorkspaceService
@inject Services.IWorkspaceSearchService WorkspaceSearchService
@inject Services.IWorkspaceAiService WorkspaceAiService
@inject Services.IRunStructuredViewService RunStructuredViewService
@inject Services.IHarnessOutputParserService HarnessOutputParser
@inject Services.IUiRealtimeBroker UiRealtimeBroker
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Workspace</PageTitle>

<MudStack Class="workspace-page" Spacing="2">
    @if (_loading)
    {
        <MudStack Class="overview-loading" AlignItems="AlignItems.Center" Justify="Justify.Center">
            <MudProgressCircular Indeterminate="true" Size="Size.Large" />
        </MudStack>
    }
    else
    {
        <div class="workspace-shell">
            <MudPaper Class="workspace-left-pane" Elevation="0">
                <MudStack Spacing="2">
                    <MudStack Row AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h5">Workspace</MudText>
                        <MudSpacer />
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Add"
                                   Size="Size.Small"
                                   OnClick="OpenCreateTaskFormAsync"
                                   Disabled="_selectedRepository is null">
                            New Task
                        </MudButton>
                    </MudStack>

                    <MudTextField T="string"
                                  Value="_searchText"
                                  ValueChanged="OnSearchTextChangedAsync"
                                  Placeholder="Search task or message"
                                  Variant="Variant.Outlined"
                                  Margin="Margin.Dense"
                                  Immediate="true"
                                  Adornment="Adornment.Start"
                                  AdornmentIcon="@Icons.Material.Filled.Search" />

                    <MudStack Row AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Need cross-repository search?</MudText>
                        <MudSpacer />
                        <MudButton Variant="Variant.Text"
                                   Size="Size.Small"
                                   StartIcon="@Icons.Material.Filled.TravelExplore"
                                   Href="@BuildGlobalSearchHref()">
                            Open Global Search
                        </MudButton>
                    </MudStack>

                    <MudStack Row Spacing="1">
                        <MudSelect T="string"
                                   @bind-Value="_repositoryFilter"
                                   Label="Repos"
                                   Variant="Variant.Outlined"
                                   Margin="Margin.Dense"
                                   Class="workspace-filter-select">
                            <MudSelectItem T="string" Value="@RepositoryFilterAll">All</MudSelectItem>
                            <MudSelectItem T="string" Value="@RepositoryFilterAttention">Needs Attention</MudSelectItem>
                            <MudSelectItem T="string" Value="@RepositoryFilterHealthy">Healthy</MudSelectItem>
                        </MudSelect>

                        <MudSelect T="string"
                                   @bind-Value="_taskFilter"
                                   Label="Tasks"
                                   Variant="Variant.Outlined"
                                   Margin="Margin.Dense"
                                   Class="workspace-filter-select">
                            <MudSelectItem T="string" Value="@TaskFilterAll">All</MudSelectItem>
                            <MudSelectItem T="string" Value="@TaskFilterRunning">Running/Queued</MudSelectItem>
                            <MudSelectItem T="string" Value="@TaskFilterFailed">Failed</MudSelectItem>
                            <MudSelectItem T="string" Value="@TaskFilterSucceeded">Succeeded</MudSelectItem>
                            <MudSelectItem T="string" Value="@TaskFilterEnabled">Enabled Only</MudSelectItem>
                        </MudSelect>
                    </MudStack>

                    @if (_searchInFlight)
                    {
                        <MudProgressLinear Indeterminate="true" Color="Color.Info" />
                    }

                    @if (!string.IsNullOrWhiteSpace(_searchError))
                    {
                        <MudAlert Severity="Severity.Warning">@_searchError</MudAlert>
                    }

                    @if (!string.IsNullOrWhiteSpace(_searchText))
                    {
                        <MudPaper Class="workspace-search-results" Elevation="0">
                            <MudStack Row AlignItems="AlignItems.Center" Class="mb-1">
                                <MudText Typo="Typo.subtitle2">Search Results</MudText>
                                <MudSpacer />
                                @if (_searchResult is not null)
                                {
                                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@_searchResult.Hits.Count hits</MudChip>
                                    <MudChip T="string"
                                             Size="Size.Small"
                                             Color="@(_searchResult.SqliteVecAvailable ? Color.Success : Color.Warning)">
                                        @(_searchResult.SqliteVecAvailable ? "sqlite-vec" : "Text fallback")
                                    </MudChip>
                                }
                            </MudStack>

                            @if (_searchHits.Count == 0 && !_searchInFlight)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Secondary">No task/message hits found.</MudText>
                            }
                            else
                            {
                                @foreach (var hit in _searchHits.Take(10))
                                {
                                    <MudPaper Class="workspace-search-hit" Elevation="0" @onclick="() => JumpToSearchHitAsync(hit)">
                                        <MudStack Row AlignItems="AlignItems.Center">
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@FormatHitKind(hit.Kind)</MudChip>
                                            <MudText Typo="Typo.caption">@hit.Title</MudText>
                                            <MudSpacer />
                                            <MudText Typo="Typo.caption" Color="Color.Secondary">S @hit.Score.ToString("0.##")</MudText>
                                        </MudStack>
                                        <MudText Typo="Typo.body2">@hit.Snippet</MudText>
                                    </MudPaper>
                                }
                            }
                        </MudPaper>
                    }
                </MudStack>

                <MudDivider Class="my-2" />

                <div class="workspace-repository-groups">
                    <MudText Typo="Typo.subtitle2" Class="workspace-section-title">Repositories</MudText>

                    @if (FilteredRepositoryGroups.Count == 0)
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">No repositories match your filters.</MudText>
                    }
                    else
                    {
                        @foreach (var group in FilteredRepositoryGroups)
                        {
                            <MudText Typo="Typo.caption" Class="workspace-group-label">@group.Name (@group.Repositories.Count)</MudText>

                            @foreach (var repository in group.Repositories)
                            {
                                <MudPaper Class="@GetRepositoryCardClass(repository)"
                                          Elevation="0"
                                          @onclick="() => SelectRepositoryAsync(repository.Id, true)">
                                    <MudStack Spacing="1">
                                        <MudStack Row AlignItems="AlignItems.Center">
                                            <MudText Typo="Typo.subtitle2">@repository.Name</MudText>
                                            <MudSpacer />
                                            <MudChip T="string" Size="Size.Small" Color="@GetRepositoryHealthColor(repository)">
                                                @GetRepositoryHealthLabel(repository)
                                            </MudChip>
                                        </MudStack>

                                        <MudStack Row Spacing="1">
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@GetBranchLabel(repository)</MudChip>
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">A/B @repository.AheadCount/@repository.BehindCount</MudChip>
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">Delta @GetWorkingTreeCount(repository)</MudChip>
                                        </MudStack>

                                        <MudProgressLinear Value="@GetRepositoryProgress(repository)"
                                                           Color="@GetRepositoryHealthColor(repository)"
                                                           Size="Size.Small" />
                                    </MudStack>
                                </MudPaper>
                            }
                        }
                    }
                </div>

                <MudDivider Class="my-2" />

                <div class="workspace-task-list">
                    <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                        <MudText Typo="Typo.subtitle2" Class="workspace-section-title">Recent Tasks</MudText>
                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@_recentTaskTargetCount visible</MudChip>
                    </MudStack>

                    @if (FilteredRecentTasks.Count == 0)
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">No tasks available for the selected repository.</MudText>
                    }
                    else
                    {
                        @foreach (var task in FilteredRecentTasks)
                        {
                            var latestRun = GetLatestRun(task.Id);
                            <MudPaper Class="@GetTaskCardClass(task)"
                                      Elevation="0"
                                      @onclick="() => SelectTaskAsync(task.Id)">
                                    <MudStack Spacing="1">
                                        <MudStack Row AlignItems="AlignItems.Center">
                                            <MudText Typo="Typo.subtitle2">@task.Name</MudText>
                                            <MudSpacer />
                                            <TaskStatusChip Task="task" LatestRun="@latestRun" IsLoading="_taskStatusLoading" />
                                        </MudStack>

                                    <MudStack Row Spacing="1">
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@task.Harness</MudChip>
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@task.Kind</MudChip>
                                        @if (latestRun is not null)
                                        {
                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">
                                                @latestRun.CreatedAtUtc.ToLocalTime().ToString("g")
                                            </MudChip>
                                        }
                                    </MudStack>

                                    <MudProgressLinear Value="@GetTaskProgressPercent(task.Id)"
                                                       Color="@GetTaskStateColor(task)"
                                                       Size="Size.Small" />
                                </MudStack>
                            </MudPaper>
                        }
                    }
                </div>
            </MudPaper>

            <div class="workspace-right-pane">
                @if (_selectedRepository is null)
                {
                    <MudPaper Class="workspace-empty-state" Elevation="0">
                        <MudText Typo="Typo.h6">No repositories available</MudText>
                        <MudText Typo="Typo.body2" Color="Color.Secondary">Add a repository in settings, then return to Workspace.</MudText>
                    </MudPaper>
                }
                else if (_isCreateTaskMode)
                {
                    <MudPaper Class="workspace-create-task-panel" Elevation="0">
                        <MudStack Row AlignItems="AlignItems.Center" Class="mb-2">
                            <MudText Typo="Typo.h5">Create Task</MudText>
                            <MudSpacer />
                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@_selectedRepository.Name</MudChip>
                        </MudStack>

                        <MudGrid>
                            <MudItem xs="12" md="3">
                                <MudTextField T="string"
                                              @ref="_createTaskNameField"
                                              @bind-Value="_createTaskName"
                                              Label="Task Name"
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Immediate="true" />
                            </MudItem>

                            <MudItem xs="12" md="3">
                                <MudSelect T="string"
                                           @bind-Value="_createTaskHarness"
                                           Label="Harness"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense">
                                    <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("zai")'>Zai (GLM-5)</MudSelectItem>
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12" md="3">
                                <MudSelect T="TaskKind"
                                           @bind-Value="_createTaskKind"
                                           Label="Kind"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense">
                                    <MudSelectItem T="TaskKind" Value="@TaskKind.OneShot">One Shot</MudSelectItem>
                                    <MudSelectItem T="TaskKind" Value="@TaskKind.Cron">Cron</MudSelectItem>
                                    <MudSelectItem T="TaskKind" Value="@TaskKind.EventDriven">Event Driven</MudSelectItem>
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12" md="3">
                                <MudSelect T="HarnessExecutionMode"
                                           @bind-Value="_createTaskModeDefault"
                                           Label="Default Mode"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense">
                                    <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Default">Default</MudSelectItem>
                                    <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Plan">Plan</MudSelectItem>
                                    <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Review">Review</MudSelectItem>
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12" md="8">
                                <MudTextField T="string"
                                              @bind-Value="_createTaskCommand"
                                              Label="Shell Command"
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Immediate="true" />
                            </MudItem>

                            <MudItem xs="12" md="4">
                                <MudTextField T="string"
                                              @bind-Value="_createTaskCron"
                                              Label="Cron Expression"
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Immediate="true" />
                            </MudItem>

                            <MudItem xs="12">
                                <MudTextField T="string"
                                              @bind-Value="_createTaskPrompt"
                                              Label="Prompt"
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Immediate="true"
                                              Lines="16" />
                            </MudItem>
                        </MudGrid>

                        <MudStack Row Spacing="1" Class="mt-2">
                            <MudSwitch T="bool"
                                       @bind-Value="_createTaskAutoPr"
                                       Label="Auto PR"
                                       Color="Color.Primary" />
                            <MudSpacer />
                            <MudButton Variant="Variant.Outlined"
                                       Color="Color.Default"
                                       OnClick="CloseCreateTaskForm"
                                       Disabled="_isCreatingTask">
                                Cancel
                            </MudButton>
                            <MudButton Variant="Variant.Filled"
                                       Color="Color.Primary"
                                       OnClick="CreateTaskAsync"
                                       Disabled="@_isCreatingTask">
                                @if (_isCreatingTask)
                                {
                                    <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="mr-2" />
                                    <span>Creating...</span>
                                }
                                else
                                {
                                    <span>Create Task</span>
                                }
                            </MudButton>
                        </MudStack>
                    </MudPaper>
                }
                else if (_selectedTask is null)
                {
                    <MudPaper Class="workspace-empty-state" Elevation="0">
                        <MudText Typo="Typo.h6">No task selected</MudText>
                        <MudText Typo="Typo.body2" Color="Color.Secondary">Pick a task on the left to inspect execution and submit new prompt guidance.</MudText>
                    </MudPaper>
                }
                else
                {
                    <div class="workspace-right-split">
                        <MudPaper Class="workspace-console-panel" Elevation="0">
                            <MudStack Row AlignItems="AlignItems.Center" Class="workspace-console-header">
                                <MudText Typo="Typo.h6">@_selectedTask.Name</MudText>
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@_selectedTask.Harness</MudChip>
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@_selectedTask.Kind</MudChip>
                                <MudChip T="string" Size="Size.Small" Color="@GetTaskStateColor(_selectedTask)">@GetTaskStateLabel(_selectedTask)</MudChip>
                                @if (_selectedRun is not null)
                                {
                                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">Run @_selectedRun.Id[..Math.Min(8, _selectedRun.Id.Length)]</MudChip>
                                    <MudChip T="string" Size="Size.Small" Color="@GetStateColor(_selectedRun.State)">@_selectedRun.State</MudChip>
                                    <MudChip T="string" Size="Size.Small" Color="@GetRunStepColor(_selectedRun, RunStep.Queued)">Queued</MudChip>
                                    <MudChip T="string" Size="Size.Small" Color="@GetRunStepColor(_selectedRun, RunStep.Running)">Running</MudChip>
                                    <MudChip T="string" Size="Size.Small" Color="@GetRunStepColor(_selectedRun, RunStep.Done)">Done</MudChip>
                                    @if (_selectedRun.State is RunState.Running or RunState.Queued or RunState.PendingApproval)
                                    {
                                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                    }
                                }
                                <MudSpacer />
                                @if (_selectedRun is not null)
                                {
                                    <MudTooltip Text="Refresh AI summary">
                                        <MudIconButton Icon="@Icons.Material.Filled.AutoAwesome"
                                                       Color="Color.Inherit"
                                                       OnClick="@(() => RefreshRunSummaryAsync(force: true))" />
                                    </MudTooltip>
                                }
                                <MudTooltip Text="Refresh runs and logs">
                                    <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                                                   Color="Color.Inherit"
                                                   OnClick="RefreshSelectedRepositoryAsync" />
                                </MudTooltip>
                                <MudTooltip Text="Toggle history panel">
                                    <MudIconButton Icon="@(_historyPanelOpen ? Icons.Material.Filled.VisibilityOff : Icons.Material.Filled.Visibility)"
                                                   Color="Color.Inherit"
                                                   OnClick="ToggleHistoryPanel" />
                                </MudTooltip>
                            </MudStack>

                            <MudTabs Elevation="0" Rounded>
                                <MudTabPanel Text="Timeline" Icon="@Icons.Material.Filled.Timeline">
                                    <div class="workspace-console-scroll">
                                        @if (_selectedRun is null)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No executions found for this task.</MudText>
                                        }
                                        else
                                        {
                                            <MudStack Spacing="1">
                                                <MudGrid Class="mb-1">
                                                    <MudItem xs="6" md="2">
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">Thinking</MudText>
                                                            <MudText Typo="Typo.h6">@_selectedRunStructuredView.Thinking.Count</MudText>
                                                        </MudPaper>
                                                    </MudItem>
                                                    <MudItem xs="6" md="2">
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">Tools</MudText>
                                                            <MudText Typo="Typo.h6">@_selectedRunStructuredView.Tools.Count</MudText>
                                                        </MudPaper>
                                                    </MudItem>
                                                    <MudItem xs="6" md="2">
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">Diff</MudText>
                                                            <MudText Typo="Typo.h6">@RunDiffParser.Parse(GetWorkspaceResolvedDiffPatch()).Count</MudText>
                                                        </MudPaper>
                                                    </MudItem>
                                                    <MudItem xs="6" md="3">
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">Summary</MudText>
                                                            <MudText Typo="Typo.body2">@TruncateForDisplay(_selectedRunAiSummary?.Summary ?? _selectedRunParsed?.Summary ?? GetRunSummary(_selectedRun), 120)</MudText>
                                                        </MudPaper>
                                                    </MudItem>
                                                    <MudItem xs="12" md="3">
                                                        <MudPaper Class="workspace-structured-section workspace-structured-section-error" Elevation="0">
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">Errors</MudText>
                                                            <MudText Typo="Typo.body2">@TruncateForDisplay(_selectedRunParsed?.Error ?? string.Empty, 120)</MudText>
                                                        </MudPaper>
                                                    </MudItem>
                                                </MudGrid>

                                                @if (!string.IsNullOrWhiteSpace(_selectedRunAiSummary?.Summary))
                                                {
                                                    <MudAlert Severity="Severity.Info">
                                                        <MudText Typo="Typo.caption">@(_selectedRunAiSummary.Title == string.Empty ? "AI Summary" : _selectedRunAiSummary.Title)</MudText>
                                                        <MudText Typo="Typo.body2">@_selectedRunAiSummary.Summary</MudText>
                                                    </MudAlert>
                                                }

                                                @if (_selectedRunParsed is not null)
                                                {
                                                    <MudStack Row Spacing="1">
                                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">Status: @_selectedRunParsed.Status</MudChip>
                                                        @if (_selectedRunParsed.ToolCallGroups.Count > 0)
                                                        {
                                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">Tools: @_selectedRunParsed.ToolCallGroups.Count</MudChip>
                                                        }
                                                        @if (_selectedRunParsed.RawStream.Count > 0)
                                                        {
                                                            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">Stream: @_selectedRunParsed.RawStream.Count lines</MudChip>
                                                        }
                                                    </MudStack>

                                                    @if (_selectedRunParsed.Summary != string.Empty)
                                                    {
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption">Summary</MudText>
                                                            <MudText Typo="Typo.body2">@_selectedRunParsed.Summary</MudText>
                                                        </MudPaper>
                                                    }

                                                    @if (_selectedRunParsed.Error != string.Empty)
                                                    {
                                                        <MudPaper Class="workspace-structured-section workspace-structured-section-error" Elevation="0">
                                                            <MudText Typo="Typo.caption">Error</MudText>
                                                            <MudText Typo="Typo.body2">@_selectedRunParsed.Error</MudText>
                                                        </MudPaper>
                                                    }

                                                    @foreach (var parsedSection in _selectedRunParsed.Sections.Where(section => section.Key != "summary" && section.Key != "error" && section.Key != "raw_json"))
                                                    {
                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                            <MudText Typo="Typo.caption">@parsedSection.Title</MudText>
                                                            <MudText Typo="Typo.body2">@parsedSection.Content</MudText>
                                                        </MudPaper>
                                                    }

                                                    @if (_selectedRunParsed.ToolCallGroups.Count > 0)
                                                    {
                                                        <MudText Typo="Typo.subtitle2" Class="mt-2">Tool Call Timeline</MudText>
                                                        <MudTimeline TimelinePosition="TimelinePosition.Start" TimelineOrientation="TimelineOrientation.Vertical">
                                                            @foreach (var toolGroup in _selectedRunParsed.ToolCallGroups)
                                                            {
                                                                <MudTimelineItem Color="Color.Info" Size="Size.Small">
                                                                    <ItemOpposite>
                                                                        <MudText Typo="Typo.caption">@toolGroup.ToolName</MudText>
                                                                    </ItemOpposite>
                                                                    <ItemContent>
                                                                        <MudPaper Class="workspace-structured-section" Elevation="0">
                                                                            <MudText Typo="Typo.caption">@toolGroup.Entries.Count entries</MudText>
                                                                            @foreach (var entry in toolGroup.Entries.Take(6))
                                                                            {
                                                                                <MudText Typo="Typo.caption">@entry.TimestampUtc.ToLocalTime().ToString("HH:mm:ss") @entry.Message</MudText>
                                                                            }
                                                                        </MudPaper>
                                                                    </ItemContent>
                                                                </MudTimelineItem>
                                                            }
                                                        </MudTimeline>
                                                    }
                                                }

                                                @if (_selectedRunLogs.Count == 0)
                                                {
                                                    <MudText Typo="Typo.body2" Color="Color.Secondary">No logs captured yet.</MudText>
                                                }
                                                else
                                                {
                                                    <MudText Typo="Typo.subtitle2" Class="mt-2">Live Stream</MudText>
                                                    @foreach (var log in _selectedRunLogs.TakeLast(120))
                                                    {
                                                        <MudText Typo="Typo.body2" Class="workspace-console-line">[@log.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")] @log.Message</MudText>
                                                    }
                                                }
                                            </MudStack>
                                        }
                                    </div>
                                    @if (_selectedRun is not null && _selectedRun.State is RunState.Running or RunState.Queued or RunState.PendingApproval)
                                    {
                                        <MudProgressLinear Indeterminate="true" Color="Color.Info" />
                                    }
                                </MudTabPanel>

                                <MudTabPanel Text="Thinking" Icon="@Icons.Material.Filled.Psychology">
                                    <div class="workspace-console-scroll">
                                        @if (_selectedRun is null)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No run selected.</MudText>
                                        }
                                        else if (_selectedRunStructuredView.Thinking.Count == 0)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No thinking events captured.</MudText>
                                        }
                                        else
                                        {
                                            @foreach (var item in _selectedRunStructuredView.Thinking.TakeLast(160))
                                            {
                                                <MudText Typo="Typo.body2" Class="workspace-console-line">[@item.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")] @item.Content</MudText>
                                            }
                                        }
                                    </div>
                                </MudTabPanel>

                                <MudTabPanel Text="Tools" Icon="@Icons.Material.Filled.Build">
                                    <div class="workspace-console-scroll">
                                        @if (_selectedRun is null)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No run selected.</MudText>
                                        }
                                        else if (_selectedRunStructuredView.Tools.Count == 0)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No tool lifecycle events captured.</MudText>
                                        }
                                        else
                                        {
                                            @foreach (var tool in _selectedRunStructuredView.Tools.TakeLast(240))
                                            {
                                                <MudPaper Class="workspace-structured-section" Elevation="0">
                                                    <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@tool.ToolName</MudChip>
                                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@tool.State</MudChip>
                                                        @if (!string.IsNullOrWhiteSpace(tool.ToolCallId))
                                                        {
                                                            <MudText Typo="Typo.caption" Color="Color.Secondary">@tool.ToolCallId</MudText>
                                                        }
                                                        <MudSpacer />
                                                        <MudText Typo="Typo.caption">@tool.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")</MudText>
                                                    </MudStack>
                                                </MudPaper>
                                            }
                                        }
                                    </div>
                                </MudTabPanel>

                                <MudTabPanel Text="Diff" Icon="@Icons.Material.Filled.Difference">
                                    <div class="workspace-console-scroll">
                                        @if (_selectedRun is null)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">No run selected.</MudText>
                                        }
                                        else
                                        {
                                            <RunDiffViewer RunId="@_selectedRun.Id"
                                                           Patch="@GetWorkspaceResolvedDiffPatch()"
                                                           DiffStat="@GetWorkspaceResolvedDiffStat()" />
                                        }
                                    </div>
                                </MudTabPanel>

                                <MudTabPanel Text="Raw" Icon="@Icons.Material.Filled.DataObject">
                                    <div class="workspace-console-scroll">
                                        @if (_selectedRun is null)
                                        {
                                            <MudText Typo="Typo.body2" Color="Color.Secondary">Select a run from history to inspect payloads.</MudText>
                                        }
                                        else
                                        {
                                            <MudStack Spacing="1">
                                                <MudText Typo="Typo.caption">Run ID: @_selectedRun.Id</MudText>
                                                <MudText Typo="Typo.caption">Created: @_selectedRun.CreatedAtUtc.ToLocalTime().ToString("g")</MudText>
                                                <MudText Typo="Typo.caption">Summary: @(_selectedRun.Summary == string.Empty ? "-" : _selectedRun.Summary)</MudText>
                                                <MudStack Row Spacing="1">
                                                    <MudButton Variant="Variant.Outlined"
                                                               Size="Size.Small"
                                                               StartIcon="@Icons.Material.Filled.ContentCopy"
                                                               OnClick="CopySelectedRunStructuredEventsJsonAsync">
                                                        Copy Event JSON
                                                    </MudButton>
                                                </MudStack>
                                                <MudDivider />
                                                <MudText Typo="Typo.caption">Raw OutputJson</MudText>
                                                <pre class="workspace-raw-output">@GetSelectedRunRawOutput()</pre>

                                                <MudText Typo="Typo.caption">Structured Events (@_selectedRunStructuredEvents.Count)</MudText>
                                                <pre class="workspace-raw-output">@GetSelectedRunStructuredEventsJson()</pre>

                                                @if (_selectedRunParsed is not null && _selectedRunParsed.RawStream.Count > 0)
                                                {
                                                    <MudText Typo="Typo.caption">Raw Stream</MudText>
                                                    @foreach (var item in _selectedRunParsed.RawStream.TakeLast(240))
                                                    {
                                                        <MudText Typo="Typo.caption" Class="workspace-console-line">[@item.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")] [@item.Level] @item.Message</MudText>
                                                    }
                                                }
                                            </MudStack>
                                        }
                                    </div>
                                </MudTabPanel>
                            </MudTabs>

                            <MudDivider Class="my-2" />

                            <MudStack Spacing="1">
                                <MudText Typo="Typo.subtitle2">Prompt Composer</MudText>

                                <div class="workspace-composer-wrap">
                                    <div class="workspace-composer-ghost-layer" aria-hidden="true">
                                        <span class="workspace-composer-ghost-typed">@_composerValue</span><span class="workspace-composer-ghost-suggestion">@_composerGhostSuffix</span>
                                    </div>
                                    <textarea id="@_composerInputId"
                                              class="workspace-composer-input"
                                              rows="6"
                                              value="@_composerValue"
                                              @oninput="OnComposerInputChangedAsync"
                                              @onkeydown="OnComposerKeyDown"
                                              placeholder="Add run guidance, press Tab or ArrowRight to accept suggestion"></textarea>
                                </div>

                                <MudExpansionPanels Elevation="0">
                                    <MudExpansionPanel Text="Agent Team Configuration" Dense>
                                        @for (var index = 0; index < _agentTeamMembers.Count; index++)
                                        {
                                            <MudPaper Class="workspace-structured-section mb-1" Elevation="0">
                                                <MudText Typo="Typo.caption">Member @(index + 1)</MudText>
                                                <MudGrid>
                                                    <MudItem xs="12" md="2">
                                                        <MudSelect T="string" @bind-Value="_agentTeamMembers[index].Harness" Label="Harness" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true">
                                                            <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                                            <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                                            <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                                            <MudSelectItem T="string" Value='@("zai")'>Zai</MudSelectItem>
                                                        </MudSelect>
                                                    </MudItem>
                                                    <MudItem xs="12" md="2">
                                                        <MudSelect T="HarnessExecutionMode" @bind-Value="_agentTeamMembers[index].Mode" Label="Mode" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true">
                                                            <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Default">Default</MudSelectItem>
                                                            <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Plan">Plan</MudSelectItem>
                                                            <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Review">Review</MudSelectItem>
                                                        </MudSelect>
                                                    </MudItem>
                                                    <MudItem xs="12" md="4">
                                                        <MudTextField T="string" @bind-Value="_agentTeamMembers[index].RolePrompt" Label="Role Prompt" Variant="Variant.Outlined" Margin="Margin.Dense" />
                                                    </MudItem>
                                                    <MudItem xs="12" md="2">
                                                        <MudTextField T="string" @bind-Value="_agentTeamMembers[index].ModelOverride" Label="Model Override" Variant="Variant.Outlined" Margin="Margin.Dense" />
                                                    </MudItem>
                                                    <MudItem xs="12" md="2">
                                                        <MudNumericField T="int?" @bind-Value="_agentTeamMembers[index].TimeoutSeconds" Label="Timeout (sec)" Variant="Variant.Outlined" Margin="Margin.Dense" Min="1" />
                                                    </MudItem>
                                                </MudGrid>
                                            </MudPaper>
                                        }

                                        <MudPaper Class="workspace-structured-section mt-1" Elevation="0">
                                            <MudText Typo="Typo.caption">Synthesis</MudText>
                                            <MudGrid>
                                                <MudItem xs="12" md="2" Class="d-flex align-center">
                                                    <MudSwitch T="bool" @bind-Value="_agentTeamSynthesisEnabled" Label="Enabled" />
                                                </MudItem>
                                                <MudItem xs="12" md="2">
                                                    <MudSelect T="string" @bind-Value="_agentTeamSynthesisHarness" Label="Harness" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true">
                                                        <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                                        <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                                        <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                                        <MudSelectItem T="string" Value='@("zai")'>Zai</MudSelectItem>
                                                    </MudSelect>
                                                </MudItem>
                                                <MudItem xs="12" md="2">
                                                    <MudSelect T="HarnessExecutionMode" @bind-Value="_agentTeamSynthesisMode" Label="Mode" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true">
                                                        <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Default">Default</MudSelectItem>
                                                        <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Plan">Plan</MudSelectItem>
                                                        <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Review">Review</MudSelectItem>
                                                    </MudSelect>
                                                </MudItem>
                                                <MudItem xs="12" md="3">
                                                    <MudTextField T="string" @bind-Value="_agentTeamSynthesisModelOverride" Label="Model Override" Variant="Variant.Outlined" Margin="Margin.Dense" />
                                                </MudItem>
                                                <MudItem xs="12" md="3">
                                                    <MudNumericField T="int?" @bind-Value="_agentTeamSynthesisTimeoutSeconds" Label="Timeout (sec)" Variant="Variant.Outlined" Margin="Margin.Dense" Min="1" />
                                                </MudItem>
                                                <MudItem xs="12">
                                                    <MudTextField T="string" @bind-Value="_agentTeamSynthesisPrompt" Label="Synthesis Prompt" Variant="Variant.Outlined" Margin="Margin.Dense" />
                                                </MudItem>
                                            </MudGrid>
                                        </MudPaper>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>

                                <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                                    <MudText Typo="Typo.caption" Color="Color.Secondary">Composer guidance is submitted as follow-up prompt context.</MudText>
                                    <MudSelect T="HarnessExecutionMode?"
                                               @bind-Value="_composerModeOverride"
                                               Label="Run Mode"
                                               Variant="Variant.Outlined"
                                               Margin="Margin.Dense"
                                               Dense="true"
                                               Class="workspace-filter-select">
                                        <MudSelectItem T="HarnessExecutionMode?" Value="@((HarnessExecutionMode?)null)">Task Default</MudSelectItem>
                                        <MudSelectItem T="HarnessExecutionMode?" Value="@HarnessExecutionMode.Default">Default</MudSelectItem>
                                        <MudSelectItem T="HarnessExecutionMode?" Value="@HarnessExecutionMode.Plan">Plan</MudSelectItem>
                                        <MudSelectItem T="HarnessExecutionMode?" Value="@HarnessExecutionMode.Review">Review</MudSelectItem>
                                    </MudSelect>
                                    <MudSpacer />
                                    <MudButton Variant="Variant.Filled"
                                               Color="Color.Primary"
                                               OnClick="SubmitComposerAsync"
                                               Disabled="@_isSubmittingComposer">
                                        @if (_isSubmittingComposer)
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                            <span>Submitting...</span>
                                        }
                                        else
                                        {
                                            <span>Submit</span>
                                        }
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined"
                                               Color="Color.Warning"
                                               OnClick="RunAgainWithEditsAsync"
                                               Disabled="@(_selectedRun is null || _isSubmittingComposer)">
                                        Run Again With Edits
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined"
                                               Color="Color.Success"
                                               StartIcon="@Icons.Material.Filled.Groups"
                                               OnClick="SubmitDefaultAgentTeamAsync"
                                               Disabled="@_isSubmittingComposer">
                                        Agent Team Run
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined"
                                               Color="Color.Secondary"
                                               StartIcon="@Icons.Material.Filled.Tune"
                                               OnClick="() => OpenPromptDraftDialogAsync(PromptDraftMode.Improve)">
                                        Improve
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined"
                                               Color="Color.Info"
                                               StartIcon="@Icons.Material.Filled.AutoAwesome"
                                               OnClick="() => OpenPromptDraftDialogAsync(PromptDraftMode.Generate)">
                                        Generate
                                    </MudButton>
                                </MudStack>
                            </MudStack>
                        </MudPaper>

                        <MudPaper Class="@GetHistoryPanelClass()" Elevation="0">
                            <MudStack Row AlignItems="AlignItems.Center" Class="mb-2">
                                <MudText Typo="Typo.subtitle1">History</MudText>
                                <MudSpacer />
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@SelectedTaskRuns.Count runs</MudChip>
                            </MudStack>

                            <MudStack Row Spacing="1" Class="mb-2">
                                <MudSelect T="string"
                                           @bind-Value="_historyStateFilter"
                                           Label="State"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense"
                                           Dense="true"
                                           Class="workspace-filter-select">
                                    <MudSelectItem T="string" Value='@("all")'>All States</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("running")'>Running</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("queued")'>Queued</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("pendingapproval")'>Pending Approval</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("succeeded")'>Succeeded</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("failed")'>Failed</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("cancelled")'>Cancelled</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("obsolete")'>Obsolete</MudSelectItem>
                                </MudSelect>
                                <MudSelect T="string"
                                           @bind-Value="_historyModeFilter"
                                           Label="Mode"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense"
                                           Dense="true"
                                           Class="workspace-filter-select">
                                    <MudSelectItem T="string" Value='@("all")'>All Modes</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("default")'>Default</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("plan")'>Plan</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("review")'>Review</MudSelectItem>
                                </MudSelect>
                                <MudSelect T="string"
                                           @bind-Value="_historyHarnessFilter"
                                           Label="Harness"
                                           Variant="Variant.Outlined"
                                           Margin="Margin.Dense"
                                           Dense="true"
                                           Class="workspace-filter-select">
                                    <MudSelectItem T="string" Value='@("all")'>All Harnesses</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                    <MudSelectItem T="string" Value='@("zai")'>Zai</MudSelectItem>
                                </MudSelect>
                            </MudStack>

                            @if (SelectedTaskRuns.Count == 0)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">No execution history yet.</MudText>
                            }
                            else
                            {
                                <MudTimeline TimelinePosition="TimelinePosition.Start" TimelineOrientation="TimelineOrientation.Vertical">
                                    @foreach (var run in SelectedTaskRuns)
                                    {
                                        <MudTimelineItem Color="@GetStateColor(run.State)" Size="Size.Small">
                                            <ItemOpposite>
                                                <MudText Typo="Typo.caption">@run.CreatedAtUtc.ToLocalTime().ToString("g")</MudText>
                                            </ItemOpposite>
                                            <ItemContent>
                                                <MudPaper Class="@GetHistoryItemClass(run)" Elevation="0" @onclick="() => SelectRunAsync(run.Id)">
                                                    <MudStack Spacing="0">
                                                        <MudStack Row AlignItems="AlignItems.Center">
                                                            <MudText Typo="Typo.caption">@run.Id[..Math.Min(8, run.Id.Length)]</MudText>
                                                            <MudSpacer />
                                                            <MudChip T="string" Size="Size.Small" Color="@GetStateColor(run.State)">@run.State</MudChip>
                                                        </MudStack>
                                                        <MudText Typo="Typo.caption" Class="workspace-history-summary">@GetRunSummary(run)</MudText>
                                                    </MudStack>
                                                </MudPaper>
                                            </ItemContent>
                                        </MudTimelineItem>
                                    }
                                </MudTimeline>
                            }

                            @if (_selectedTaskPromptHistory.Count > 0)
                            {
                                <MudDivider Class="my-2" />
                                <MudText Typo="Typo.subtitle2">Prompt History</MudText>
                                @foreach (var entry in _selectedTaskPromptHistory.Take(12))
                                {
                                    <MudPaper Class="workspace-history-item" Elevation="0">
                                        <MudStack Spacing="0">
                                            <MudStack Row AlignItems="AlignItems.Center">
                                                <MudText Typo="Typo.caption">@entry.CreatedAtUtc.ToLocalTime().ToString("g")</MudText>
                                                <MudSpacer />
                                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@entry.Role</MudChip>
                                                @if (!string.IsNullOrWhiteSpace(entry.RunId))
                                                {
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Info">@entry.RunId[..Math.Min(8, entry.RunId.Length)]</MudChip>
                                                }
                                            </MudStack>
                                            <MudText Typo="Typo.caption">@TruncateForDisplay(entry.Content, 180)</MudText>
                                        </MudStack>
                                    </MudPaper>
                                }
                            }
                        </MudPaper>
                    </div>
                }
            </div>
        </div>
    }
</MudStack>

    <MudDialog @bind-Visible="_promptDraftDialogOpen" Options="_promptDraftDialogOptions" Class="workspace-prompt-dialog">
    <TitleContent>
        <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
            <MudText Typo="Typo.h6">@GetPromptDraftTitle()</MudText>
            @if (_isPromptDraftLoading)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
            }
        </MudStack>
    </TitleContent>
    <DialogContent>
        @if (_isPromptDraftLoading)
        {
            <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Class="workspace-draft-loading">
                <MudProgressCircular Indeterminate="true" />
            </MudStack>
        }
        else if (!string.IsNullOrWhiteSpace(_promptDraftError))
        {
            <MudAlert Severity="Severity.Warning">@_promptDraftError</MudAlert>
        }
        else
        {
            <MudTabs @bind-ActivePanelIndex="_promptDraftActivePanel" Elevation="0" Rounded>
                <MudTabPanel Text="Preview">
                    <MudPaper Class="workspace-draft-preview" Elevation="0">
                        <pre class="workspace-draft-preview-text">@_promptDraftValue</pre>
                    </MudPaper>
                </MudTabPanel>
                <MudTabPanel Text="Editor">
                    <div class="workspace-draft-editor-host">
                        <StandaloneCodeEditor @key="_promptDraftEditorKey"
                                              @ref="_promptDraftEditor"
                                              ConstructionOptions="DraftEditorOptions"
                                              CssClass="monaco-fill-parent" />
                    </div>
                </MudTabPanel>
            </MudTabs>
        }
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="ClosePromptDraftDialog">Close</MudButton>
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Secondary"
                   OnClick="RefreshPromptDraftPreviewAsync"
                   Disabled="@_isPromptDraftLoading">
            Refresh Preview
        </MudButton>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="ApplyPromptDraftAsync"
                   Disabled="@(_isPromptDraftLoading || string.IsNullOrWhiteSpace(_promptDraftValue))">
            Apply
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    private const string RepositoryFilterAll = "all";
    private const string RepositoryFilterAttention = "attention";
    private const string RepositoryFilterHealthy = "healthy";

    private const string TaskFilterAll = "all";
    private const string TaskFilterRunning = "running";
    private const string TaskFilterFailed = "failed";
    private const string TaskFilterSucceeded = "succeeded";
    private const string TaskFilterEnabled = "enabled";

    private static readonly string[] ComposerSuggestions =
    [
        "Focus on deterministic output and include validation commands.",
        "Include a concise checklist of changed files and risks.",
        "Validate with dotnet build src/AgentsDashboard.slnx -m --tl and summarize failures.",
        "Finish with a short markdown summary and concrete next steps."
    ];

    private bool _loading = true;
    private List<RepositoryDocument> _repositories = [];
    private RepositoryDocument? _selectedRepository;
    private List<TaskDocument> _selectedRepositoryTasks = [];
    private List<RunDocument> _selectedRepositoryRuns = [];
    private Dictionary<string, RunDocument> _latestRunsByTask = new(StringComparer.OrdinalIgnoreCase);
    private bool _taskStatusLoading;
    private TaskDocument? _selectedTask;
    private RunDocument? _selectedRun;
    private List<RunLogEvent> _selectedRunLogs = [];
    private ParsedHarnessOutput? _selectedRunParsed;
    private List<RunStructuredEventDocument> _selectedRunStructuredEvents = [];
    private RunDiffSnapshotDocument? _selectedRunDiffSnapshot;
    private RunStructuredViewSnapshot _selectedRunStructuredView = new(string.Empty, 0, [], [], [], null, DateTime.UtcNow);
    private RunAiSummaryDocument? _selectedRunAiSummary;
    private List<WorkspacePromptEntryDocument> _selectedTaskPromptHistory = [];

    private string _searchText = string.Empty;
    private string _repositoryFilter = RepositoryFilterAll;
    private string _taskFilter = TaskFilterAll;
    private int _recentTaskTargetCount = 5;
    private bool _searchInFlight;
    private string _searchError = string.Empty;
    private WorkspaceSearchResult? _searchResult;
    private List<WorkspaceSearchHit> _searchHits = [];
    private CancellationTokenSource? _searchDebounceCts;

    private bool _isCreateTaskMode;
    private bool _isCreatingTask;
    private MudTextField<string>? _createTaskNameField;
    private bool _pendingCreateTaskNameFocus;

    private string _createTaskName = string.Empty;
    private TaskKind _createTaskKind = TaskKind.OneShot;
    private string _createTaskHarness = "codex";
    private string _createTaskPrompt = "Describe the goal, constraints, validation, and output format.";
    private string _createTaskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Workspace run\",\"artifacts\":[]}'";
    private string _createTaskCron = string.Empty;
    private bool _createTaskAutoPr;
    private HarnessExecutionMode _createTaskModeDefault = HarnessExecutionMode.Default;

    private bool _isSubmittingComposer;
    private HarnessExecutionMode? _composerModeOverride;
    private string _composerValue = string.Empty;
    private string _composerGhostSuggestion = string.Empty;
    private string _composerGhostSuffix = string.Empty;
    private readonly string _composerInputId = $"workspace-composer-{Guid.NewGuid():N}";
    private CancellationTokenSource? _composerSuggestionCts;

    private bool _historyPanelOpen = true;
    private string _historyStateFilter = "all";
    private string _historyModeFilter = "all";
    private string _historyHarnessFilter = "all";
    private readonly List<WorkspaceTeamMemberDraft> _agentTeamMembers =
    [
        new()
        {
            Harness = "codex",
            Mode = HarnessExecutionMode.Plan,
            RolePrompt = "Planner. Produce an explicit implementation plan with ordered steps, risks, and validation checkpoints."
        },
        new()
        {
            Harness = "codex",
            Mode = HarnessExecutionMode.Default,
            RolePrompt = "Implementer. Execute the plan with concrete code changes and verification."
        },
        new()
        {
            Harness = "codex",
            Mode = HarnessExecutionMode.Review,
            RolePrompt = "Reviewer. Focus on defects, regressions, and missing tests. Return issue-first findings."
        }
    ];
    private bool _agentTeamSynthesisEnabled = true;
    private string _agentTeamSynthesisPrompt = "Synthesize planner, implementer, and reviewer outputs. Summarize consensus, conflicts, and the recommended final patch.";
    private string _agentTeamSynthesisHarness = string.Empty;
    private HarnessExecutionMode _agentTeamSynthesisMode = HarnessExecutionMode.Review;
    private string _agentTeamSynthesisModelOverride = string.Empty;
    private int? _agentTeamSynthesisTimeoutSeconds;

    private bool _promptDraftDialogOpen;
    private bool _isPromptDraftLoading;
    private string _promptDraftError = string.Empty;
    private string _promptDraftValue = string.Empty;
    private int _promptDraftActivePanel;
    private int _promptDraftEditorKey;
    private bool _pendingPromptDraftEditorSync;
    private StandaloneCodeEditor? _promptDraftEditor;
    private PromptDraftMode _promptDraftMode = PromptDraftMode.Generate;
    private readonly DialogOptions _promptDraftDialogOptions = new() { MaxWidth = MaxWidth.False, FullWidth = true, CloseOnEscapeKey = true };

    private IDisposable? _selectionSubscription;
    private IDisposable? _runLogSubscription;
    private IDisposable? _runStatusSubscription;
    private IDisposable? _structuredSubscription;
    private IDisposable? _diffSubscription;
    private IDisposable? _toolSubscription;
    private IJSObjectReference? _workspaceJsModule;
    private DotNetObjectReference<Workspace>? _dotNetRef;
    private string? _viewportListenerHandle;
    private string? _composerKeyBridgeHandle;

    private List<RepositoryGroup> FilteredRepositoryGroups
    {
        get
        {
            var filtered = _repositories
                .Where(MatchesRepositorySearch)
                .OrderBy(repo => repo.Name)
                .ToList();

            var attention = filtered.Where(IsAttentionRepository).ToList();
            var healthy = filtered.Where(repo => !IsAttentionRepository(repo)).ToList();
            var groups = new List<RepositoryGroup>();

            if ((_repositoryFilter == RepositoryFilterAll || _repositoryFilter == RepositoryFilterAttention) && attention.Count > 0)
            {
                groups.Add(new RepositoryGroup("Needs Attention", attention));
            }

            if ((_repositoryFilter == RepositoryFilterAll || _repositoryFilter == RepositoryFilterHealthy) && healthy.Count > 0)
            {
                groups.Add(new RepositoryGroup("Healthy", healthy));
            }

            return groups;
        }
    }

    private List<TaskDocument> FilteredRecentTasks
    {
        get
        {
            return _selectedRepositoryTasks
                .Where(MatchesTaskSearch)
                .Where(MatchesTaskFilter)
                .OrderByDescending(task => GetLatestRun(task.Id)?.CreatedAtUtc ?? task.CreatedAtUtc)
                .Take(_recentTaskTargetCount)
                .ToList();
        }
    }

    private List<RunDocument> SelectedTaskRuns =>
        _selectedTask is null
            ? []
            : _selectedRepositoryRuns
                .Where(run => run.TaskId == _selectedTask.Id)
                .Where(MatchesHistoryRunState)
                .Where(MatchesHistoryRunMode)
                .Where(MatchesHistoryRunHarness)
                .OrderByDescending(run => run.CreatedAtUtc)
                .Take(20)
                .ToList();

    protected override async Task OnInitializedAsync()
    {
        _selectionSubscription = SelectionService.Subscribe(_args =>
        {
            _ = InvokeAsync(OnExternalSelectionChangedAsync);
        });
        _runLogSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.SignalR.RunLogChunkEvent>(OnRunLogChunkAsync);
        _runStatusSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.SignalR.RunStatusChangedEvent>(OnRunStatusChangedAsync);
        _structuredSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.SignalR.RunStructuredEventChangedEvent>(OnRunStructuredEventChangedAsync);
        _diffSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.SignalR.RunDiffUpdatedEvent>(OnRunDiffUpdatedAsync);
        _toolSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.SignalR.RunToolTimelineUpdatedEvent>(OnRunToolTimelineUpdatedAsync);
        RefreshComposerSuggestionFallback();
        await LoadWorkspaceAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            _workspaceJsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./workspace.js");
            var viewportHeight = await _workspaceJsModule.InvokeAsync<int>("getViewportHeight");
            SetRecentTaskTargetCount(viewportHeight);
            _viewportListenerHandle = await _workspaceJsModule.InvokeAsync<string?>("registerViewportListener", _dotNetRef);
            await InvokeAsync(StateHasChanged);
        }

        if (_pendingCreateTaskNameFocus && _createTaskNameField is not null)
        {
            _pendingCreateTaskNameFocus = false;
            await _createTaskNameField.FocusAsync();
        }

        if (_workspaceJsModule is not null)
        {
            if (ShouldAttachComposerBridge() && _composerKeyBridgeHandle is null)
            {
                _composerKeyBridgeHandle = await _workspaceJsModule.InvokeAsync<string?>("registerComposerKeyBridge", _composerInputId, _dotNetRef);
            }
            else if (!ShouldAttachComposerBridge() && _composerKeyBridgeHandle is not null)
            {
                await _workspaceJsModule.InvokeVoidAsync("unregisterComposerKeyBridge", _composerKeyBridgeHandle);
                _composerKeyBridgeHandle = null;
            }
        }

        if (_promptDraftDialogOpen && _pendingPromptDraftEditorSync && _promptDraftEditor is not null)
        {
            _pendingPromptDraftEditorSync = false;
            await _promptDraftEditor.SetValue(_promptDraftValue);
        }
    }

    [JSInvokable]
    public Task OnWorkspaceViewportChanged(int viewportHeight)
    {
        SetRecentTaskTargetCount(viewportHeight);
        return InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public Task<bool> TryAcceptGhostSuggestionFromJs(string key, int selectionStart, int selectionEnd)
    {
        var accepted = (key == "Tab" || key == "ArrowRight") && TryAcceptGhostSuggestion(selectionStart, selectionEnd);
        if (accepted)
        {
            _ = InvokeAsync(StateHasChanged);
        }

        return Task.FromResult(accepted);
    }

    private async Task LoadWorkspaceAsync()
    {
        _loading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            _repositories = await Store.ListRepositoriesAsync(CancellationToken.None);

            var selectedRepositoryId = SelectionService.SelectedRepositoryId;
            if (string.IsNullOrWhiteSpace(selectedRepositoryId) || _repositories.All(repo => repo.Id != selectedRepositoryId))
            {
                selectedRepositoryId = _repositories.FirstOrDefault()?.Id;
            }

            if (!string.IsNullOrWhiteSpace(selectedRepositoryId))
            {
                await SelectRepositoryAsync(selectedRepositoryId, false);
            }
            else
            {
                _selectedRepository = null;
                _selectedRepositoryTasks = [];
                _selectedRepositoryRuns = [];
                _latestRunsByTask = new Dictionary<string, RunDocument>(StringComparer.OrdinalIgnoreCase);
                _selectedTask = null;
                _selectedRun = null;
                _selectedRunLogs = [];
                _selectedRunParsed = null;
                ClearSelectedRunStructuredState();
                _selectedRunAiSummary = null;
                _selectedTaskPromptHistory = [];
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load workspace: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnExternalSelectionChangedAsync()
    {
        var selectedRepositoryId = SelectionService.SelectedRepositoryId;
        if (string.IsNullOrWhiteSpace(selectedRepositoryId) || selectedRepositoryId == _selectedRepository?.Id)
        {
            return;
        }

        if (_repositories.All(repo => repo.Id != selectedRepositoryId))
        {
            _repositories = await Store.ListRepositoriesAsync(CancellationToken.None);
        }

        await SelectRepositoryAsync(selectedRepositoryId, false);
    }

    private async Task SelectRepositoryAsync(string repositoryId, bool syncSelection)
    {
        var repository = _repositories.FirstOrDefault(repo => repo.Id == repositoryId);
        if (repository is null)
        {
            return;
        }

        _selectedRepository = repository;
        _isCreateTaskMode = false;
        _selectedTask = null;
        _selectedRun = null;
        _selectedRunLogs = [];
        _selectedRunParsed = null;
        ClearSelectedRunStructuredState();
        _selectedRunAiSummary = null;
        _selectedTaskPromptHistory = [];

        if (syncSelection && SelectionService.SelectedRepositoryId != repositoryId)
        {
            await SelectionService.SelectRepositoryAsync(repositoryId, CancellationToken.None);
        }

        await LoadSelectedRepositoryDataAsync(repositoryId, preserveTaskSelection: false);
        if (!string.IsNullOrWhiteSpace(_searchText))
        {
            await QueueSearchAsync();
        }
    }

    private async Task LoadSelectedRepositoryDataAsync(string repositoryId, bool preserveTaskSelection)
    {
        var previousTaskId = preserveTaskSelection ? _selectedTask?.Id : null;
        var previousRunId = preserveTaskSelection ? _selectedRun?.Id : null;
        _taskStatusLoading = true;
        try
        {
            _selectedRepositoryTasks = await Store.ListTasksAsync(repositoryId, CancellationToken.None);
            _selectedRepositoryRuns = await Store.ListRunsByRepositoryAsync(repositoryId, CancellationToken.None);
            _selectedRepositoryRuns = _selectedRepositoryRuns.OrderByDescending(run => run.CreatedAtUtc).ToList();

            RebuildLatestRunsIndex();

            if (!string.IsNullOrWhiteSpace(previousTaskId) && _selectedRepositoryTasks.Any(task => task.Id == previousTaskId))
            {
                await SelectTaskAsync(previousTaskId, preserveRunSelection: true, preferredRunId: previousRunId);
                return;
            }

            var defaultTask = _selectedRepositoryTasks
                .OrderByDescending(task => GetLatestRun(task.Id)?.CreatedAtUtc ?? task.CreatedAtUtc)
                .FirstOrDefault();

            if (defaultTask is null)
            {
                _selectedTask = null;
                _selectedRun = null;
                _selectedRunLogs = [];
                _selectedRunParsed = null;
                ClearSelectedRunStructuredState();
                _selectedRunAiSummary = null;
                _selectedTaskPromptHistory = [];
                return;
            }

            await SelectTaskAsync(defaultTask.Id, preserveRunSelection: false, preferredRunId: null);
        }
        finally
        {
            _taskStatusLoading = false;
        }
    }

    private Task SelectTaskAsync(string taskId)
    {
        return SelectTaskAsync(taskId, preserveRunSelection: false, preferredRunId: null);
    }

    private async Task SelectTaskAsync(string taskId, bool preserveRunSelection, string? preferredRunId)
    {
        var task = _selectedRepositoryTasks.FirstOrDefault(item => item.Id == taskId);
        if (task is null)
        {
            return;
        }

        _isCreateTaskMode = false;
        _selectedTask = task;
        _composerModeOverride = null;
        foreach (var member in _agentTeamMembers)
        {
            member.Harness = task.Harness;
        }
        _agentTeamSynthesisHarness = task.Harness;
        _selectedTaskPromptHistory = await Store.ListWorkspacePromptHistoryAsync(task.Id, 80, CancellationToken.None);

        var taskRuns = GetRunsForTask(task.Id);
        RunDocument? selectedRun = null;

        if (preserveRunSelection && !string.IsNullOrWhiteSpace(preferredRunId))
        {
            selectedRun = taskRuns.FirstOrDefault(run => run.Id == preferredRunId);
        }

        selectedRun ??= taskRuns
            .Where(run => run.State is RunState.Running or RunState.Queued or RunState.PendingApproval)
            .OrderByDescending(run => run.CreatedAtUtc)
            .FirstOrDefault();
        selectedRun ??= taskRuns
            .Where(run => run.State is RunState.Succeeded or RunState.Failed or RunState.Cancelled)
            .OrderByDescending(run => run.EndedAtUtc ?? run.CreatedAtUtc)
            .FirstOrDefault();
        selectedRun ??= taskRuns.FirstOrDefault();

        if (selectedRun is null)
        {
            _selectedRun = null;
            _selectedRunLogs = [];
            _selectedRunParsed = null;
            ClearSelectedRunStructuredState();
            _selectedRunAiSummary = null;
        }
        else
        {
            await SelectRunAsync(selectedRun.Id);
        }

        _ = QueueComposerSuggestionAsync();
    }

    private async Task SelectRunAsync(string runId)
    {
        var run = _selectedRepositoryRuns.FirstOrDefault(item => item.Id == runId);
        if (run is null)
        {
            _selectedRun = null;
            _selectedRunLogs = [];
            _selectedRunParsed = null;
            ClearSelectedRunStructuredState();
            _selectedRunAiSummary = null;
            return;
        }

        _selectedRun = run;
        _selectedRunLogs = await Store.ListRunLogsAsync(run.Id, CancellationToken.None);
        _selectedRunLogs = _selectedRunLogs.OrderBy(log => log.TimestampUtc).ToList();
        _selectedRunParsed = HarnessOutputParser.Parse(_selectedRun.OutputJson, _selectedRunLogs);
        await RefreshSelectedRunStructuredStateAsync(run.Id);
        _selectedRunAiSummary = await Store.GetRunAiSummaryAsync(run.Id, CancellationToken.None);
        await RefreshRunSummaryAsync(force: false);
    }

    private async Task OnRunLogChunkAsync(AgentsDashboard.Contracts.SignalR.RunLogChunkEvent logEvent)
    {
        if (_selectedRun is null || !string.Equals(logEvent.RunId, _selectedRun.Id, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        _selectedRunLogs.Add(new RunLogEvent
        {
            RunId = logEvent.RunId,
            Level = logEvent.Level,
            Message = logEvent.Message,
            TimestampUtc = logEvent.Timestamp,
        });
        _selectedRunLogs = _selectedRunLogs.OrderBy(log => log.TimestampUtc).ToList();
        _selectedRunParsed = HarnessOutputParser.Parse(_selectedRun.OutputJson, _selectedRunLogs);
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnRunStatusChangedAsync(AgentsDashboard.Contracts.SignalR.RunStatusChangedEvent statusEvent)
    {
        if (_selectedRepository is null ||
            _selectedRepositoryRuns.All(run => !string.Equals(run.Id, statusEvent.RunId, StringComparison.OrdinalIgnoreCase)))
        {
            return;
        }

        var refreshed = await Store.GetRunAsync(statusEvent.RunId, CancellationToken.None);
        if (refreshed is null || !string.Equals(refreshed.RepositoryId, _selectedRepository.Id, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        var existingIndex = _selectedRepositoryRuns.FindIndex(run => string.Equals(run.Id, refreshed.Id, StringComparison.OrdinalIgnoreCase));
        if (existingIndex >= 0)
        {
            _selectedRepositoryRuns[existingIndex] = refreshed;
        }
        else
        {
            _selectedRepositoryRuns.Add(refreshed);
        }

        _selectedRepositoryRuns = _selectedRepositoryRuns
            .OrderByDescending(run => run.CreatedAtUtc)
            .ToList();
        RebuildLatestRunsIndex();

        if (_selectedRun is not null && string.Equals(_selectedRun.Id, refreshed.Id, StringComparison.OrdinalIgnoreCase))
        {
            _selectedRun = refreshed;
            _selectedRunParsed = HarnessOutputParser.Parse(_selectedRun.OutputJson, _selectedRunLogs);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnRunStructuredEventChangedAsync(AgentsDashboard.Contracts.SignalR.RunStructuredEventChangedEvent structuredEvent)
    {
        if (_selectedRun is null || !string.Equals(_selectedRun.Id, structuredEvent.RunId, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        await RefreshSelectedRunStructuredStateAsync(structuredEvent.RunId);
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnRunDiffUpdatedAsync(AgentsDashboard.Contracts.SignalR.RunDiffUpdatedEvent diffEvent)
    {
        if (_selectedRun is null || !string.Equals(_selectedRun.Id, diffEvent.RunId, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        await RefreshSelectedRunStructuredStateAsync(diffEvent.RunId);
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnRunToolTimelineUpdatedAsync(AgentsDashboard.Contracts.SignalR.RunToolTimelineUpdatedEvent toolEvent)
    {
        if (_selectedRun is null || !string.Equals(_selectedRun.Id, toolEvent.RunId, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        await RefreshSelectedRunStructuredStateAsync(toolEvent.RunId);
        await InvokeAsync(StateHasChanged);
    }

    private async Task RefreshSelectedRunStructuredStateAsync(string? expectedRunId = null)
    {
        var runId = expectedRunId;
        if (string.IsNullOrWhiteSpace(runId))
        {
            runId = _selectedRun?.Id;
        }

        if (string.IsNullOrWhiteSpace(runId))
        {
            ClearSelectedRunStructuredState();
            return;
        }

        var structuredEvents = await Store.ListRunStructuredEventsAsync(runId, 2000, CancellationToken.None);
        var diffSnapshot = await Store.GetLatestRunDiffSnapshotAsync(runId, CancellationToken.None);
        var structuredView = await RunStructuredViewService.GetViewAsync(runId, CancellationToken.None);

        if (_selectedRun is null || !string.Equals(_selectedRun.Id, runId, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        _selectedRunStructuredEvents = structuredEvents;
        _selectedRunDiffSnapshot = diffSnapshot;
        _selectedRunStructuredView = structuredView;
    }

    private async Task RefreshRunSummaryAsync(bool force)
    {
        if (_selectedRepository is null || _selectedRun is null)
        {
            return;
        }

        var result = await WorkspaceService.RefreshRunSummaryAsync(
            _selectedRepository.Id,
            _selectedRun.Id,
            eventType: "run-selected",
            force,
            CancellationToken.None);

        if (!result.Success)
        {
            return;
        }

        _selectedRunAiSummary = await Store.GetRunAiSummaryAsync(_selectedRun.Id, CancellationToken.None)
            ?? _selectedRunAiSummary;

        if (_selectedRunAiSummary is null && !string.IsNullOrWhiteSpace(result.Summary))
        {
            _selectedRunAiSummary = new RunAiSummaryDocument
            {
                RunId = _selectedRun.Id,
                RepositoryId = _selectedRun.RepositoryId,
                TaskId = _selectedRun.TaskId,
                Title = "Run summary",
                Summary = result.Summary,
                Model = result.UsedFallback ? "fallback" : "glm-5",
                GeneratedAtUtc = DateTime.UtcNow,
            };
        }
    }

    private async Task RefreshSelectedRepositoryAsync()
    {
        if (_selectedRepository is null)
        {
            return;
        }

        await LoadSelectedRepositoryDataAsync(_selectedRepository.Id, preserveTaskSelection: true);
        if (!string.IsNullOrWhiteSpace(_searchText))
        {
            await QueueSearchAsync();
        }
    }

    private async Task OpenCreateTaskFormAsync()
    {
        if (_selectedRepository is null)
        {
            if (_repositories.Count == 0)
            {
                Snackbar.Add("Create a repository first.", Severity.Warning);
                return;
            }

            await SelectRepositoryAsync(_repositories[0].Id, true);
        }

        ResetCreateTaskForm();
        _isCreateTaskMode = true;
        _pendingCreateTaskNameFocus = true;
    }

    private void CloseCreateTaskForm()
    {
        _isCreateTaskMode = false;
    }

    private void ResetCreateTaskForm()
    {
        _createTaskName = string.Empty;
        _createTaskKind = TaskKind.OneShot;
        _createTaskHarness = "codex";
        _createTaskPrompt = "Describe the goal, constraints, validation, and output format.";
        _createTaskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Workspace run\",\"artifacts\":[]}'";
        _createTaskCron = string.Empty;
        _createTaskAutoPr = false;
        _createTaskModeDefault = HarnessExecutionMode.Default;
    }

    private async Task CreateTaskAsync()
    {
        if (_selectedRepository is null)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_createTaskName))
        {
            Snackbar.Add("Task name is required.", Severity.Warning);
            return;
        }

        _isCreatingTask = true;

        try
        {
            var request = new CreateTaskRequest(
                RepositoryId: _selectedRepository.Id,
                Name: _createTaskName.Trim(),
                Kind: _createTaskKind,
                Harness: _createTaskHarness,
                Prompt: _createTaskPrompt,
                Command: _createTaskCommand,
                AutoCreatePullRequest: _createTaskAutoPr,
                CronExpression: _createTaskCron,
                Enabled: true,
                ExecutionModeDefault: _createTaskModeDefault);

            var created = await Store.CreateTaskAsync(request, CancellationToken.None);
            _isCreateTaskMode = false;
            await LoadSelectedRepositoryDataAsync(_selectedRepository.Id, preserveTaskSelection: false);
            await SelectTaskAsync(created.Id);
            Snackbar.Add("Task created.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create task: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCreatingTask = false;
        }
    }

    private Task SubmitComposerAsync()
    {
        return SubmitComposerAsync(forceNewRun: false);
    }

    private async Task SubmitComposerAsync(bool forceNewRun)
    {
        if (_selectedRepository is null || _selectedTask is null)
        {
            return;
        }

        var composerText = _composerValue.Trim();
        if (string.IsNullOrWhiteSpace(composerText))
        {
            Snackbar.Add("Enter prompt guidance first.", Severity.Info);
            return;
        }

        _isSubmittingComposer = true;

        try
        {
            var submission = await WorkspaceService.SubmitPromptAsync(
                _selectedRepository.Id,
                new WorkspacePromptSubmissionRequest(
                    Prompt: MergePrompt(_selectedTask.Prompt, composerText),
                    TaskId: _selectedTask.Id,
                    Harness: _selectedTask.Harness,
                    Command: _selectedTask.Command,
                    ForceNewRun: forceNewRun,
                    UserMessage: composerText,
                    ModeOverride: _composerModeOverride),
                CancellationToken.None);

            if (!submission.Success)
            {
                Snackbar.Add(submission.Message, Severity.Warning);
                return;
            }

            if (submission.Task is not null)
            {
                _selectedTask = submission.Task;
            }

            _composerValue = string.Empty;
            _ = QueueComposerSuggestionAsync();

            await LoadSelectedRepositoryDataAsync(_selectedRepository.Id, preserveTaskSelection: true);

            if (submission.Run is not null)
            {
                await SelectRunAsync(submission.Run.Id);
            }

            Snackbar.Add(submission.Message, submission.DispatchAccepted ? Severity.Success : Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Submit failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSubmittingComposer = false;
        }
    }

    private async Task RunAgainWithEditsAsync()
    {
        if (_selectedRun is null)
        {
            Snackbar.Add("Select a historical run first.", Severity.Info);
            return;
        }

        if (string.IsNullOrWhiteSpace(_composerValue))
        {
            _composerValue = $"Follow-up based on run {_selectedRun.Id[..Math.Min(8, _selectedRun.Id.Length)]}: ";
            _ = QueueComposerSuggestionAsync();
            Snackbar.Add("Composer prefilled. Edit and submit.", Severity.Info);
            return;
        }

        await SubmitComposerAsync(forceNewRun: true);
    }

    private async Task SubmitDefaultAgentTeamAsync()
    {
        if (_selectedRepository is null || _selectedTask is null)
        {
            return;
        }

        var composerText = _composerValue.Trim();
        if (string.IsNullOrWhiteSpace(composerText))
        {
            Snackbar.Add("Enter prompt guidance first.", Severity.Info);
            return;
        }

        _isSubmittingComposer = true;

        try
        {
            var mergedPrompt = MergePrompt(_selectedTask.Prompt, composerText);
            var harness = _selectedTask.Harness;
            var teamMembers = _agentTeamMembers
                .Select(member => new WorkspaceAgentTeamMemberRequest(
                    Harness: string.IsNullOrWhiteSpace(member.Harness) ? harness : member.Harness,
                    Mode: member.Mode,
                    RolePrompt: string.IsNullOrWhiteSpace(member.RolePrompt) ? "Team member" : member.RolePrompt.Trim(),
                    ModelOverride: string.IsNullOrWhiteSpace(member.ModelOverride) ? null : member.ModelOverride.Trim(),
                    TimeoutSeconds: member.TimeoutSeconds))
                .ToList();

            if (teamMembers.Count == 0)
            {
                Snackbar.Add("Configure at least one team member.", Severity.Warning);
                return;
            }

            var synthesisHarness = string.IsNullOrWhiteSpace(_agentTeamSynthesisHarness)
                ? harness
                : _agentTeamSynthesisHarness.Trim();
            var teamRequest = new WorkspaceAgentTeamRequest(
                Members: teamMembers,
                Synthesis: new WorkspaceAgentTeamSynthesisRequest(
                    Enabled: _agentTeamSynthesisEnabled,
                    Prompt: string.IsNullOrWhiteSpace(_agentTeamSynthesisPrompt)
                        ? "Synthesize team outputs and return the recommended final patch."
                        : _agentTeamSynthesisPrompt.Trim(),
                    Harness: synthesisHarness,
                    Mode: _agentTeamSynthesisMode,
                    ModelOverride: string.IsNullOrWhiteSpace(_agentTeamSynthesisModelOverride) ? null : _agentTeamSynthesisModelOverride.Trim(),
                    TimeoutSeconds: _agentTeamSynthesisTimeoutSeconds));

            var submission = await WorkspaceService.SubmitPromptAsync(
                _selectedRepository.Id,
                new WorkspacePromptSubmissionRequest(
                    Prompt: mergedPrompt,
                    TaskId: _selectedTask.Id,
                    Harness: harness,
                    Command: _selectedTask.Command,
                    ForceNewRun: true,
                    UserMessage: composerText,
                    ModeOverride: _composerModeOverride,
                    AgentTeam: teamRequest),
                CancellationToken.None);

            if (!submission.Success)
            {
                Snackbar.Add(submission.Message, Severity.Warning);
                return;
            }

            if (submission.Task is not null)
            {
                _selectedTask = submission.Task;
            }

            _composerValue = string.Empty;
            _ = QueueComposerSuggestionAsync();
            await LoadSelectedRepositoryDataAsync(_selectedRepository.Id, preserveTaskSelection: true);

            if (submission.Run is not null)
            {
                await SelectRunAsync(submission.Run.Id);
            }

            var severity = submission.DispatchAccepted ? Severity.Success : Severity.Info;
            var message = submission.WorkflowExecution is null
                ? submission.Message
                : $"Agent team run queued. Workflow {submission.WorkflowExecution.Id[..Math.Min(8, submission.WorkflowExecution.Id.Length)]}.";
            Snackbar.Add(message, severity);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Team run submit failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSubmittingComposer = false;
        }
    }

    private async Task OpenPromptDraftDialogAsync(PromptDraftMode mode)
    {
        if (_selectedRepository is null || _selectedTask is null)
        {
            Snackbar.Add("Select a task first.", Severity.Warning);
            return;
        }

        _promptDraftMode = mode;
        _promptDraftDialogOpen = true;
        _isPromptDraftLoading = true;
        _promptDraftError = string.Empty;
        _promptDraftValue = string.Empty;
        _promptDraftActivePanel = 0;
        _promptDraftEditorKey++;
        _pendingPromptDraftEditorSync = false;
        StateHasChanged();

        try
        {
            WorkspaceAiTextResult result;
            if (mode == PromptDraftMode.Improve)
            {
                result = await WorkspaceAiService.ImprovePromptAsync(
                    _selectedRepository.Id,
                    _selectedTask.Prompt,
                    _composerValue,
                    CancellationToken.None);
            }
            else
            {
                result = await WorkspaceAiService.GeneratePromptFromContextAsync(
                    _selectedRepository.Id,
                    BuildPromptGenerationContext(),
                    CancellationToken.None);
            }

            if (!result.Success || string.IsNullOrWhiteSpace(result.Text))
            {
                _promptDraftError = result.Message ?? "Prompt generation failed.";
                return;
            }

            _promptDraftValue = result.Text;
            _pendingPromptDraftEditorSync = true;
        }
        catch (Exception ex)
        {
            _promptDraftError = $"Prompt generation failed: {ex.Message}";
        }
        finally
        {
            _isPromptDraftLoading = false;
            StateHasChanged();
        }
    }

    private void ClosePromptDraftDialog()
    {
        _promptDraftDialogOpen = false;
        _isPromptDraftLoading = false;
        _promptDraftError = string.Empty;
    }

    private async Task RefreshPromptDraftPreviewAsync()
    {
        if (_promptDraftEditor is not null)
        {
            _promptDraftValue = await _promptDraftEditor.GetValue();
        }
    }

    private async Task ApplyPromptDraftAsync()
    {
        if (_selectedTask is null || _selectedRepository is null)
        {
            return;
        }

        var promptValue = _promptDraftEditor is not null
            ? await _promptDraftEditor.GetValue()
            : _promptDraftValue;

        if (string.IsNullOrWhiteSpace(promptValue))
        {
            Snackbar.Add("Draft is empty.", Severity.Warning);
            return;
        }

        try
        {
            var updateRequest = ToUpdateRequest(_selectedTask, promptValue);
            var updatedTask = await Store.UpdateTaskAsync(_selectedTask.Id, updateRequest, CancellationToken.None);
            if (updatedTask is not null)
            {
                _selectedTask = updatedTask;
            }

            _promptDraftDialogOpen = false;
            await LoadSelectedRepositoryDataAsync(_selectedRepository.Id, preserveTaskSelection: true);
            Snackbar.Add("Task prompt updated.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to apply prompt: {ex.Message}", Severity.Error);
        }
    }

    private string GetPromptDraftTitle()
    {
        return _promptDraftMode switch
        {
            PromptDraftMode.Improve => "Improve Prompt Draft",
            _ => "Generate Prompt Draft"
        };
    }

    private string BuildPromptGenerationContext()
    {
        return $"""
Task: {_selectedTask?.Name}
Harness: {_selectedTask?.Harness}
Kind: {_selectedTask?.Kind}
Command: {_selectedTask?.Command}
Existing Prompt:
{_selectedTask?.Prompt}

Composer Focus:
{_composerValue}
""";
    }

    private StandaloneEditorConstructionOptions DraftEditorOptions(StandaloneCodeEditor editor) => new()
    {
        AutomaticLayout = true,
        Language = "markdown",
        Theme = "agents-dashboard-dark",
        Minimap = new EditorMinimapOptions { Enabled = false },
        WordWrap = "on",
        FontSize = 13,
        Value = _promptDraftValue,
    };

    private async Task OnSearchTextChangedAsync(string value)
    {
        _searchText = value ?? string.Empty;
        await QueueSearchAsync();
    }

    private async Task QueueSearchAsync()
    {
        _searchDebounceCts?.Cancel();
        _searchDebounceCts?.Dispose();

        if (string.IsNullOrWhiteSpace(_searchText) || _selectedRepository is null)
        {
            _searchResult = null;
            _searchHits.Clear();
            _searchError = string.Empty;
            _searchInFlight = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var cts = new CancellationTokenSource();
        _searchDebounceCts = cts;

        try
        {
            await Task.Delay(TimeSpan.FromMilliseconds(350), cts.Token);

            _searchInFlight = true;
            _searchError = string.Empty;
            await InvokeAsync(StateHasChanged);

            var result = await WorkspaceSearchService.SearchAsync(
                new WorkspaceSearchRequest(_selectedRepository.Id, _searchText, Limit: 20, IncludeRunLogs: true),
                cts.Token);

            _searchResult = result;
            _searchHits = result.Hits.ToList();
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            _searchError = ex.Message;
            _searchHits.Clear();
        }
        finally
        {
            if (ReferenceEquals(_searchDebounceCts, cts))
            {
                _searchInFlight = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task JumpToSearchHitAsync(WorkspaceSearchHit hit)
    {
        if (_selectedRepository is null)
        {
            return;
        }

        if (!string.IsNullOrWhiteSpace(hit.TaskId))
        {
            await SelectTaskAsync(hit.TaskId, preserveRunSelection: true, preferredRunId: hit.RunId);
        }

        if (!string.IsNullOrWhiteSpace(hit.RunId))
        {
            await SelectRunAsync(hit.RunId);
        }

        _historyPanelOpen = true;
    }

    private string BuildGlobalSearchHref()
    {
        var repoPart = _selectedRepository is null
            ? string.Empty
            : $"repo={Uri.EscapeDataString(_selectedRepository.Id)}";
        var queryPart = string.IsNullOrWhiteSpace(_searchText)
            ? string.Empty
            : $"q={Uri.EscapeDataString(_searchText.Trim())}";

        if (repoPart.Length == 0 && queryPart.Length == 0)
        {
            return "/search";
        }

        if (repoPart.Length == 0)
        {
            return $"/search?{queryPart}";
        }

        if (queryPart.Length == 0)
        {
            return $"/search?{repoPart}";
        }

        return $"/search?{repoPart}&{queryPart}";
    }

    private string FormatHitKind(string kind)
    {
        return kind switch
        {
            "task" => "Task",
            "run-log" => "Run Msg",
            "run-message" => "Run Msg",
            "run" => "Run",
            "finding" => "Finding",
            _ => "Result"
        };
    }

    private async Task OnComposerInputChangedAsync(ChangeEventArgs args)
    {
        _composerValue = args.Value?.ToString() ?? string.Empty;
        await QueueComposerSuggestionAsync();
    }

    private async Task QueueComposerSuggestionAsync()
    {
        RefreshComposerSuggestionFallback();

        _composerSuggestionCts?.Cancel();
        _composerSuggestionCts?.Dispose();

        if (_selectedRepository is null || _selectedTask is null)
        {
            return;
        }

        if (_composerValue.Length < 12)
        {
            return;
        }

        var cts = new CancellationTokenSource();
        _composerSuggestionCts = cts;

        try
        {
            await Task.Delay(TimeSpan.FromMilliseconds(600), cts.Token);

            if (_workspaceJsModule is not null)
            {
                var selection = await _workspaceJsModule.InvokeAsync<int[]>("getInputSelection", _composerInputId);
                if (selection.Length >= 2)
                {
                    var atEnd = selection[0] == _composerValue.Length && selection[1] == _composerValue.Length;
                    if (!atEnd)
                    {
                        return;
                    }
                }
            }

            var result = await WorkspaceAiService.SuggestPromptContinuationAsync(
                _selectedRepository.Id,
                _composerValue,
                BuildPromptGenerationContext(),
                cts.Token);

            if (!result.Success || string.IsNullOrWhiteSpace(result.Text))
            {
                return;
            }

            if (ReferenceEquals(_composerSuggestionCts, cts) && result.Text.Length > 0)
            {
                if (result.Text.StartsWith(_composerValue, StringComparison.OrdinalIgnoreCase))
                {
                    _composerGhostSuggestion = result.Text;
                    _composerGhostSuffix = result.Text[_composerValue.Length..];
                }
                else
                {
                    _composerGhostSuggestion = _composerValue + result.Text;
                    _composerGhostSuffix = result.Text;
                }

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch
        {
        }
    }

    private async Task OnComposerKeyDown(KeyboardEventArgs args)
    {
        if (args.Key is "Tab" or "ArrowRight")
        {
            if (TryAcceptGhostSuggestion(_composerValue.Length, _composerValue.Length))
            {
                await InvokeAsync(StateHasChanged);
            }

            return;
        }

        if (args.Key == "Enter" && !args.ShiftKey)
        {
            await SubmitComposerAsync();
        }
    }

    private bool TryAcceptGhostSuggestion(int selectionStart, int selectionEnd)
    {
        if (string.IsNullOrEmpty(_composerGhostSuffix))
        {
            return false;
        }

        if (selectionStart != _composerValue.Length || selectionEnd != _composerValue.Length)
        {
            return false;
        }

        _composerValue = string.Concat(_composerValue, _composerGhostSuffix);
        _ = QueueComposerSuggestionAsync();
        return true;
    }

    private void RefreshComposerSuggestionFallback()
    {
        if (string.IsNullOrEmpty(_composerValue))
        {
            _composerGhostSuggestion = ComposerSuggestions[0];
            _composerGhostSuffix = _composerGhostSuggestion;
            return;
        }

        var suggestion = ComposerSuggestions.FirstOrDefault(candidate =>
            candidate.StartsWith(_composerValue, StringComparison.OrdinalIgnoreCase) &&
            candidate.Length > _composerValue.Length);

        _composerGhostSuggestion = suggestion ?? string.Empty;
        _composerGhostSuffix = _composerGhostSuggestion.Length == 0
            ? string.Empty
            : _composerGhostSuggestion[_composerValue.Length..];
    }

    private void SetRecentTaskTargetCount(int viewportHeight)
    {
        if (viewportHeight <= 0)
        {
            _recentTaskTargetCount = 5;
            return;
        }

        var estimated = (int)Math.Round((viewportHeight - 340) / 96d, MidpointRounding.AwayFromZero);
        _recentTaskTargetCount = Math.Clamp(estimated, 3, 10);
    }

    private bool ShouldAttachComposerBridge()
    {
        return _selectedTask is not null && !_isCreateTaskMode;
    }

    private void RebuildLatestRunsIndex()
    {
        _latestRunsByTask = _selectedRepositoryRuns
            .GroupBy(run => run.TaskId)
            .ToDictionary(
                group => group.Key,
                group => group.OrderByDescending(run => run.CreatedAtUtc).First(),
                StringComparer.OrdinalIgnoreCase);
    }

    private RunDocument? GetLatestRun(string taskId)
    {
        return _latestRunsByTask.TryGetValue(taskId, out var run)
            ? run
            : null;
    }

    private List<RunDocument> GetRunsForTask(string taskId)
    {
        return _selectedRepositoryRuns
            .Where(run => run.TaskId == taskId)
            .OrderByDescending(run => run.CreatedAtUtc)
            .ToList();
    }

    private bool MatchesRepositorySearch(RepositoryDocument repository)
    {
        if (string.IsNullOrWhiteSpace(_searchText))
        {
            return true;
        }

        return repository.Name.Contains(_searchText, StringComparison.OrdinalIgnoreCase)
               || repository.GitUrl.Contains(_searchText, StringComparison.OrdinalIgnoreCase)
               || repository.LocalPath.Contains(_searchText, StringComparison.OrdinalIgnoreCase);
    }

    private bool MatchesTaskSearch(TaskDocument task)
    {
        if (string.IsNullOrWhiteSpace(_searchText))
        {
            return true;
        }

        return task.Name.Contains(_searchText, StringComparison.OrdinalIgnoreCase)
               || task.Harness.Contains(_searchText, StringComparison.OrdinalIgnoreCase)
               || task.Prompt.Contains(_searchText, StringComparison.OrdinalIgnoreCase);
    }

    private bool MatchesTaskFilter(TaskDocument task)
    {
        var latestRun = GetLatestRun(task.Id);

        return _taskFilter switch
        {
            TaskFilterRunning => latestRun?.State is RunState.Running or RunState.Queued or RunState.PendingApproval,
            TaskFilterFailed => latestRun?.State is RunState.Failed,
            TaskFilterSucceeded => latestRun?.State is RunState.Succeeded,
            TaskFilterEnabled => task.Enabled,
            _ => true
        };
    }

    private bool MatchesHistoryRunState(RunDocument run)
    {
        if (string.Equals(_historyStateFilter, "all", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return string.Equals(_historyStateFilter, run.State.ToString(), StringComparison.OrdinalIgnoreCase);
    }

    private bool MatchesHistoryRunMode(RunDocument run)
    {
        if (string.Equals(_historyModeFilter, "all", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return string.Equals(_historyModeFilter, run.ExecutionMode.ToString(), StringComparison.OrdinalIgnoreCase);
    }

    private bool MatchesHistoryRunHarness(RunDocument run)
    {
        if (string.Equals(_historyHarnessFilter, "all", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (_selectedTask is not null && string.Equals(_selectedTask.Harness, _historyHarnessFilter, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return string.Equals(run.StructuredProtocol, _historyHarnessFilter, StringComparison.OrdinalIgnoreCase)
               || run.StructuredProtocol.Contains(_historyHarnessFilter, StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsAttentionRepository(RepositoryDocument repository)
    {
        return !string.IsNullOrWhiteSpace(repository.LastSyncError)
               || repository.ModifiedCount > 0
               || repository.StagedCount > 0
               || repository.UntrackedCount > 0
               || repository.BehindCount > 0;
    }

    private string GetRepositoryCardClass(RepositoryDocument repository)
    {
        return repository.Id == _selectedRepository?.Id
            ? "workspace-repository-card workspace-repository-card-selected"
            : "workspace-repository-card";
    }

    private string GetTaskCardClass(TaskDocument task)
    {
        return task.Id == _selectedTask?.Id
            ? "workspace-task-card workspace-task-card-selected"
            : "workspace-task-card";
    }

    private string GetHistoryItemClass(RunDocument run)
    {
        return _selectedRun?.Id == run.Id
            ? "workspace-history-item workspace-history-item-selected"
            : "workspace-history-item";
    }

    private string GetHistoryPanelClass()
    {
        return _historyPanelOpen
            ? "workspace-history-panel"
            : "workspace-history-panel workspace-history-panel-hidden";
    }

    private void ToggleHistoryPanel()
    {
        _historyPanelOpen = !_historyPanelOpen;
    }

    private static string GetBranchLabel(RepositoryDocument repository)
    {
        return string.IsNullOrWhiteSpace(repository.CurrentBranch)
            ? "Branch: -"
            : $"Branch: {repository.CurrentBranch}";
    }

    private static int GetWorkingTreeCount(RepositoryDocument repository)
    {
        return repository.StagedCount + repository.ModifiedCount + repository.UntrackedCount;
    }

    private static int GetRepositoryProgress(RepositoryDocument repository)
    {
        var debt = repository.StagedCount + repository.ModifiedCount + repository.UntrackedCount + repository.BehindCount + repository.AheadCount;
        var progress = Math.Max(0, 100 - Math.Min(100, debt * 8));
        if (!string.IsNullOrWhiteSpace(repository.LastSyncError))
        {
            progress = Math.Min(progress, 35);
        }

        return progress;
    }

    private static Color GetRepositoryHealthColor(RepositoryDocument repository)
    {
        if (!string.IsNullOrWhiteSpace(repository.LastSyncError))
        {
            return Color.Error;
        }

        if (GetWorkingTreeCount(repository) > 0 || repository.BehindCount > 0)
        {
            return Color.Warning;
        }

        if (repository.AheadCount > 0)
        {
            return Color.Info;
        }

        return Color.Success;
    }

    private static string GetRepositoryHealthLabel(RepositoryDocument repository)
    {
        if (!string.IsNullOrWhiteSpace(repository.LastSyncError))
        {
            return "Sync Error";
        }

        if (GetWorkingTreeCount(repository) > 0)
        {
            return "Dirty";
        }

        if (repository.BehindCount > 0)
        {
            return "Behind";
        }

        if (repository.AheadCount > 0)
        {
            return "Ahead";
        }

        return "Clean";
    }

    private int GetTaskProgressPercent(string taskId)
    {
        var runs = _selectedRepositoryRuns
            .Where(run => run.TaskId == taskId)
            .Take(10)
            .ToList();

        if (runs.Count == 0)
        {
            return 0;
        }

        var succeeded = runs.Count(run => run.State == RunState.Succeeded);
        return Math.Clamp((int)Math.Round(succeeded * 100d / runs.Count, MidpointRounding.AwayFromZero), 0, 100);
    }

    private Color GetTaskStateColor(TaskDocument task)
    {
        var latestRun = GetLatestRun(task.Id);
        if (latestRun is null)
        {
            return task.Enabled ? Color.Default : Color.Secondary;
        }

        return GetStateColor(latestRun.State);
    }

    private string GetTaskStateLabel(TaskDocument task)
    {
        var latestRun = GetLatestRun(task.Id);
        if (latestRun is null)
        {
            return task.Enabled ? "Idle" : "Disabled";
        }

        return latestRun.State.ToString();
    }

    private static Color GetStateColor(RunState state)
    {
        return state switch
        {
            RunState.Succeeded => Color.Success,
            RunState.Failed => Color.Error,
            RunState.Running => Color.Info,
            RunState.Queued => Color.Warning,
            RunState.PendingApproval => Color.Secondary,
            RunState.Cancelled => Color.Default,
            _ => Color.Default
        };
    }

    private static string GetRunSummary(RunDocument run)
    {
        if (!string.IsNullOrWhiteSpace(run.Summary))
        {
            return run.Summary;
        }

        return run.State switch
        {
            RunState.Running => "Execution in progress",
            RunState.Queued => "Queued",
            RunState.Failed => "Execution failed",
            RunState.Succeeded => "Execution succeeded",
            RunState.PendingApproval => "Pending approval",
            _ => "No summary"
        };
    }

    private string GetSelectedRunRawOutput()
    {
        if (_selectedRun is null)
        {
            return string.Empty;
        }

        return string.IsNullOrWhiteSpace(_selectedRun.OutputJson)
            ? "{ }"
            : _selectedRun.OutputJson;
    }

    private void ClearSelectedRunStructuredState()
    {
        _selectedRunStructuredEvents = [];
        _selectedRunDiffSnapshot = null;
        _selectedRunStructuredView = new RunStructuredViewSnapshot(string.Empty, 0, [], [], [], null, DateTime.UtcNow);
    }

    private string GetSelectedRunStructuredEventsJson()
    {
        if (_selectedRunStructuredEvents.Count == 0)
        {
            return "[]";
        }

        return JsonSerializer.Serialize(_selectedRunStructuredEvents, new JsonSerializerOptions
        {
            WriteIndented = true
        });
    }

    private async Task CopySelectedRunStructuredEventsJsonAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", GetSelectedRunStructuredEventsJson());
            Snackbar.Add("Event JSON copied.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Unable to copy event JSON: {ex.Message}", Severity.Warning);
        }
    }

    private string GetWorkspaceResolvedDiffPatch()
    {
        if (!string.IsNullOrWhiteSpace(_selectedRunDiffSnapshot?.DiffPatch))
        {
            return _selectedRunDiffSnapshot.DiffPatch;
        }

        return _selectedRunStructuredView.Diff?.DiffPatch ?? string.Empty;
    }

    private string GetWorkspaceResolvedDiffStat()
    {
        if (!string.IsNullOrWhiteSpace(_selectedRunDiffSnapshot?.DiffStat))
        {
            return _selectedRunDiffSnapshot.DiffStat;
        }

        return _selectedRunStructuredView.Diff?.DiffStat ?? string.Empty;
    }

    private static string MergePrompt(string currentPrompt, string composerText)
    {
        var suffix = $"Workspace instruction:\n{composerText}";
        if (string.IsNullOrWhiteSpace(currentPrompt))
        {
            return suffix;
        }

        return $"{currentPrompt.TrimEnd()}\n\n{suffix}";
    }

    private static UpdateTaskRequest ToUpdateRequest(TaskDocument task, string prompt)
    {
        return new UpdateTaskRequest(
            task.Name,
            task.Kind,
            task.Harness,
            prompt,
            task.Command,
            task.AutoCreatePullRequest,
            task.CronExpression,
            task.Enabled,
            task.RetryPolicy,
            task.Timeouts,
            task.SandboxProfile,
            task.ArtifactPolicy,
            task.ApprovalProfile,
            task.ConcurrencyLimit,
            task.InstructionFiles.Count > 0 ? [.. task.InstructionFiles] : null,
            task.ArtifactPatterns.Count > 0 ? [.. task.ArtifactPatterns] : null,
            task.LinkedFailureRuns.Count > 0 ? [.. task.LinkedFailureRuns] : null,
            task.ExecutionModeDefault);
    }

    private static string TruncateForDisplay(string text, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(text) || text.Length <= maxLength)
        {
            return text;
        }

        return text[..maxLength] + "...";
    }

    private Color GetRunStepColor(RunDocument run, RunStep step)
    {
        return step switch
        {
            RunStep.Queued when run.State is RunState.Queued or RunState.Running or RunState.PendingApproval or RunState.Succeeded or RunState.Failed or RunState.Cancelled => Color.Success,
            RunStep.Queued => Color.Default,
            RunStep.Running when run.State is RunState.Running or RunState.PendingApproval or RunState.Succeeded or RunState.Failed or RunState.Cancelled => Color.Success,
            RunStep.Running when run.State is RunState.Queued => Color.Warning,
            RunStep.Running => Color.Default,
            RunStep.Done when run.State is RunState.Succeeded => Color.Success,
            RunStep.Done when run.State is RunState.Failed => Color.Error,
            RunStep.Done when run.State is RunState.Cancelled => Color.Warning,
            _ => Color.Default
        };
    }

    public async ValueTask DisposeAsync()
    {
        _selectionSubscription?.Dispose();
        _runLogSubscription?.Dispose();
        _runStatusSubscription?.Dispose();
        _structuredSubscription?.Dispose();
        _diffSubscription?.Dispose();
        _toolSubscription?.Dispose();
        _searchDebounceCts?.Cancel();
        _searchDebounceCts?.Dispose();
        _composerSuggestionCts?.Cancel();
        _composerSuggestionCts?.Dispose();

        if (_workspaceJsModule is not null)
        {
            try
            {
                if (_viewportListenerHandle is not null)
                {
                    await _workspaceJsModule.InvokeVoidAsync("unregisterViewportListener", _viewportListenerHandle);
                }
            }
            catch
            {
            }

            try
            {
                if (_composerKeyBridgeHandle is not null)
                {
                    await _workspaceJsModule.InvokeVoidAsync("unregisterComposerKeyBridge", _composerKeyBridgeHandle);
                }
            }
            catch
            {
            }

            try
            {
                await _workspaceJsModule.DisposeAsync();
            }
            catch
            {
            }
        }

        _dotNetRef?.Dispose();
    }

    private sealed record RepositoryGroup(string Name, List<RepositoryDocument> Repositories);

    private sealed class WorkspaceTeamMemberDraft
    {
        public string Harness { get; set; } = "codex";
        public HarnessExecutionMode Mode { get; set; } = HarnessExecutionMode.Default;
        public string RolePrompt { get; set; } = string.Empty;
        public string ModelOverride { get; set; } = string.Empty;
        public int? TimeoutSeconds { get; set; }
    }

    private enum PromptDraftMode
    {
        Generate,
        Improve
    }

    private enum RunStep
    {
        Queued,
        Running,
        Done
    }
}

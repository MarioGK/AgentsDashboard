@page "/settings/repositories/{RepositoryId}"
@layout SettingsLayout
@rendermode InteractiveServer
@inject Data.IOrchestratorStore Store
@inject Services.RunDispatcher Dispatcher
@inject Services.SecretCryptoService Crypto
@inject Services.TaskTemplateService TemplateService
@inject Services.LlmTornadoGatewayService LlmTornadoGateway
@inject ISnackbar Snackbar
@using AgentsDashboard.ControlPlane.Services
@using AgentsDashboard.Contracts.Domain

<PageTitle>Repository</PageTitle>

@if (_repository is null)
{
    <MudAlert Severity="Severity.Error">Repository not found</MudAlert>
}
else
{
    <MudStack Spacing="2">
        <MudText Typo="Typo.h4">@_repository.Name</MudText>
        <MudText Typo="Typo.subtitle2">@_repository.GitUrl</MudText>

        <MudTabs Elevation="1" Rounded>
            <MudTabPanel Text="Tasks">
                <MudPaper Class="pa-4 mb-3" Elevation="1">
                    <MudText Typo="Typo.subtitle1" Class="mb-2">Quick Start from Template</MudText>
                    <MudStack Row Spacing="2" Style="flex-wrap: wrap;">
                        @foreach (var template in _templates)
                        {
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Size="Size.Small"
                                       OnClick="() => ApplyTemplate(template)">
                                @template.Name
                            </MudButton>
                        }
                    </MudStack>
                </MudPaper>

                <MudPaper Class="pa-4 mb-3">
                    <MudText Typo="Typo.h6" Class="mb-3">Create Task</MudText>
                    <MudGrid>
                        <MudItem xs="12" md="4"><MudTextField @bind-Value="_taskName" Label="Task Name" /></MudItem>
                        <MudItem xs="12" md="3">
                            <MudSelect T="TaskKind" @bind-Value="_taskKind" Label="Kind">
                                <MudSelectItem T="TaskKind" Value="@TaskKind.OneShot">One Shot</MudSelectItem>
                                <MudSelectItem T="TaskKind" Value="@TaskKind.Cron">Cron</MudSelectItem>
                                <MudSelectItem T="TaskKind" Value="@TaskKind.EventDriven">Event Driven</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" md="3">
                            <MudSelect T="string" @bind-Value="_taskHarness" Label="Harness">
                                <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                <MudSelectItem T="string" Value='@("zai")'>Zai (GLM-5)</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" md="2" Class="d-flex align-center">
                            <MudSwitch @bind-Value="_taskEnabled" Label="Enabled" />
                        </MudItem>
                    </MudGrid>
                    <MudGrid Class="mt-2">
                        <MudItem xs="12" md="4"><MudTextField @bind-Value="_taskCron" Label="Cron (if cron)" /></MudItem>
                        <MudItem xs="12" md="6"><MudTextField @bind-Value="_taskCommand" Label="Shell Command" /></MudItem>
                        <MudItem xs="12" md="2" Class="d-flex align-center"><MudSwitch @bind-Value="_taskAutoPr" Label="Auto PR" /></MudItem>
                    </MudGrid>
                    <MudText Typo="Typo.subtitle2" Class="mt-3 mb-2">Prompt (Monaco)</MudText>
                    <div style="height: 420px;">
                        <StandaloneCodeEditor @ref="_taskPromptEditor"
                                              Id="promptEditor"
                                              CssClass="monaco-fill-parent"
                                              ConstructionOptions="EditorOptions" />
                    </div>
                    <MudStack Row Spacing="2" Class="mt-3">
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Secondary"
                                   StartIcon="@Icons.Material.Filled.AutoAwesome"
                                   OnClick="GenerateTaskPromptAsync"
                                   Disabled="@(_isGeneratingTaskPrompt || string.IsNullOrWhiteSpace(_taskName))">
                            @if (_isGeneratingTaskPrompt)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Generating...</span>
                            }
                            else
                            {
                                <span>Generate Prompt (GLM-5)</span>
                            }
                        </MudButton>
                    </MudStack>
                    <MudStack Row Spacing="2" Class="mt-3">
                        @if (_editingTaskId is not null)
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Warning" OnClick="CreateTaskAsync">Update Task</MudButton>
                            <MudButton Variant="Variant.Outlined" OnClick="CancelEdit">Cancel</MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateTaskAsync">Create Task</MudButton>
                        }
                    </MudStack>
                </MudPaper>

                <MudTable Items="_tasks" Dense Hover>
                    <HeaderContent>
                        <MudTh>Name</MudTh>
                        <MudTh>Kind</MudTh>
                        <MudTh>Harness</MudTh>
                        <MudTh>Enabled</MudTh>
                        <MudTh>Next Run</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Name</MudTd>
                        <MudTd>@context.Kind</MudTd>
                        <MudTd>@context.Harness</MudTd>
                        <MudTd>@context.Enabled</MudTd>
                        <MudTd>@(context.NextRunAtUtc?.ToLocalTime().ToString("g") ?? "-")</MudTd>
                        <MudTd>
                            <MudStack Row>
                                <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="() => TriggerTaskAsync(context)">Run</MudButton>
                                <MudButton Variant="Variant.Text" Color="Color.Secondary" Size="Size.Small" OnClick="() => StartEditTask(context)">Edit</MudButton>
                                <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small" OnClick="() => DeleteTaskAsync(context)">Delete</MudButton>
                            </MudStack>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Runs">
                <MudTable Items="_runs" Dense Hover>
                    <HeaderContent>
                        <MudTh>Run</MudTh>
                        <MudTh>Task</MudTh>
                        <MudTh>Status</MudTh>
                        <MudTh>Summary</MudTh>
                        <MudTh>Created</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Id[..8]</MudTd>
                        <MudTd>@context.TaskId[..Math.Min(8, context.TaskId.Length)]</MudTd>
                        <MudTd><MudChip T="string" Color="@StateColor(context.State)">@context.State</MudChip></MudTd>
                        <MudTd>@context.Summary</MudTd>
                        <MudTd>@context.CreatedAtUtc.ToLocalTime().ToString("g")</MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Findings Inbox">
                <MudTable Items="_findings" Dense Hover>
                    <HeaderContent>
                        <MudTh>Title</MudTh>
                        <MudTh>Severity</MudTh>
                        <MudTh>State</MudTh>
                        <MudTh>Created</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Title</MudTd>
                        <MudTd>@context.Severity</MudTd>
                        <MudTd>@context.State</MudTd>
                        <MudTd>@context.CreatedAtUtc.ToLocalTime().ToString("g")</MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Instructions">
                <MudPaper Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Repository Instruction Files</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        These instructions are layered into every task prompt for this repository (Project → Repository → Task → User Prompt).
                    </MudText>

                    @for (var i = 0; i < _repoInstructionFiles.Count; i++)
                    {
                        var index = i;
                        var file = _repoInstructionFiles[index];
                        <MudPaper Class="pa-3 mb-3" Outlined>
                            <MudGrid>
                                <MudItem xs="12" md="5">
                                    <MudTextField Value="@file.Name" Label="File Name"
                                                  ValueChanged="@((string v) => UpdateInstructionFileName(index, v))" />
                                </MudItem>
                                <MudItem xs="12" md="3">
                                    <MudNumericField Value="@file.Order" Label="Order"
                                                     ValueChanged="@((int v) => UpdateInstructionFileOrder(index, v))" />
                                </MudItem>
                                <MudItem xs="12" md="4" Class="d-flex align-center justify-end">
                                    <MudTooltip Text="Move Up">
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Size="Size.Small"
                                                       Disabled="@(index == 0)"
                                                       OnClick="() => MoveInstructionFile(index, -1)" />
                                    </MudTooltip>
                                    <MudTooltip Text="Move Down">
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Size="Size.Small"
                                                       Disabled="@(index == _repoInstructionFiles.Count - 1)"
                                                       OnClick="() => MoveInstructionFile(index, 1)" />
                                    </MudTooltip>
                                    <MudTooltip Text="Remove">
                                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error"
                                                       OnClick="() => RemoveInstructionFile(index)" />
                                    </MudTooltip>
                                </MudItem>
                            </MudGrid>
                            <div style="height: 320px;" class="mt-2">
                                <StandaloneCodeEditor @key="@($"repo-instr-{index}-{file.Name}")"
                                                      Id="@($"repoInstrEditor_{index}")"
                                                      CssClass="monaco-fill-parent"
                                                      ConstructionOptions="InstructionEditorOptions"
                                                      OnDidChangeModelContent="() => OnInstructionContentChanged(index)"
                                                      @ref="_instructionEditors[index]" />
                            </div>
                        </MudPaper>
                    }

                    <MudStack Row Spacing="2">
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="AddInstructionFile"
                                   StartIcon="@Icons.Material.Filled.Add">Add Instruction File</MudButton>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveInstructionFilesAsync">Save Instructions</MudButton>
                    </MudStack>

                    @if (!string.IsNullOrWhiteSpace(_instructionSaveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">@_instructionSaveMessage</MudAlert>
                    }
                </MudPaper>
            </MudTabPanel>

            <MudTabPanel Text="Secrets & Webhooks">
                <MudPaper Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Repository Secrets</MudText>
                    <MudGrid>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_githubToken" Label="GitHub Token (GH_TOKEN)" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_codexToken" Label="Codex API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_opencodeToken" Label="OpenCode API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_claudeToken" Label="Claude Code API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_zaiToken" Label="Z.ai API Key (Z_AI_API_KEY)" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_llmTornadoToken" Label="LlmTornado Key (ANTHROPIC_AUTH_TOKEN)" InputType="InputType.Password" />
                        </MudItem>
                    </MudGrid>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveSecretsAsync" Class="mt-3">Save Secrets</MudButton>

                    @if (!string.IsNullOrWhiteSpace(_saveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">@_saveMessage</MudAlert>
                    }
                </MudPaper>
            </MudTabPanel>
        </MudTabs>
    </MudStack>
}

@code {
    [Parameter] public string RepositoryId { get; set; } = string.Empty;

    private RepositoryDocument? _repository;
    private ProjectDocument? _project;

    private readonly List<TaskDocument> _tasks = [];
    private readonly List<RunDocument> _runs = [];
    private readonly List<FindingDocument> _findings = [];
    private List<TaskTemplateDocument> _templates = [];

    private string _taskName = string.Empty;
    private TaskKind _taskKind = TaskKind.OneShot;
    private string _taskHarness = "codex";
    private string _taskCron = string.Empty;
    private string _taskPrompt = "Describe the task objective and expected output in JSON envelope format.";
    private string _taskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Sample run\",\"artifacts\":[]}'";
    private bool _taskAutoPr;
    private bool _taskEnabled = true;
    private string? _editingTaskId = null;
    private int _taskRetryMaxAttempts = 1;
    private int _taskExecutionTimeout = 600;
    private int _taskOverallTimeout = 1800;
    private double _taskCpuLimit = 1.5;
    private string _taskMemoryLimit = "2g";
    private bool _taskNetworkDisabled;
    private bool _taskReadOnlyRootFs;
    private int _taskMaxArtifacts = 50;
    private long _taskMaxTotalSizeBytes = 104_857_600;
    private List<string> _taskArtifactPatterns = [];
    private List<string> _taskLinkedFailureRuns = [];
    private string _githubToken = string.Empty;
    private string _codexToken = string.Empty;
    private string _opencodeToken = string.Empty;
    private string _claudeToken = string.Empty;
    private string _zaiToken = string.Empty;
    private string _llmTornadoToken = string.Empty;
    private string _saveMessage = string.Empty;
    private readonly List<InstructionFileEdit> _repoInstructionFiles = [];
    private readonly Dictionary<int, StandaloneCodeEditor> _instructionEditors = [];
    private StandaloneCodeEditor? _taskPromptEditor;
    private string _instructionSaveMessage = string.Empty;
    private bool _isGeneratingTaskPrompt;
    private const string MonacoTheme = "agents-dashboard-dark";

    private StandaloneEditorConstructionOptions InstructionEditorOptions(StandaloneCodeEditor editor)
        => new()
        {
            AutomaticLayout = true,
            Language = "markdown",
            Theme = MonacoTheme,
            Minimap = new EditorMinimapOptions { Enabled = false },
            WordWrap = "on",
            FontSize = 13,
            Value = GetInstructionEditorValue(editor),
        };

    private string GetInstructionEditorValue(StandaloneCodeEditor editor)
    {
        var entry = _instructionEditors.FirstOrDefault(kv => kv.Value == editor);
        if (entry.Value is not null && entry.Key < _repoInstructionFiles.Count)
            return _repoInstructionFiles[entry.Key].Content;

        var index = _repoInstructionFiles.Count - 1;
        return index >= 0 ? _repoInstructionFiles[index].Content : string.Empty;
    }

    private StandaloneEditorConstructionOptions EditorOptions(StandaloneCodeEditor editor)
        => new()
        {
            AutomaticLayout = true,
            Language = "markdown",
            Theme = MonacoTheme,
            Minimap = new EditorMinimapOptions { Enabled = false },
            WordWrap = "on",
            FontSize = 13,
            Value = _taskPrompt,
        };

    protected override async Task OnParametersSetAsync()
    {
        _repository = await Store.GetRepositoryAsync(RepositoryId, CancellationToken.None);

        if (_repository is null)
        {
            return;
        }

        _project = await Store.GetProjectAsync(_repository.ProjectId, CancellationToken.None);
        _templates = await TemplateService.ListTemplatesAsync(CancellationToken.None);
        await RefreshAsync();
        await LoadInstructionFilesAsync();
    }

    private void ApplyTemplate(TaskTemplateDocument template)
    {
        _taskName = template.Name;
        _taskKind = template.Kind;
        _taskHarness = template.Harness;
        _taskCommand = template.Commands.Count > 0 ? string.Join(" && ", template.Commands) : string.Empty;
        _taskPrompt = template.Prompt;
        _taskCron = template.CronExpression;
        _taskEnabled = true;
        _taskAutoPr = template.AutoCreatePullRequest;
        _taskRetryMaxAttempts = template.RetryPolicy.MaxAttempts;
        _taskExecutionTimeout = template.Timeouts.ExecutionSeconds;
        _taskOverallTimeout = template.Timeouts.OverallSeconds;
        _taskCpuLimit = template.SandboxProfile.CpuLimit;
        _taskMemoryLimit = template.SandboxProfile.MemoryLimit;
        _taskNetworkDisabled = template.SandboxProfile.NetworkDisabled;
        _taskReadOnlyRootFs = template.SandboxProfile.ReadOnlyRootFs;
        _taskMaxArtifacts = template.ArtifactPolicy.MaxArtifacts;
        _taskMaxTotalSizeBytes = template.ArtifactPolicy.MaxTotalSizeBytes;
        _taskArtifactPatterns = [.. template.ArtifactPatterns];
        _taskLinkedFailureRuns = [.. template.LinkedFailureRuns];
        _editingTaskId = null;
        StateHasChanged();
    }

    private void StartEditTask(TaskDocument task)
    {
        _editingTaskId = task.Id;
        _taskName = task.Name;
        _taskKind = task.Kind;
        _taskHarness = task.Harness;
        _taskCommand = task.Command;
        _taskPrompt = task.Prompt;
        _taskCron = task.CronExpression;
        _taskEnabled = task.Enabled;
        _taskAutoPr = task.AutoCreatePullRequest;
        _taskRetryMaxAttempts = task.RetryPolicy.MaxAttempts;
        _taskExecutionTimeout = task.Timeouts.ExecutionSeconds;
        _taskOverallTimeout = task.Timeouts.OverallSeconds;
        _taskCpuLimit = task.SandboxProfile.CpuLimit;
        _taskMemoryLimit = task.SandboxProfile.MemoryLimit;
        _taskNetworkDisabled = task.SandboxProfile.NetworkDisabled;
        _taskReadOnlyRootFs = task.SandboxProfile.ReadOnlyRootFs;
        _taskMaxArtifacts = task.ArtifactPolicy.MaxArtifacts;
        _taskMaxTotalSizeBytes = task.ArtifactPolicy.MaxTotalSizeBytes;
        _taskArtifactPatterns = [.. task.ArtifactPatterns];
        _taskLinkedFailureRuns = [.. task.LinkedFailureRuns];
        _ = SyncTaskPromptEditorAsync();
        StateHasChanged();
    }

    private void CancelEdit()
    {
        _editingTaskId = null;
        _taskName = string.Empty;
        _taskCron = string.Empty;
        _taskAutoPr = false;
        _taskEnabled = true;
        _taskPrompt = "Describe the task objective and expected output in JSON envelope format.";
        _taskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Sample run\",\"artifacts\":[]}'";
        _taskRetryMaxAttempts = 1;
        _taskExecutionTimeout = 600;
        _taskOverallTimeout = 1800;
        _taskCpuLimit = 1.5;
        _taskMemoryLimit = "2g";
        _taskNetworkDisabled = false;
        _taskReadOnlyRootFs = false;
        _taskMaxArtifacts = 50;
        _taskMaxTotalSizeBytes = 104_857_600;
        _taskArtifactPatterns = [];
        _taskLinkedFailureRuns = [];
        _ = SyncTaskPromptEditorAsync();
        StateHasChanged();
    }

    private async Task CreateTaskAsync()
    {
        if (_repository is null || string.IsNullOrWhiteSpace(_taskName))
        {
            return;
        }

        if (_taskPromptEditor is not null)
            _taskPrompt = await _taskPromptEditor.GetValue();

        var retryPolicy = new RetryPolicyConfig(_taskRetryMaxAttempts);
        var timeouts = new TimeoutConfig(_taskExecutionTimeout, _taskOverallTimeout);
        var sandboxProfile = new SandboxProfileConfig(_taskCpuLimit, _taskMemoryLimit, _taskNetworkDisabled, _taskReadOnlyRootFs);
        var artifactPolicy = new ArtifactPolicyConfig(_taskMaxArtifacts, _taskMaxTotalSizeBytes);

        if (_editingTaskId is not null)
        {
            var updateRequest = new UpdateTaskRequest(
                _taskName.Trim(),
                _taskKind,
                _taskHarness,
                _taskPrompt,
                _taskCommand,
                _taskAutoPr,
                _taskCron,
                _taskEnabled,
                retryPolicy,
                timeouts,
                sandboxProfile,
                artifactPolicy,
                null,
                null,
                null,
                _taskArtifactPatterns.Count > 0 ? _taskArtifactPatterns : null,
                _taskLinkedFailureRuns.Count > 0 ? _taskLinkedFailureRuns : null);
            await Store.UpdateTaskAsync(_editingTaskId, updateRequest, CancellationToken.None);
            _editingTaskId = null;
        }
        else
        {
            var request = new CreateTaskRequest(
                _repository.Id,
                _taskName.Trim(),
                _taskKind,
                _taskHarness,
                _taskPrompt,
                _taskCommand,
                _taskAutoPr,
                _taskCron,
                _taskEnabled,
                retryPolicy,
                timeouts,
                sandboxProfile,
                artifactPolicy,
                null,
                null,
                null,
                _taskArtifactPatterns.Count > 0 ? _taskArtifactPatterns : null,
                _taskLinkedFailureRuns.Count > 0 ? _taskLinkedFailureRuns : null);

            await Store.CreateTaskAsync(request, CancellationToken.None);
        }

        _taskName = string.Empty;
        _taskCron = string.Empty;
        _taskAutoPr = false;
        _taskArtifactPatterns = [];
        _taskLinkedFailureRuns = [];

        await RefreshAsync();
    }

    private async Task GenerateTaskPromptAsync()
    {
        if (_repository is null)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_taskName))
        {
            Snackbar.Add("Set a task name before generating a prompt.", Severity.Warning);
            return;
        }

        _isGeneratingTaskPrompt = true;
        StateHasChanged();

        try
        {
            var llmTornadoSecret = await Store.GetProviderSecretAsync("global", "llmtornado", CancellationToken.None);
            var zaiSecret = await Store.GetProviderSecretAsync("global", "zai", CancellationToken.None);
            string? apiKey = null;

            if (llmTornadoSecret is not null && !string.IsNullOrWhiteSpace(llmTornadoSecret.EncryptedValue))
            {
                apiKey = Crypto.Decrypt(llmTornadoSecret.EncryptedValue);
            }
            else if (zaiSecret is not null && !string.IsNullOrWhiteSpace(zaiSecret.EncryptedValue))
            {
                apiKey = Crypto.Decrypt(zaiSecret.EncryptedValue);
            }

            if (string.IsNullOrWhiteSpace(apiKey))
            {
                Snackbar.Add("Configure a global LlmTornado key in Provider Settings first.", Severity.Warning);
                return;
            }

            var result = await LlmTornadoGateway.GenerateTaskPromptAsync(
                new TaskPromptGenerationRequest(
                    _repository.Name,
                    _taskName.Trim(),
                    _taskHarness,
                    _taskKind.ToString(),
                    _taskCommand,
                    _taskCron),
                apiKey,
                CancellationToken.None);

            if (!result.Success)
            {
                Snackbar.Add(result.Error ?? "Failed to generate prompt.", Severity.Error);
                return;
            }

            _taskPrompt = result.Prompt;
            await SyncTaskPromptEditorAsync();
            Snackbar.Add("Prompt generated with GLM-5.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to generate prompt: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isGeneratingTaskPrompt = false;
            StateHasChanged();
        }
    }

    private async Task SyncTaskPromptEditorAsync()
    {
        if (_taskPromptEditor is not null)
            await _taskPromptEditor.SetValue(_taskPrompt);
    }

    private async Task DeleteTaskAsync(TaskDocument task)
    {
        await Store.DeleteTaskAsync(task.Id, CancellationToken.None);
        await RefreshAsync();
    }

    private async Task TriggerTaskAsync(TaskDocument task)
    {
        if (_project is null || _repository is null)
        {
            return;
        }

        var run = await Store.CreateRunAsync(task, _project.Id, CancellationToken.None);
        await Dispatcher.DispatchAsync(_project, _repository, task, run, CancellationToken.None);

        await RefreshAsync();
    }

    private async Task RefreshAsync()
    {
        if (_repository is null)
        {
            return;
        }

        _tasks.Clear();
        _tasks.AddRange(await Store.ListTasksAsync(_repository.Id, CancellationToken.None));

        _runs.Clear();
        _runs.AddRange(await Store.ListRunsByRepositoryAsync(_repository.Id, CancellationToken.None));

        _findings.Clear();
        _findings.AddRange(await Store.ListFindingsAsync(_repository.Id, CancellationToken.None));
    }

    private async Task SaveSecretsAsync()
    {
        if (_repository is null)
        {
            return;
        }

        await SaveSecretIfPresentAsync("github", _githubToken);
        await SaveSecretIfPresentAsync("codex", _codexToken);
        await SaveSecretIfPresentAsync("opencode", _opencodeToken);
        await SaveSecretIfPresentAsync("claude-code", _claudeToken);
        await SaveSecretIfPresentAsync("zai", _zaiToken);
        await SaveSecretIfPresentAsync("llmtornado", _llmTornadoToken);

        _saveMessage = "Secrets saved.";
        await RefreshAsync();
    }

    private async Task SaveSecretIfPresentAsync(string provider, string value)
    {
        if (_repository is null || string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        await Store.UpsertProviderSecretAsync(_repository.Id, provider, Crypto.Encrypt(value.Trim()), CancellationToken.None);
    }

    private async Task LoadInstructionFilesAsync()
    {
        if (_repository is null) return;
        var files = await Store.GetRepositoryInstructionFilesAsync(_repository.Id, CancellationToken.None);
        _repoInstructionFiles.Clear();
        _instructionEditors.Clear();
        foreach (var f in files.OrderBy(f => f.Order))
            _repoInstructionFiles.Add(new InstructionFileEdit { Name = f.Name, Content = f.Content, Order = f.Order });
    }

    private void AddInstructionFile()
    {
        var nextOrder = _repoInstructionFiles.Count > 0 ? _repoInstructionFiles.Max(f => f.Order) + 1 : 0;
        _repoInstructionFiles.Add(new InstructionFileEdit { Name = $"instruction-{nextOrder}.md", Content = string.Empty, Order = nextOrder });
        StateHasChanged();
    }

    private void RemoveInstructionFile(int index)
    {
        _repoInstructionFiles.RemoveAt(index);
        _instructionEditors.Remove(index);
        StateHasChanged();
    }

    private void UpdateInstructionFileName(int index, string name)
    {
        _repoInstructionFiles[index].Name = name;
    }

    private void UpdateInstructionFileOrder(int index, int order)
    {
        _repoInstructionFiles[index].Order = order;
    }

    private void MoveInstructionFile(int index, int direction)
    {
        var newIndex = index + direction;
        if (newIndex < 0 || newIndex >= _repoInstructionFiles.Count) return;
        (_repoInstructionFiles[index], _repoInstructionFiles[newIndex]) = (_repoInstructionFiles[newIndex], _repoInstructionFiles[index]);
        for (var i = 0; i < _repoInstructionFiles.Count; i++)
            _repoInstructionFiles[i].Order = i;
        StateHasChanged();
    }

    private async void OnInstructionContentChanged(int index)
    {
        if (_instructionEditors.TryGetValue(index, out var editor))
            _repoInstructionFiles[index].Content = await editor.GetValue();
    }

    private async Task SaveInstructionFilesAsync()
    {
        if (_repository is null) return;

        foreach (var kv in _instructionEditors)
        {
            if (kv.Key < _repoInstructionFiles.Count)
                _repoInstructionFiles[kv.Key].Content = await kv.Value.GetValue();
        }

        var files = _repoInstructionFiles
            .Select(f => new InstructionFile(f.Name, f.Content, f.Order))
            .ToList();
        await Store.UpdateRepositoryInstructionFilesAsync(_repository.Id, files, CancellationToken.None);
        _instructionSaveMessage = "Instructions saved.";
        StateHasChanged();
    }

    private static Color StateColor(RunState state) => state switch
    {
        RunState.Succeeded => Color.Success,
        RunState.Failed => Color.Error,
        RunState.Running => Color.Info,
        RunState.Queued => Color.Warning,
        _ => Color.Default
    };

    private sealed class InstructionFileEdit
    {
        public string Name { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public int Order { get; set; }
    }
}

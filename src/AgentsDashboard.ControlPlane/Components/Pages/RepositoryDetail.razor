@page "/settings/repositories/{RepositoryId}"
@page "/repositories/{RepositoryId}"
@layout SettingsLayout
@rendermode InteractiveServer
@inject Data.IOrchestratorStore Store
@inject Services.RunDispatcher Dispatcher
@inject Services.SecretCryptoService Crypto
@inject Services.TaskTemplateService TemplateService
@inject Services.LlmTornadoGatewayService LlmTornadoGateway
@inject Services.IGitWorkspaceService GitWorkspace
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@using AgentsDashboard.ControlPlane.Services
@using AgentsDashboard.Contracts.Domain
@implements IAsyncDisposable

<PageTitle>Repository</PageTitle>

@if (_repository is null)
{
    <MudAlert Severity="Severity.Error">Repository not found</MudAlert>
}
else
{
    <MudStack Spacing="2">
        <MudText Typo="Typo.h4">@_repository.Name</MudText>
        <MudText Typo="Typo.subtitle2">@_repository.GitUrl</MudText>
        <MudText Typo="Typo.caption">@_repository.LocalPath</MudText>

        <MudPaper Class="pa-3">
            <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                <MudChip T="string" Color="Color.Info" Size="Size.Small">Branch: @(_repository.CurrentBranch == string.Empty ? "-" : _repository.CurrentBranch)</MudChip>
                <MudChip T="string" Color="Color.Default" Size="Size.Small">Ahead/Behind: @_repository.AheadCount/@_repository.BehindCount</MudChip>
                <MudChip T="string" Color="Color.Default" Size="Size.Small">Staged/Modified/Untracked: @_repository.StagedCount/@_repository.ModifiedCount/@_repository.UntrackedCount</MudChip>
                <MudButton Variant="Variant.Outlined" Color="Color.Info" Size="Size.Small" OnClick="RefreshGitStatusAsync">Refresh Git</MudButton>
            </MudStack>
        </MudPaper>

        <MudTabs Elevation="1" Rounded>
            <MudTabPanel Text="Tasks">
                <MudPaper Class="pa-4 mb-3" Elevation="1">
                    <MudText Typo="Typo.subtitle1" Class="mb-2">Quick Start from Template</MudText>
                    <MudStack Row Spacing="2" Style="flex-wrap: wrap;">
                        @foreach (var template in _templates)
                        {
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Size="Size.Small"
                                       OnClick="() => ApplyTemplate(template)">
                                @template.Name
                            </MudButton>
                        }
                    </MudStack>
                </MudPaper>

                <MudPaper Class="pa-4 mb-3" Elevation="1">
                    <MudText Typo="Typo.subtitle1" Class="mb-2">Prompt Skills</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        Type <code>/</code> in the task prompt editor to autocomplete repository and global skills.
                    </MudText>
                    <MudGrid>
                        <MudItem xs="12" md="4">
                            <MudTextField @bind-Value="_promptSkillName" Label="Skill Name" />
                        </MudItem>
                        <MudItem xs="12" md="4">
                            <MudTextField @bind-Value="_promptSkillTrigger" Label="Trigger (without /)" />
                        </MudItem>
                        <MudItem xs="12" md="4" Class="d-flex align-center">
                            <MudSwitch @bind-Value="_promptSkillEnabled" Label="Enabled" />
                        </MudItem>
                    </MudGrid>
                    <MudGrid Class="mt-2">
                        <MudItem xs="12">
                            <MudTextField @bind-Value="_promptSkillDescription" Label="Description" />
                        </MudItem>
                        <MudItem xs="12">
                            <MudTextField @bind-Value="_promptSkillContent" Label="Skill Content" Lines="6" />
                        </MudItem>
                    </MudGrid>
                    <MudStack Row Spacing="2" Class="mt-3">
                        @if (_editingPromptSkillId is not null)
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Warning" OnClick="SavePromptSkillAsync">Update Skill</MudButton>
                            <MudButton Variant="Variant.Outlined" OnClick="CancelPromptSkillEdit">Cancel</MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SavePromptSkillAsync">Create Skill</MudButton>
                        }
                    </MudStack>
                    <MudDivider Class="my-3" />
                    <MudTable Items="_repositoryPromptSkills" Dense Hover>
                        <HeaderContent>
                            <MudTh>Name</MudTh>
                            <MudTh>Trigger</MudTh>
                            <MudTh>Enabled</MudTh>
                            <MudTh>Updated</MudTh>
                            <MudTh></MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Name">@context.Name</MudTd>
                            <MudTd DataLabel="Trigger"><code>@($"/{context.Trigger}")</code></MudTd>
                            <MudTd DataLabel="Enabled">@context.Enabled</MudTd>
                            <MudTd DataLabel="Updated">@context.UpdatedAtUtc.ToLocalTime().ToString("g")</MudTd>
                            <MudTd DataLabel="Actions">
                                <MudStack Row>
                                    <MudButton Variant="Variant.Text" Color="Color.Secondary" Size="Size.Small" OnClick="() => StartEditPromptSkill(context)">Edit</MudButton>
                                    <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small" OnClick="() => DeletePromptSkillAsync(context)">Delete</MudButton>
                                </MudStack>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudPaper>

                <MudPaper Class="pa-4 mb-3">
                    <MudText Typo="Typo.h6" Class="mb-3">Create Task</MudText>
                    <MudGrid>
                        <MudItem xs="12" md="4"><MudTextField @bind-Value="_taskName" Label="Task Name" /></MudItem>
                        <MudItem xs="12" md="2">
                            <MudSelect T="TaskKind" @bind-Value="_taskKind" Label="Kind">
                                <MudSelectItem T="TaskKind" Value="@TaskKind.OneShot">One Shot</MudSelectItem>
                                <MudSelectItem T="TaskKind" Value="@TaskKind.Cron">Cron</MudSelectItem>
                                <MudSelectItem T="TaskKind" Value="@TaskKind.EventDriven">Event Driven</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" md="2">
                            <MudSelect T="string" @bind-Value="_taskHarness" Label="Harness">
                                <MudSelectItem T="string" Value='@("codex")'>Codex</MudSelectItem>
                                <MudSelectItem T="string" Value='@("opencode")'>OpenCode</MudSelectItem>
                                <MudSelectItem T="string" Value='@("claude-code")'>Claude Code</MudSelectItem>
                                <MudSelectItem T="string" Value='@("zai")'>Zai (GLM-5)</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" md="2">
                            <MudSelect T="HarnessExecutionMode" @bind-Value="_taskExecutionModeDefault" Label="Default Mode">
                                <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Default">Default</MudSelectItem>
                                <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Plan">Plan</MudSelectItem>
                                <MudSelectItem T="HarnessExecutionMode" Value="@HarnessExecutionMode.Review">Review</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" md="2" Class="d-flex align-center">
                            <MudSwitch @bind-Value="_taskEnabled" Label="Enabled" />
                        </MudItem>
                    </MudGrid>
                    <MudGrid Class="mt-2">
                        <MudItem xs="12" md="4"><MudTextField @bind-Value="_taskCron" Label="Cron (if cron)" /></MudItem>
                        <MudItem xs="12" md="6"><MudTextField @bind-Value="_taskCommand" Label="Shell Command" /></MudItem>
                        <MudItem xs="12" md="2" Class="d-flex align-center"><MudSwitch @bind-Value="_taskAutoPr" Label="Auto PR" /></MudItem>
                    </MudGrid>
                    <MudText Typo="Typo.subtitle2" Class="mt-3 mb-2">Prompt (Monaco)</MudText>
                    <div style="height: 420px;">
                        <StandaloneCodeEditor @ref="_taskPromptEditor"
                                              Id="promptEditor"
                                              CssClass="monaco-fill-parent"
                                              ConstructionOptions="EditorOptions" />
                    </div>
                    <MudStack Row Spacing="2" Class="mt-3">
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Secondary"
                                   StartIcon="@Icons.Material.Filled.AutoAwesome"
                                   OnClick="GenerateTaskPromptAsync"
                                   Disabled="@(_isGeneratingTaskPrompt || string.IsNullOrWhiteSpace(_taskName))">
                            @if (_isGeneratingTaskPrompt)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Generating...</span>
                            }
                            else
                            {
                                <span>Generate Prompt (GLM-5)</span>
                            }
                        </MudButton>
                    </MudStack>
                    <MudStack Row Spacing="2" Class="mt-3">
                        @if (_editingTaskId is not null)
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Warning" OnClick="CreateTaskAsync">Update Task</MudButton>
                            <MudButton Variant="Variant.Outlined" OnClick="CancelEdit">Cancel</MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateTaskAsync">Create Task</MudButton>
                        }
                    </MudStack>
                </MudPaper>

                <MudTable Items="_tasks" Dense Hover>
                    <HeaderContent>
                        <MudTh>Name</MudTh>
                        <MudTh>Status</MudTh>
                        <MudTh>Kind</MudTh>
                        <MudTh>Harness</MudTh>
                        <MudTh>Enabled</MudTh>
                        <MudTh>Next Run</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Name</MudTd>
                        <MudTd>
                            <TaskStatusChip Task="context" LatestRun="@GetLatestRunForTask(context.Id)" IsLoading="_taskStatusLoading" />
                        </MudTd>
                        <MudTd>@context.Kind</MudTd>
                        <MudTd>@context.Harness</MudTd>
                        <MudTd>@context.Enabled</MudTd>
                        <MudTd>@(context.NextRunAtUtc?.ToLocalTime().ToString("g") ?? "-")</MudTd>
                        <MudTd>
                            <MudStack Row>
                                <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="() => TriggerTaskAsync(context)">Run</MudButton>
                                <MudButton Variant="Variant.Text" Color="Color.Secondary" Size="Size.Small" OnClick="() => StartEditTask(context)">Edit</MudButton>
                                <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small" OnClick="() => DeleteTaskAsync(context)">Delete</MudButton>
                            </MudStack>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Runs">
                <MudTable Items="_runs" Dense Hover>
                    <HeaderContent>
                        <MudTh>Run</MudTh>
                        <MudTh>Task</MudTh>
                        <MudTh>Status</MudTh>
                        <MudTh>Summary</MudTh>
                        <MudTh>Created</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Id[..8]</MudTd>
                        <MudTd>@context.TaskId[..Math.Min(8, context.TaskId.Length)]</MudTd>
                        <MudTd>
                            <MudChip T="string" Color="@TaskRunStatusPresentation.FromRunState(context.State).Color">
                                @TaskRunStatusPresentation.FromRunState(context.State).Label
                            </MudChip>
                        </MudTd>
                        <MudTd>@context.Summary</MudTd>
                        <MudTd>@context.CreatedAtUtc.ToLocalTime().ToString("g")</MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Findings Inbox">
                <MudTable Items="_findings" Dense Hover>
                    <HeaderContent>
                        <MudTh>Title</MudTh>
                        <MudTh>Severity</MudTh>
                        <MudTh>State</MudTh>
                        <MudTh>Created</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd>@context.Title</MudTd>
                        <MudTd>@context.Severity</MudTd>
                        <MudTd>@context.State</MudTd>
                        <MudTd>@context.CreatedAtUtc.ToLocalTime().ToString("g")</MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>

            <MudTabPanel Text="Instructions">
                <MudPaper Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Repository Instruction Files</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        These instructions are layered into every task prompt for this repository (Repository → Task → User Prompt).
                    </MudText>

                    @for (var i = 0; i < _repoInstructionFiles.Count; i++)
                    {
                        var index = i;
                        var file = _repoInstructionFiles[index];
                        <MudPaper Class="pa-3 mb-3" Outlined>
                            <MudGrid>
                                <MudItem xs="12" md="5">
                                    <MudTextField Value="@file.Name" Label="File Name"
                                                  ValueChanged="@((string v) => UpdateInstructionFileName(index, v))" />
                                </MudItem>
                                <MudItem xs="12" md="3">
                                    <MudNumericField Value="@file.Order" Label="Order"
                                                     ValueChanged="@((int v) => UpdateInstructionFileOrder(index, v))" />
                                </MudItem>
                                <MudItem xs="12" md="4" Class="d-flex align-center justify-end">
                                    <MudTooltip Text="Move Up">
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Size="Size.Small"
                                                       Disabled="@(index == 0)"
                                                       OnClick="() => MoveInstructionFile(index, -1)" />
                                    </MudTooltip>
                                    <MudTooltip Text="Move Down">
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Size="Size.Small"
                                                       Disabled="@(index == _repoInstructionFiles.Count - 1)"
                                                       OnClick="() => MoveInstructionFile(index, 1)" />
                                    </MudTooltip>
                                    <MudTooltip Text="Remove">
                                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error"
                                                       OnClick="() => RemoveInstructionFile(index)" />
                                    </MudTooltip>
                                </MudItem>
                            </MudGrid>
                            <div style="height: 320px;" class="mt-2">
                                <StandaloneCodeEditor @key="@($"repo-instr-{index}-{file.Name}")"
                                                      Id="@($"repoInstrEditor_{index}")"
                                                      CssClass="monaco-fill-parent"
                                                      ConstructionOptions="InstructionEditorOptions"
                                                      OnDidChangeModelContent="() => OnInstructionContentChanged(index)"
                                                      @ref="_instructionEditors[index]" />
                            </div>
                        </MudPaper>
                    }

                    <MudStack Row Spacing="2">
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="AddInstructionFile"
                                   StartIcon="@Icons.Material.Filled.Add">Add Instruction File</MudButton>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveInstructionFilesAsync">Save Instructions</MudButton>
                    </MudStack>

                    @if (!string.IsNullOrWhiteSpace(_instructionSaveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">@_instructionSaveMessage</MudAlert>
                    }
                </MudPaper>
            </MudTabPanel>

            <MudTabPanel Text="Secrets & Webhooks">
                <MudPaper Class="pa-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Repository Secrets</MudText>
                    <MudGrid>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_githubToken" Label="GitHub Token (GH_TOKEN)" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_codexToken" Label="Codex API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_opencodeToken" Label="OpenCode API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_claudeToken" Label="Claude Code API Key" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_zaiToken" Label="Z.ai API Key (Z_AI_API_KEY)" InputType="InputType.Password" />
                        </MudItem>
                        <MudItem xs="12" md="6">
                            <MudTextField @bind-Value="_llmTornadoToken" Label="LlmTornado Key (ANTHROPIC_AUTH_TOKEN)" InputType="InputType.Password" />
                        </MudItem>
                    </MudGrid>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveSecretsAsync" Class="mt-3">Save Secrets</MudButton>

                    @if (!string.IsNullOrWhiteSpace(_saveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">@_saveMessage</MudAlert>
                    }
                </MudPaper>
            </MudTabPanel>
        </MudTabs>
    </MudStack>
}

@code {
    [Parameter] public string RepositoryId { get; set; } = string.Empty;

    private RepositoryDocument? _repository;

    private readonly List<TaskDocument> _tasks = [];
    private readonly List<RunDocument> _runs = [];
    private readonly List<FindingDocument> _findings = [];
    private readonly Dictionary<string, RunDocument?> _latestRunsByTaskId = new(StringComparer.Ordinal);
    private bool _taskStatusLoading;
    private List<TaskTemplateDocument> _templates = [];
    private readonly List<PromptSkillDocument> _repositoryPromptSkills = [];
    private readonly List<PromptSkillDocument> _globalPromptSkills = [];

    private string _taskName = string.Empty;
    private TaskKind _taskKind = TaskKind.OneShot;
    private string _taskHarness = "codex";
    private string _taskCron = string.Empty;
    private string _taskPrompt = "Describe the task objective and expected output in JSON envelope format.";
    private string _taskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Sample run\",\"artifacts\":[]}'";
    private HarnessExecutionMode _taskExecutionModeDefault = HarnessExecutionMode.Default;
    private bool _taskAutoPr;
    private bool _taskEnabled = true;
    private string? _editingTaskId = null;
    private int _taskRetryMaxAttempts = 1;
    private int _taskExecutionTimeout = 600;
    private int _taskOverallTimeout = 1800;
    private double _taskCpuLimit = 1.5;
    private string _taskMemoryLimit = "2g";
    private bool _taskNetworkDisabled;
    private bool _taskReadOnlyRootFs;
    private int _taskMaxArtifacts = 50;
    private long _taskMaxTotalSizeBytes = 104_857_600;
    private List<string> _taskArtifactPatterns = [];
    private List<string> _taskLinkedFailureRuns = [];
    private string _githubToken = string.Empty;
    private string _codexToken = string.Empty;
    private string _opencodeToken = string.Empty;
    private string _claudeToken = string.Empty;
    private string _zaiToken = string.Empty;
    private string _llmTornadoToken = string.Empty;
    private string _saveMessage = string.Empty;
    private readonly List<InstructionFileEdit> _repoInstructionFiles = [];
    private readonly Dictionary<int, StandaloneCodeEditor> _instructionEditors = [];
    private StandaloneCodeEditor? _taskPromptEditor;
    private string _instructionSaveMessage = string.Empty;
    private bool _isGeneratingTaskPrompt;
    private string _promptSkillName = string.Empty;
    private string _promptSkillTrigger = string.Empty;
    private string _promptSkillDescription = string.Empty;
    private string _promptSkillContent = string.Empty;
    private bool _promptSkillEnabled = true;
    private string? _editingPromptSkillId;
    private bool _taskPromptSkillAutocompleteBound;
    private int _taskPromptSkillAutocompleteVersion;
    private int _taskPromptSkillAutocompleteSyncedVersion = -1;
    private const string MonacoTheme = "agents-dashboard-dark";
    private const string GlobalRepositoryScope = "global";

    private StandaloneEditorConstructionOptions InstructionEditorOptions(StandaloneCodeEditor editor)
        => new()
        {
            AutomaticLayout = true,
            Language = "markdown",
            Theme = MonacoTheme,
            Minimap = new EditorMinimapOptions { Enabled = false },
            WordWrap = "on",
            FontSize = 13,
            Value = GetInstructionEditorValue(editor),
        };

    private string GetInstructionEditorValue(StandaloneCodeEditor editor)
    {
        var entry = _instructionEditors.FirstOrDefault(kv => kv.Value == editor);
        if (entry.Value is not null && entry.Key < _repoInstructionFiles.Count)
            return _repoInstructionFiles[entry.Key].Content;

        var index = _repoInstructionFiles.Count - 1;
        return index >= 0 ? _repoInstructionFiles[index].Content : string.Empty;
    }

    private StandaloneEditorConstructionOptions EditorOptions(StandaloneCodeEditor editor)
        => new()
        {
            AutomaticLayout = true,
            Language = "markdown",
            Theme = MonacoTheme,
            Minimap = new EditorMinimapOptions { Enabled = false },
            WordWrap = "on",
            FontSize = 13,
            Value = _taskPrompt,
        };

    protected override async Task OnParametersSetAsync()
    {
        _repository = await Store.GetRepositoryAsync(RepositoryId, CancellationToken.None);

        if (_repository is null)
        {
            return;
        }

        await Store.TouchRepositoryAsync(_repository.Id, CancellationToken.None);
        _templates = await TemplateService.ListTemplatesAsync(CancellationToken.None);
        _taskPromptSkillAutocompleteBound = false;
        _taskPromptSkillAutocompleteSyncedVersion = -1;
        await LoadPromptSkillsAsync();
        await RefreshAsync();
        await LoadInstructionFilesAsync();
        await RefreshGitStatusAsync();
    }

    private void ApplyTemplate(TaskTemplateDocument template)
    {
        _taskName = template.Name;
        _taskKind = template.Kind;
        _taskHarness = template.Harness;
        _taskCommand = template.Commands.Count > 0 ? string.Join(" && ", template.Commands) : string.Empty;
        _taskPrompt = template.Prompt;
        _taskCron = template.CronExpression;
        _taskExecutionModeDefault = HarnessExecutionMode.Default;
        _taskEnabled = true;
        _taskAutoPr = template.AutoCreatePullRequest;
        _taskRetryMaxAttempts = template.RetryPolicy.MaxAttempts;
        _taskExecutionTimeout = template.Timeouts.ExecutionSeconds;
        _taskOverallTimeout = template.Timeouts.OverallSeconds;
        _taskCpuLimit = template.SandboxProfile.CpuLimit;
        _taskMemoryLimit = template.SandboxProfile.MemoryLimit;
        _taskNetworkDisabled = template.SandboxProfile.NetworkDisabled;
        _taskReadOnlyRootFs = template.SandboxProfile.ReadOnlyRootFs;
        _taskMaxArtifacts = template.ArtifactPolicy.MaxArtifacts;
        _taskMaxTotalSizeBytes = template.ArtifactPolicy.MaxTotalSizeBytes;
        _taskArtifactPatterns = [.. template.ArtifactPatterns];
        _taskLinkedFailureRuns = [.. template.LinkedFailureRuns];
        _editingTaskId = null;
        StateHasChanged();
    }

    private void StartEditTask(TaskDocument task)
    {
        _editingTaskId = task.Id;
        _taskName = task.Name;
        _taskKind = task.Kind;
        _taskHarness = task.Harness;
        _taskCommand = task.Command;
        _taskPrompt = task.Prompt;
        _taskCron = task.CronExpression;
        _taskExecutionModeDefault = task.ExecutionModeDefault ?? HarnessExecutionMode.Default;
        _taskEnabled = task.Enabled;
        _taskAutoPr = task.AutoCreatePullRequest;
        _taskRetryMaxAttempts = task.RetryPolicy.MaxAttempts;
        _taskExecutionTimeout = task.Timeouts.ExecutionSeconds;
        _taskOverallTimeout = task.Timeouts.OverallSeconds;
        _taskCpuLimit = task.SandboxProfile.CpuLimit;
        _taskMemoryLimit = task.SandboxProfile.MemoryLimit;
        _taskNetworkDisabled = task.SandboxProfile.NetworkDisabled;
        _taskReadOnlyRootFs = task.SandboxProfile.ReadOnlyRootFs;
        _taskMaxArtifacts = task.ArtifactPolicy.MaxArtifacts;
        _taskMaxTotalSizeBytes = task.ArtifactPolicy.MaxTotalSizeBytes;
        _taskArtifactPatterns = [.. task.ArtifactPatterns];
        _taskLinkedFailureRuns = [.. task.LinkedFailureRuns];
        _ = SyncTaskPromptEditorAsync();
        StateHasChanged();
    }

    private void CancelEdit()
    {
        _editingTaskId = null;
        _taskName = string.Empty;
        _taskCron = string.Empty;
        _taskAutoPr = false;
        _taskEnabled = true;
        _taskExecutionModeDefault = HarnessExecutionMode.Default;
        _taskPrompt = "Describe the task objective and expected output in JSON envelope format.";
        _taskCommand = "echo '{\"status\":\"succeeded\",\"summary\":\"Sample run\",\"artifacts\":[]}'";
        _taskRetryMaxAttempts = 1;
        _taskExecutionTimeout = 600;
        _taskOverallTimeout = 1800;
        _taskCpuLimit = 1.5;
        _taskMemoryLimit = "2g";
        _taskNetworkDisabled = false;
        _taskReadOnlyRootFs = false;
        _taskMaxArtifacts = 50;
        _taskMaxTotalSizeBytes = 104_857_600;
        _taskArtifactPatterns = [];
        _taskLinkedFailureRuns = [];
        _ = SyncTaskPromptEditorAsync();
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await SyncTaskPromptSkillAutocompleteAsync();
    }

    private async Task SavePromptSkillAsync()
    {
        if (_repository is null)
        {
            return;
        }

        var trigger = NormalizePromptSkillTriggerInput(_promptSkillTrigger);

        try
        {
            if (_editingPromptSkillId is not null)
            {
                var updateRequest = new UpdatePromptSkillRequest(
                    _promptSkillName,
                    trigger,
                    _promptSkillContent,
                    _promptSkillDescription,
                    _promptSkillEnabled);
                var updated = await Store.UpdatePromptSkillAsync(_editingPromptSkillId, updateRequest, CancellationToken.None);
                if (updated is null)
                {
                    Snackbar.Add("Skill not found.", Severity.Warning);
                    return;
                }
            }
            else
            {
                var createRequest = new CreatePromptSkillRequest(
                    _repository.Id,
                    _promptSkillName,
                    trigger,
                    _promptSkillContent,
                    _promptSkillDescription,
                    _promptSkillEnabled);
                await Store.CreatePromptSkillAsync(createRequest, CancellationToken.None);
            }

            CancelPromptSkillEdit();
            await LoadPromptSkillsAsync();
            Snackbar.Add("Skill saved.", Severity.Success);
        }
        catch (ArgumentException ex)
        {
            Snackbar.Add(ex.Message, Severity.Warning);
        }
        catch (InvalidOperationException ex)
        {
            Snackbar.Add(ex.Message, Severity.Warning);
        }
    }

    private void StartEditPromptSkill(PromptSkillDocument skill)
    {
        _editingPromptSkillId = skill.Id;
        _promptSkillName = skill.Name;
        _promptSkillTrigger = skill.Trigger;
        _promptSkillDescription = skill.Description;
        _promptSkillContent = skill.Content;
        _promptSkillEnabled = skill.Enabled;
    }

    private void CancelPromptSkillEdit()
    {
        _editingPromptSkillId = null;
        _promptSkillName = string.Empty;
        _promptSkillTrigger = string.Empty;
        _promptSkillDescription = string.Empty;
        _promptSkillContent = string.Empty;
        _promptSkillEnabled = true;
    }

    private async Task DeletePromptSkillAsync(PromptSkillDocument skill)
    {
        var deleted = await Store.DeletePromptSkillAsync(skill.Id, CancellationToken.None);
        if (!deleted)
        {
            Snackbar.Add("Skill not found.", Severity.Warning);
            return;
        }

        if (_editingPromptSkillId == skill.Id)
        {
            CancelPromptSkillEdit();
        }

        await LoadPromptSkillsAsync();
        Snackbar.Add("Skill deleted.", Severity.Success);
    }

    private async Task LoadPromptSkillsAsync()
    {
        if (_repository is null)
        {
            return;
        }

        var skills = await Store.ListPromptSkillsAsync(_repository.Id, includeGlobal: true, CancellationToken.None);

        _repositoryPromptSkills.Clear();
        _repositoryPromptSkills.AddRange(
            skills
                .Where(x => x.RepositoryId == _repository.Id)
                .OrderBy(x => x.Trigger)
                .ToList());

        _globalPromptSkills.Clear();
        _globalPromptSkills.AddRange(
            skills
                .Where(x => x.RepositoryId == GlobalRepositoryScope)
                .OrderBy(x => x.Trigger)
                .ToList());

        _taskPromptSkillAutocompleteVersion++;
    }

    private async Task SyncTaskPromptSkillAutocompleteAsync()
    {
        if (_repository is null)
        {
            return;
        }

        if (_taskPromptSkillAutocompleteSyncedVersion == _taskPromptSkillAutocompleteVersion && _taskPromptSkillAutocompleteBound)
        {
            return;
        }

        var payload = BuildTaskPromptSkillAutocompletePayload();

        try
        {
            var bound = await JS.InvokeAsync<bool>(
                "agentsDashboardSkillAutocomplete.bindTaskPromptEditor",
                "promptEditor",
                payload);

            if (!bound)
            {
                return;
            }

            _taskPromptSkillAutocompleteBound = true;
            _taskPromptSkillAutocompleteSyncedVersion = _taskPromptSkillAutocompleteVersion;
        }
        catch (JSException)
        {
            _taskPromptSkillAutocompleteBound = false;
        }
    }

    private List<PromptSkillAutocompleteEntry> BuildTaskPromptSkillAutocompletePayload()
    {
        var payload = new List<PromptSkillAutocompleteEntry>();
        var seenTriggers = new HashSet<string>(StringComparer.Ordinal);

        foreach (var skill in _repositoryPromptSkills.Where(x => x.Enabled))
        {
            if (!seenTriggers.Add(skill.Trigger))
            {
                continue;
            }

            payload.Add(new PromptSkillAutocompleteEntry(
                skill.Trigger,
                skill.Content,
                skill.Description,
                "Repository skill",
                0,
                true));
        }

        foreach (var skill in _globalPromptSkills.Where(x => x.Enabled))
        {
            if (!seenTriggers.Add(skill.Trigger))
            {
                continue;
            }

            payload.Add(new PromptSkillAutocompleteEntry(
                skill.Trigger,
                skill.Content,
                skill.Description,
                "Global skill",
                1,
                true));
        }

        return payload;
    }

    private static string NormalizePromptSkillTriggerInput(string trigger)
    {
        return (trigger?.Trim() ?? string.Empty).TrimStart('/').ToLowerInvariant();
    }

    private async Task CreateTaskAsync()
    {
        if (_repository is null || string.IsNullOrWhiteSpace(_taskName))
        {
            return;
        }

        if (_taskPromptEditor is not null)
            _taskPrompt = await _taskPromptEditor.GetValue();

        var retryPolicy = new RetryPolicyConfig(_taskRetryMaxAttempts);
        var timeouts = new TimeoutConfig(_taskExecutionTimeout, _taskOverallTimeout);
        var sandboxProfile = new SandboxProfileConfig(_taskCpuLimit, _taskMemoryLimit, _taskNetworkDisabled, _taskReadOnlyRootFs);
        var artifactPolicy = new ArtifactPolicyConfig(_taskMaxArtifacts, _taskMaxTotalSizeBytes);

        if (_editingTaskId is not null)
        {
            var updateRequest = new UpdateTaskRequest(
                Name: _taskName.Trim(),
                Kind: _taskKind,
                Harness: _taskHarness,
                Prompt: _taskPrompt,
                Command: _taskCommand,
                AutoCreatePullRequest: _taskAutoPr,
                CronExpression: _taskCron,
                Enabled: _taskEnabled,
                RetryPolicy: retryPolicy,
                Timeouts: timeouts,
                SandboxProfile: sandboxProfile,
                ArtifactPolicy: artifactPolicy,
                ArtifactPatterns: _taskArtifactPatterns.Count > 0 ? _taskArtifactPatterns : null,
                LinkedFailureRuns: _taskLinkedFailureRuns.Count > 0 ? _taskLinkedFailureRuns : null,
                ExecutionModeDefault: _taskExecutionModeDefault);
            await Store.UpdateTaskAsync(_editingTaskId, updateRequest, CancellationToken.None);
            _editingTaskId = null;
        }
        else
        {
            var request = new CreateTaskRequest(
                RepositoryId: _repository.Id,
                Name: _taskName.Trim(),
                Kind: _taskKind,
                Harness: _taskHarness,
                Prompt: _taskPrompt,
                Command: _taskCommand,
                AutoCreatePullRequest: _taskAutoPr,
                CronExpression: _taskCron,
                Enabled: _taskEnabled,
                RetryPolicy: retryPolicy,
                Timeouts: timeouts,
                SandboxProfile: sandboxProfile,
                ArtifactPolicy: artifactPolicy,
                ArtifactPatterns: _taskArtifactPatterns.Count > 0 ? _taskArtifactPatterns : null,
                LinkedFailureRuns: _taskLinkedFailureRuns.Count > 0 ? _taskLinkedFailureRuns : null,
                ExecutionModeDefault: _taskExecutionModeDefault);

            await Store.CreateTaskAsync(request, CancellationToken.None);
        }

        _taskName = string.Empty;
        _taskCron = string.Empty;
        _taskAutoPr = false;
        _taskArtifactPatterns = [];
        _taskLinkedFailureRuns = [];

        await RefreshAsync();
    }

    private async Task GenerateTaskPromptAsync()
    {
        if (_repository is null)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_taskName))
        {
            Snackbar.Add("Set a task name before generating a prompt.", Severity.Warning);
            return;
        }

        _isGeneratingTaskPrompt = true;
        StateHasChanged();

        try
        {
            var llmTornadoSecret = await Store.GetProviderSecretAsync("global", "llmtornado", CancellationToken.None);
            var zaiSecret = await Store.GetProviderSecretAsync("global", "zai", CancellationToken.None);
            string? apiKey = null;

            if (llmTornadoSecret is not null && !string.IsNullOrWhiteSpace(llmTornadoSecret.EncryptedValue))
            {
                apiKey = Crypto.Decrypt(llmTornadoSecret.EncryptedValue);
            }
            else if (zaiSecret is not null && !string.IsNullOrWhiteSpace(zaiSecret.EncryptedValue))
            {
                apiKey = Crypto.Decrypt(zaiSecret.EncryptedValue);
            }

            if (string.IsNullOrWhiteSpace(apiKey))
            {
                Snackbar.Add("Configure a global LlmTornado key in Provider Settings first.", Severity.Warning);
                return;
            }

            var result = await LlmTornadoGateway.GenerateTaskPromptAsync(
                new TaskPromptGenerationRequest(
                    _repository.Name,
                    _taskName.Trim(),
                    _taskHarness,
                    _taskKind.ToString(),
                    _taskCommand,
                    _taskCron),
                apiKey,
                CancellationToken.None);

            if (!result.Success)
            {
                Snackbar.Add(result.Error ?? "Failed to generate prompt.", Severity.Error);
                return;
            }

            _taskPrompt = result.Prompt;
            await SyncTaskPromptEditorAsync();
            Snackbar.Add("Prompt generated with GLM-5.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to generate prompt: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isGeneratingTaskPrompt = false;
            StateHasChanged();
        }
    }

    private async Task SyncTaskPromptEditorAsync()
    {
        if (_taskPromptEditor is not null)
            await _taskPromptEditor.SetValue(_taskPrompt);
    }

    private async Task DeleteTaskAsync(TaskDocument task)
    {
        await Store.DeleteTaskAsync(task.Id, CancellationToken.None);
        await RefreshAsync();
    }

    private async Task TriggerTaskAsync(TaskDocument task)
    {
        if (_repository is null)
        {
            return;
        }

        var run = await Store.CreateRunAsync(task, CancellationToken.None);
        await Dispatcher.DispatchAsync(_repository, task, run, CancellationToken.None);

        await RefreshAsync();
    }

    private async Task RefreshGitStatusAsync()
    {
        if (_repository is null)
        {
            return;
        }

        try
        {
            var githubToken = await TryGetGithubTokenAsync(_repository.Id);
            var gitStatus = await GitWorkspace.RefreshStatusAsync(_repository, githubToken, fetchRemote: true, CancellationToken.None);
            _repository = await Store.UpdateRepositoryGitStateAsync(_repository.Id, gitStatus, CancellationToken.None);
            if (_repository is null)
            {
                _repository = await Store.GetRepositoryAsync(RepositoryId, CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Git refresh failed: {ex.Message}", Severity.Warning);
        }
    }

    private async Task<string?> TryGetGithubTokenAsync(string repositoryId)
    {
        var secret = await Store.GetProviderSecretAsync(repositoryId, "github", CancellationToken.None);
        if (secret is null)
        {
            return null;
        }

        try
        {
            return Crypto.Decrypt(secret.EncryptedValue);
        }
        catch
        {
            return null;
        }
    }

    private async Task RefreshAsync()
    {
        if (_repository is null)
        {
            return;
        }

        _tasks.Clear();
        _tasks.AddRange(await Store.ListTasksAsync(_repository.Id, CancellationToken.None));

        _runs.Clear();
        _runs.AddRange(await Store.ListRunsByRepositoryAsync(_repository.Id, CancellationToken.None));
        await RefreshLatestRunsByTaskAsync();

        _findings.Clear();
        _findings.AddRange(await Store.ListFindingsAsync(_repository.Id, CancellationToken.None));
    }

    private RunDocument? GetLatestRunForTask(string taskId)
        => _latestRunsByTaskId.GetValueOrDefault(taskId);

    private async Task RefreshLatestRunsByTaskAsync()
    {
        _taskStatusLoading = true;
        try
        {
            _latestRunsByTaskId.Clear();
            if (_tasks.Count == 0)
            {
                return;
            }

            var latestRunsByTaskId = await Store.GetLatestRunsByTaskIdsAsync(
                _tasks.Select(task => task.Id).ToList(),
                CancellationToken.None);

            foreach (var task in _tasks)
            {
                _latestRunsByTaskId[task.Id] = latestRunsByTaskId.GetValueOrDefault(task.Id);
            }
        }
        finally
        {
            _taskStatusLoading = false;
        }
    }

    private async Task SaveSecretsAsync()
    {
        if (_repository is null)
        {
            return;
        }

        await SaveSecretIfPresentAsync("github", _githubToken);
        await SaveSecretIfPresentAsync("codex", _codexToken);
        await SaveSecretIfPresentAsync("opencode", _opencodeToken);
        await SaveSecretIfPresentAsync("claude-code", _claudeToken);
        await SaveSecretIfPresentAsync("zai", _zaiToken);
        await SaveSecretIfPresentAsync("llmtornado", _llmTornadoToken);

        _saveMessage = "Secrets saved.";
        await RefreshAsync();
    }

    private async Task SaveSecretIfPresentAsync(string provider, string value)
    {
        if (_repository is null || string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        await Store.UpsertProviderSecretAsync(_repository.Id, provider, Crypto.Encrypt(value.Trim()), CancellationToken.None);
    }

    private async Task LoadInstructionFilesAsync()
    {
        if (_repository is null) return;
        var files = await Store.GetRepositoryInstructionFilesAsync(_repository.Id, CancellationToken.None);
        _repoInstructionFiles.Clear();
        _instructionEditors.Clear();
        foreach (var f in files.OrderBy(f => f.Order))
            _repoInstructionFiles.Add(new InstructionFileEdit { Name = f.Name, Content = f.Content, Order = f.Order });
    }

    private void AddInstructionFile()
    {
        var nextOrder = _repoInstructionFiles.Count > 0 ? _repoInstructionFiles.Max(f => f.Order) + 1 : 0;
        _repoInstructionFiles.Add(new InstructionFileEdit { Name = $"instruction-{nextOrder}.md", Content = string.Empty, Order = nextOrder });
        StateHasChanged();
    }

    private void RemoveInstructionFile(int index)
    {
        _repoInstructionFiles.RemoveAt(index);
        _instructionEditors.Remove(index);
        StateHasChanged();
    }

    private void UpdateInstructionFileName(int index, string name)
    {
        _repoInstructionFiles[index].Name = name;
    }

    private void UpdateInstructionFileOrder(int index, int order)
    {
        _repoInstructionFiles[index].Order = order;
    }

    private void MoveInstructionFile(int index, int direction)
    {
        var newIndex = index + direction;
        if (newIndex < 0 || newIndex >= _repoInstructionFiles.Count) return;
        (_repoInstructionFiles[index], _repoInstructionFiles[newIndex]) = (_repoInstructionFiles[newIndex], _repoInstructionFiles[index]);
        for (var i = 0; i < _repoInstructionFiles.Count; i++)
            _repoInstructionFiles[i].Order = i;
        StateHasChanged();
    }

    private async void OnInstructionContentChanged(int index)
    {
        if (_instructionEditors.TryGetValue(index, out var editor))
            _repoInstructionFiles[index].Content = await editor.GetValue();
    }

    private async Task SaveInstructionFilesAsync()
    {
        if (_repository is null) return;

        foreach (var kv in _instructionEditors)
        {
            if (kv.Key < _repoInstructionFiles.Count)
                _repoInstructionFiles[kv.Key].Content = await kv.Value.GetValue();
        }

        var files = _repoInstructionFiles
            .Select(f => new InstructionFile(f.Name, f.Content, f.Order))
            .ToList();
        await Store.UpdateRepositoryInstructionFilesAsync(_repository.Id, files, CancellationToken.None);
        _instructionSaveMessage = "Instructions saved.";
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("agentsDashboardSkillAutocomplete.unbindTaskPromptEditor", "promptEditor");
        }
        catch (JSDisconnectedException)
        {
        }
        catch (InvalidOperationException)
        {
        }
    }

    private sealed record PromptSkillAutocompleteEntry(
        string Trigger,
        string Content,
        string Description,
        string ScopeLabel,
        int ScopePriority,
        bool Enabled);

    private sealed class InstructionFileEdit
    {
        public string Name { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public int Order { get; set; }
    }
}

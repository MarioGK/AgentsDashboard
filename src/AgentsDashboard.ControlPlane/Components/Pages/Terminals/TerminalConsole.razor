@page "/settings/terminals"
@layout SettingsLayout
@rendermode InteractiveServer
@using AgentsDashboard.Contracts.Worker
@using AgentsDashboard.ControlPlane.Services

@inject NavigationManager Navigation
@inject AgentsDashboard.ControlPlane.Data.IOrchestratorStore Store
@inject IWorkerRegistryService WorkerRegistry
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject AgentsDashboard.ControlPlane.Services.ITerminalBridgeService TerminalBridge
@implements IAsyncDisposable

<PageTitle>Terminals - AgentsDashboard</PageTitle>

<MudStack Row AlignItems="AlignItems.Center" Class="mb-4">
    <MudText Typo="Typo.h4">Terminals</MudText>
    <MudSpacer />
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Filled.Add"
               OnClick="OpenNewTerminalDialogAsync">
        New Terminal
    </MudButton>
</MudStack>

@if (_tabs.Count == 0)
{
    <MudPaper Class="pa-8 d-flex flex-column align-center justify-center" Elevation="2" Style="min-height: 400px;">
        <MudIcon Icon="@Icons.Material.Filled.Terminal" Size="Size.Large" Color="Color.Secondary" Class="mb-4" />
        <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mb-2">No Terminal Sessions</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">Click "New Terminal" to connect to a worker.</MudText>
    </MudPaper>
}
else
{
    <MudTabs @bind-ActivePanelIndex="_activeTabIndex"
             Elevation="2"
             Rounded
             ApplyEffectsToContainer
             PanelClass="pa-0"
             KeepPanelsAlive>
        @foreach (var tab in _tabs)
        {
            <MudTabPanel @key="tab.SessionId"
                         Text="@tab.Label"
                         BadgeDot="@(!tab.IsConnected)"
                         BadgeColor="@(tab.IsConnected ? Color.Success : Color.Error)"
                         Icon="@Icons.Material.Filled.Terminal">
                <div style="position: relative;">
                    @if (!tab.IsConnected && tab.State != TerminalTabState.Connecting)
                    {
                        <MudAlert Severity="Severity.Warning" Dense Class="rounded-0">
                            Session disconnected.
                            <MudButton Variant="Variant.Text" Color="Color.Warning" Size="Size.Small"
                                       OnClick="() => ReconnectTabAsync(tab)">
                                Reconnect
                            </MudButton>
                            <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small"
                                       OnClick="() => CloseTabAsync(tab)">
                                Close
                            </MudButton>
                        </MudAlert>
                    }
                    <div id="@tab.ElementId"
                         style="height: 520px; background: #07090d; border: 1px solid rgba(165, 177, 193, 0.12); border-bottom: 0; border-radius: 12px 12px 0 0;"
                         @onclick="() => FocusTerminalAsync(tab)">
                    </div>
                    <MudStack Row AlignItems="AlignItems.Center" Class="px-2 py-1" Style="background: #0b0d11; border: 1px solid rgba(165, 177, 193, 0.12); border-top: 1px solid rgba(165, 177, 193, 0.08); border-radius: 0 0 12px 12px;">
                        <MudChip T="string" Size="Size.Small"
                                 Color="@(tab.IsConnected ? Color.Success : Color.Error)">
                            @(tab.IsConnected ? "Connected" : "Disconnected")
                        </MudChip>
                        <MudText Typo="Typo.caption" Style="color: #a5b1c1;">
                            Session: @tab.SessionId[..Math.Min(12, tab.SessionId.Length)]
                        </MudText>
                        <MudSpacer />
                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                       Size="Size.Small"
                                       Color="Color.Error"
                                       OnClick="() => CloseTabAsync(tab)" />
                    </MudStack>
                </div>
            </MudTabPanel>
        }
    </MudTabs>
}

<MudDialog @bind-Visible="_showNewTerminalDialog" Options="_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Terminal" Class="mr-2" />
            New Terminal Session
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (_workersLoading)
        {
            <MudProgressLinear Indeterminate Class="mb-4" />
        }
        else if (_availableWorkers.Count == 0)
        {
            <MudAlert Severity="Severity.Info">No online workers are currently registered. A worker will be started automatically when you connect.</MudAlert>
        }
        else
        {
            <MudSelect T="string"
                       @bind-Value="_selectedWorkerId"
                       Label="Select Worker"
                       Variant="Variant.Outlined"
                       AnchorOrigin="Origin.BottomCenter"
                       Class="mb-4">
                @foreach (var worker in _availableWorkers)
                {
                    <MudSelectItem Value="@worker.WorkerId">
                        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                            <MudIcon Icon="@Icons.Material.Filled.Dns" Size="Size.Small" />
                            <span>@worker.WorkerId</span>
                            <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                @worker.ActiveSlots/@worker.MaxSlots slots
                            </MudChip>
                        </MudStack>
                    </MudSelectItem>
                }
            </MudSelect>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showNewTerminalDialog = false">Cancel</MudButton>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   Disabled="@(_workersLoading)"
                   OnClick="CreateTerminalSessionAsync">
            Connect
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [SupplyParameterFromQuery]
    public string? RunId { get; set; }

    private readonly string _clientId = Guid.NewGuid().ToString("N");
    private IJSObjectReference? _jsModule;
    private readonly List<TerminalTab> _tabs = [];
    private int _activeTabIndex;
    private bool _showNewTerminalDialog;
    private bool _workersLoading;
    private string? _selectedWorkerId;
    private List<WorkerInfo> _availableWorkers = [];
    private DotNetObjectReference<TerminalConsole>? _dotNetRef;

    private readonly DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Small,
        FullWidth = true,
        CloseOnEscapeKey = true
    };

    protected override Task OnInitializedAsync()
    {
        _dotNetRef = DotNetObjectReference.Create(this);

        TerminalBridge.RegisterClient(_clientId, new TerminalClientCallbacks
        {
            OnSessionOpenedAsync = OnTerminalSessionOpenedAsync,
            OnSessionOutputAsync = OnTerminalOutputAsync,
            OnSessionClosedAsync = OnTerminalSessionClosedAsync,
            OnSessionErrorAsync = OnTerminalSessionErrorAsync,
        });

        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                "import",
                "./Components/Pages/Terminals/TerminalConsole.razor.js");

            if (!string.IsNullOrEmpty(RunId))
            {
                await AutoCreateSessionForRunAsync();
            }
        }

        foreach (var tab in _tabs.Where(t => t.NeedsInit))
        {
            tab.NeedsInit = false;
            await InitTerminalForTabAsync(tab);

            while (tab.PendingOutput.Count > 0)
            {
                var output = tab.PendingOutput.Dequeue();
                await _jsModule!.InvokeVoidAsync("writeTerminal", tab.ElementId, output);
            }
        }
    }

    private async Task AutoCreateSessionForRunAsync()
    {
        try
        {
            var run = await Store.GetRunAsync(RunId!, CancellationToken.None);
            if (run is null) return;

            await LoadWorkersAsync();

            var rid = RunId!;
            await CreateSessionOnWorkerAsync(null, null, $"Run #{rid[..Math.Min(8, rid.Length)]}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to auto-create terminal: {ex.Message}", Severity.Error);
        }
    }

    private async Task OpenNewTerminalDialogAsync()
    {
        _selectedWorkerId = null;
        _showNewTerminalDialog = true;
        await LoadWorkersAsync();
    }

    private async Task LoadWorkersAsync()
    {
        _workersLoading = true;
        StateHasChanged();

        try
        {
            _availableWorkers = WorkerRegistry.GetRegisteredWorkers()
                .Select(w => new WorkerInfo
                {
                    WorkerId = w.WorkerId,
                    HostName = w.HostName,
                    ActiveSlots = w.ActiveSlots,
                    MaxSlots = w.MaxSlots,
                    LastHeartbeat = w.LastHeartbeat.ToUnixTimeSeconds()
                })
                .ToList();

            if (_availableWorkers.Count == 0)
            {
                var workers = await Store.ListWorkersAsync(CancellationToken.None);
                _availableWorkers = workers
                    .Where(w => w.Online)
                    .Select(w => new WorkerInfo
                    {
                        WorkerId = w.WorkerId,
                        HostName = w.Endpoint ?? w.WorkerId,
                        ActiveSlots = w.ActiveSlots,
                        MaxSlots = w.MaxSlots
                    })
                    .ToList();
            }

            if (_availableWorkers.Count > 0 && _selectedWorkerId is null)
                _selectedWorkerId = _availableWorkers[0].WorkerId;

            if (_availableWorkers.Count == 0)
                _selectedWorkerId = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load workers: {ex.Message}", Severity.Error);
        }
        finally
        {
            _workersLoading = false;
            StateHasChanged();
        }
    }

    private async Task CreateTerminalSessionAsync()
    {
        _showNewTerminalDialog = false;
        var workerName = string.IsNullOrWhiteSpace(_selectedWorkerId)
            ? "Auto"
            : _availableWorkers.FirstOrDefault(w => w.WorkerId == _selectedWorkerId)?.HostName ?? _selectedWorkerId;
        await CreateSessionOnWorkerAsync(_selectedWorkerId, null, workerName);
    }

    private async Task CreateSessionOnWorkerAsync(string? workerId, string? runId, string label)
    {
        var tab = new TerminalTab
        {
            Label = label,
            WorkerId = workerId ?? "auto",
            RunId = runId,
            State = TerminalTabState.Connecting
        };

        _tabs.Add(tab);
        _activeTabIndex = _tabs.Count - 1;
        StateHasChanged();

        try
        {
            var sessionId = await TerminalBridge.CreateSessionAsync(
                _clientId,
                workerId,
                runId,
                120,
                30,
                CancellationToken.None);

            tab.SessionId = sessionId;
            tab.NeedsInit = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            tab.State = TerminalTabState.Error;
            tab.IsConnected = false;
            Snackbar.Add($"Failed to create session: {ex.Message}", Severity.Error);
            StateHasChanged();
        }
    }

    private async Task InitTerminalForTabAsync(TerminalTab tab)
    {
        if (_jsModule is null || _dotNetRef is null) return;

        try
        {
            await _jsModule.InvokeVoidAsync("initTerminal", tab.ElementId, tab.SessionId, _dotNetRef);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to initialize terminal: {ex.Message}", Severity.Error);
        }
    }

    private async Task FocusTerminalAsync(TerminalTab tab)
    {
        if (_jsModule is null) return;
        try
        {
            await _jsModule.InvokeVoidAsync("focusTerminal", tab.ElementId);
        }
        catch
        {
        }
    }

    private async Task ReconnectTabAsync(TerminalTab tab)
    {
        try
        {
            tab.State = TerminalTabState.Connecting;
            StateHasChanged();

            await TerminalBridge.AttachSessionAsync(_clientId, tab.SessionId, tab.LastSequence, CancellationToken.None);
            tab.IsConnected = true;
            tab.State = TerminalTabState.Active;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            tab.State = TerminalTabState.Error;
            Snackbar.Add($"Failed to reconnect: {ex.Message}", Severity.Error);
            StateHasChanged();
        }
    }

    private async Task CloseTabAsync(TerminalTab tab)
    {
        try
        {
            if (tab.IsConnected)
            {
                await TerminalBridge.CloseAsync(tab.SessionId, CancellationToken.None);
            }
        }
        catch
        {
        }

        if (_jsModule is not null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("disposeTerminal", tab.ElementId);
            }
            catch
            {
            }
        }

        _tabs.Remove(tab);
        if (_activeTabIndex >= _tabs.Count)
            _activeTabIndex = Math.Max(0, _tabs.Count - 1);

        StateHasChanged();
    }

    private Task OnTerminalSessionOpenedAsync(TerminalSessionOpenedMessage message)
    {
        return InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == message.SessionId);
            if (tab is null) return;

            if (message.Success)
            {
                tab.IsConnected = true;
                tab.State = TerminalTabState.Active;
            }
            else
            {
                tab.IsConnected = false;
                tab.State = TerminalTabState.Error;
                Snackbar.Add($"Terminal session failed: {message.Error}", Severity.Error);
            }
            StateHasChanged();
        });
    }

    private Task OnTerminalOutputAsync(TerminalOutputMessage message)
    {
        return InvokeAsync(async () =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == message.SessionId);
            if (tab is null) return;

            tab.LastSequence = message.Sequence;

            if (_jsModule is null)
            {
                tab.PendingOutput.Enqueue(message.PayloadBase64);
                return;
            }

            try
            {
                await _jsModule.InvokeVoidAsync("writeTerminal", tab.ElementId, message.PayloadBase64);
            }
            catch
            {
            }
        });
    }

    private Task OnTerminalSessionClosedAsync(TerminalSessionClosedMessage message)
    {
        return InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == message.SessionId);
            if (tab is null) return;

            tab.IsConnected = false;
            tab.State = TerminalTabState.Closed;
            Snackbar.Add($"Terminal session closed{(message.Reason is not null ? $": {message.Reason}" : "")}", Severity.Info);
            StateHasChanged();
        });
    }

    private Task OnTerminalSessionErrorAsync(TerminalSessionErrorMessage message)
    {
        return InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == message.SessionId);
            if (tab is null) return;

            tab.IsConnected = false;
            tab.State = TerminalTabState.Error;
            Snackbar.Add($"Terminal error: {message.Error}", Severity.Error);
            StateHasChanged();
        });
    }

    [JSInvokable]
    public async Task OnTerminalData(string sessionId, string base64Input)
    {
        try
        {
            await TerminalBridge.SendInputAsync(sessionId, base64Input, CancellationToken.None);
        }
        catch
        {
        }
    }

    [JSInvokable]
    public async Task OnTerminalResize(string sessionId, int cols, int rows)
    {
        try
        {
            await TerminalBridge.ResizeAsync(sessionId, cols, rows, CancellationToken.None);
        }
        catch
        {
        }
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var tab in _tabs.ToList())
        {
            try
            {
                if (tab.IsConnected)
                {
                    await TerminalBridge.CloseAsync(tab.SessionId, CancellationToken.None);
                }
            }
            catch
            {
            }
        }

        await TerminalBridge.UnregisterClientAsync(_clientId, CancellationToken.None);

        if (_jsModule is not null)
        {
            foreach (var tab in _tabs)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("disposeTerminal", tab.ElementId);
                }
                catch
                {
                }
            }
            await _jsModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }

    private sealed class TerminalTab
    {
        public string SessionId { get; set; } = Guid.NewGuid().ToString("N");
        public string Label { get; set; } = "Terminal";
        public string WorkerId { get; set; } = string.Empty;
        public string? RunId { get; set; }
        public bool IsConnected { get; set; }
        public TerminalTabState State { get; set; } = TerminalTabState.Connecting;
        public long LastSequence { get; set; }
        public bool NeedsInit { get; set; }
        public Queue<string> PendingOutput { get; } = [];
        public string ElementId => $"terminal-{SessionId}";
    }

    private enum TerminalTabState
    {
        Connecting,
        Active,
        Closed,
        Error
    }

    private sealed class WorkerInfo
    {
        public string WorkerId { get; set; } = string.Empty;
        public string HostName { get; set; } = string.Empty;
        public int ActiveSlots { get; set; }
        public int MaxSlots { get; set; }
        public long LastHeartbeat { get; set; }
    }

}

@page "/terminals"
@rendermode InteractiveServer

@inject NavigationManager Navigation
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@implements IAsyncDisposable

<PageTitle>Terminals - AgentsDashboard</PageTitle>

<MudStack Row AlignItems="AlignItems.Center" Class="mb-4">
    <MudText Typo="Typo.h4">Terminals</MudText>
    <MudSpacer />
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               StartIcon="@Icons.Material.Filled.Add"
               OnClick="OpenNewTerminalDialogAsync"
               Disabled="@(_hubConnection?.State != HubConnectionState.Connected)">
        New Terminal
    </MudButton>
</MudStack>

@if (_hubConnection?.State != HubConnectionState.Connected)
{
    <MudAlert Severity="Severity.Warning" Class="mb-4">
        @if (_hubConnection?.State == HubConnectionState.Reconnecting)
        {
            <MudProgressCircular Size="Size.Small" Indeterminate Class="mr-2" />
            @:Reconnecting to terminal hub...
        }
        else
        {
            @:Connecting to terminal hub...
            <MudProgressCircular Size="Size.Small" Indeterminate Class="ml-2" />
        }
    </MudAlert>
}

@if (_tabs.Count == 0)
{
    <MudPaper Class="pa-8 d-flex flex-column align-center justify-center" Elevation="2" Style="min-height: 400px;">
        <MudIcon Icon="@Icons.Material.Filled.Terminal" Size="Size.Large" Color="Color.Secondary" Class="mb-4" />
        <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mb-2">No Terminal Sessions</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">Click "New Terminal" to connect to a worker.</MudText>
    </MudPaper>
}
else
{
    <MudTabs @bind-ActivePanelIndex="_activeTabIndex"
             Elevation="2"
             Rounded
             ApplyEffectsToContainer
             PanelClass="pa-0"
             KeepPanelsAlive>
        @foreach (var tab in _tabs)
        {
            <MudTabPanel @key="tab.SessionId"
                         Text="@tab.Label"
                         BadgeDot="@(!tab.IsConnected)"
                         BadgeColor="@(tab.IsConnected ? Color.Success : Color.Error)"
                         Icon="@Icons.Material.Filled.Terminal">
                <div style="position: relative;">
                    @if (!tab.IsConnected && tab.State != TerminalTabState.Connecting)
                    {
                        <MudAlert Severity="Severity.Warning" Dense Class="rounded-0">
                            Session disconnected.
                            <MudButton Variant="Variant.Text" Color="Color.Warning" Size="Size.Small"
                                       OnClick="() => ReconnectTabAsync(tab)">
                                Reconnect
                            </MudButton>
                            <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small"
                                       OnClick="() => CloseTabAsync(tab)">
                                Close
                            </MudButton>
                        </MudAlert>
                    }
                    <div id="@tab.ElementId"
                         style="height: 500px; background: #1e1e1e;"
                         @onclick="() => FocusTerminalAsync(tab)">
                    </div>
                    <MudStack Row AlignItems="AlignItems.Center" Class="px-2 py-1" Style="background: #2d2d2d;">
                        <MudChip T="string" Size="Size.Small"
                                 Color="@(tab.IsConnected ? Color.Success : Color.Error)">
                            @(tab.IsConnected ? "Connected" : "Disconnected")
                        </MudChip>
                        <MudText Typo="Typo.caption" Style="color: #888;">
                            Session: @tab.SessionId[..Math.Min(12, tab.SessionId.Length)]
                        </MudText>
                        <MudSpacer />
                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                       Size="Size.Small"
                                       Color="Color.Error"
                                       OnClick="() => CloseTabAsync(tab)" />
                    </MudStack>
                </div>
            </MudTabPanel>
        }
    </MudTabs>
}

<MudDialog @bind-Visible="_showNewTerminalDialog" Options="_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Terminal" Class="mr-2" />
            New Terminal Session
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (_workersLoading)
        {
            <MudProgressLinear Indeterminate Class="mb-4" />
        }
        else if (_availableWorkers.Count == 0)
        {
            <MudAlert Severity="Severity.Warning">No online workers available. Workers must be registered and online to open terminal sessions.</MudAlert>
        }
        else
        {
            <MudSelect T="string"
                       @bind-Value="_selectedWorkerId"
                       Label="Select Worker"
                       Variant="Variant.Outlined"
                       AnchorOrigin="Origin.BottomCenter"
                       Class="mb-4">
                @foreach (var worker in _availableWorkers)
                {
                    <MudSelectItem Value="@worker.WorkerId">
                        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                            <MudIcon Icon="@Icons.Material.Filled.Dns" Size="Size.Small" />
                            <span>@worker.WorkerId</span>
                            <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                @worker.ActiveSlots/@worker.MaxSlots slots
                            </MudChip>
                        </MudStack>
                    </MudSelectItem>
                }
            </MudSelect>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="() => _showNewTerminalDialog = false">Cancel</MudButton>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   Disabled="@(string.IsNullOrEmpty(_selectedWorkerId) || _workersLoading)"
                   OnClick="CreateTerminalSessionAsync">
            Connect
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [SupplyParameterFromQuery]
    public string? RunId { get; set; }

    private HubConnection? _hubConnection;
    private IJSObjectReference? _jsModule;
    private readonly List<TerminalTab> _tabs = [];
    private int _activeTabIndex;
    private bool _showNewTerminalDialog;
    private bool _workersLoading;
    private string? _selectedWorkerId;
    private List<WorkerInfo> _availableWorkers = [];
    private DotNetObjectReference<TerminalConsole>? _dotNetRef;

    private readonly DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Small,
        FullWidth = true,
        CloseOnEscapeKey = true
    };

    protected override async Task OnInitializedAsync()
    {
        _dotNetRef = DotNetObjectReference.Create(this);

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/hubs/terminal"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<string, bool, string?>("TerminalSessionOpened", OnTerminalSessionOpened);
        _hubConnection.On<string, long, string>("TerminalOutput", OnTerminalOutput);
        _hubConnection.On<string, string?>("TerminalSessionClosed", OnTerminalSessionClosed);
        _hubConnection.On<string, string>("TerminalSessionError", OnTerminalSessionError);

        _hubConnection.Reconnecting += _ =>
        {
            InvokeAsync(StateHasChanged);
            return Task.CompletedTask;
        };

        _hubConnection.Reconnected += _ =>
        {
            InvokeAsync(async () =>
            {
                foreach (var tab in _tabs.Where(t => t.IsConnected))
                {
                    try
                    {
                        await _hubConnection.InvokeAsync("AttachSession", tab.SessionId, tab.LastSequence);
                    }
                    catch (Exception ex)
                    {
                        tab.IsConnected = false;
                        Snackbar.Add($"Failed to reattach session: {ex.Message}", Severity.Warning);
                    }
                }
                StateHasChanged();
            });
            return Task.CompletedTask;
        };

        _hubConnection.Closed += _ =>
        {
            InvokeAsync(() =>
            {
                foreach (var tab in _tabs)
                    tab.IsConnected = false;
                StateHasChanged();
            });
            return Task.CompletedTask;
        };

        await _hubConnection.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                "import",
                "./Components/Pages/Terminals/TerminalConsole.razor.js");

            if (!string.IsNullOrEmpty(RunId))
            {
                await AutoCreateSessionForRunAsync();
            }
        }

        foreach (var tab in _tabs.Where(t => t.NeedsInit))
        {
            tab.NeedsInit = false;
            await InitTerminalForTabAsync(tab);
        }
    }

    private async Task AutoCreateSessionForRunAsync()
    {
        try
        {
            var client = HttpClientFactory.CreateClient("Api");
            var response = await client.GetAsync($"/api/runs/{RunId}");
            if (!response.IsSuccessStatusCode) return;

            var run = await response.Content.ReadFromJsonAsync<RunInfo>();
            if (run is null) return;

            await LoadWorkersAsync();

            var workerId = _availableWorkers.FirstOrDefault()?.WorkerId;
            if (workerId is null)
            {
                Snackbar.Add("No workers available for terminal session", Severity.Warning);
                return;
            }

            var rid = RunId!;
            await CreateSessionOnWorkerAsync(workerId, rid, $"Run #{rid[..Math.Min(8, rid.Length)]}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to auto-create terminal: {ex.Message}", Severity.Error);
        }
    }

    private async Task OpenNewTerminalDialogAsync()
    {
        _selectedWorkerId = null;
        _showNewTerminalDialog = true;
        await LoadWorkersAsync();
    }

    private async Task LoadWorkersAsync()
    {
        _workersLoading = true;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("Api");
            var response = await client.GetAsync("/api/workers/registered");

            if (response.IsSuccessStatusCode)
            {
                _availableWorkers = await response.Content.ReadFromJsonAsync<List<WorkerInfo>>() ?? [];
            }
            else
            {
                var storeResponse = await client.GetAsync("/api/workers");
                if (storeResponse.IsSuccessStatusCode)
                {
                    var workers = await storeResponse.Content.ReadFromJsonAsync<List<WorkerStoreInfo>>() ?? [];
                    _availableWorkers = workers
                        .Where(w => w.Online)
                        .Select(w => new WorkerInfo
                        {
                            WorkerId = w.WorkerId,
                            HostName = w.Endpoint ?? w.WorkerId,
                            ActiveSlots = w.ActiveSlots,
                            MaxSlots = w.MaxSlots
                        })
                        .ToList();
                }
            }

            if (_availableWorkers.Count > 0 && _selectedWorkerId is null)
                _selectedWorkerId = _availableWorkers[0].WorkerId;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load workers: {ex.Message}", Severity.Error);
        }
        finally
        {
            _workersLoading = false;
            StateHasChanged();
        }
    }

    private async Task CreateTerminalSessionAsync()
    {
        if (string.IsNullOrEmpty(_selectedWorkerId)) return;

        _showNewTerminalDialog = false;
        var workerName = _availableWorkers.FirstOrDefault(w => w.WorkerId == _selectedWorkerId)?.HostName ?? _selectedWorkerId;
        await CreateSessionOnWorkerAsync(_selectedWorkerId, null, workerName);
    }

    private async Task CreateSessionOnWorkerAsync(string workerId, string? runId, string label)
    {
        if (_hubConnection?.State != HubConnectionState.Connected) return;

        var tab = new TerminalTab
        {
            Label = label,
            WorkerId = workerId,
            RunId = runId,
            State = TerminalTabState.Connecting,
            NeedsInit = true
        };

        _tabs.Add(tab);
        _activeTabIndex = _tabs.Count - 1;
        StateHasChanged();

        try
        {
            var sessionId = await _hubConnection.InvokeAsync<string>(
                "CreateSession", workerId, runId, 120, 30);
            tab.SessionId = sessionId;
        }
        catch (Exception ex)
        {
            tab.State = TerminalTabState.Error;
            tab.IsConnected = false;
            Snackbar.Add($"Failed to create session: {ex.Message}", Severity.Error);
            StateHasChanged();
        }
    }

    private async Task InitTerminalForTabAsync(TerminalTab tab)
    {
        if (_jsModule is null || _dotNetRef is null) return;

        try
        {
            await _jsModule.InvokeVoidAsync("initTerminal", tab.ElementId, tab.SessionId, _dotNetRef);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to initialize terminal: {ex.Message}", Severity.Error);
        }
    }

    private async Task FocusTerminalAsync(TerminalTab tab)
    {
        if (_jsModule is null) return;
        try
        {
            await _jsModule.InvokeVoidAsync("focusTerminal", tab.ElementId);
        }
        catch { }
    }

    private async Task ReconnectTabAsync(TerminalTab tab)
    {
        if (_hubConnection?.State != HubConnectionState.Connected) return;

        try
        {
            tab.State = TerminalTabState.Connecting;
            StateHasChanged();

            await _hubConnection.InvokeAsync("AttachSession", tab.SessionId, tab.LastSequence);
            tab.IsConnected = true;
            tab.State = TerminalTabState.Active;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            tab.State = TerminalTabState.Error;
            Snackbar.Add($"Failed to reconnect: {ex.Message}", Severity.Error);
            StateHasChanged();
        }
    }

    private async Task CloseTabAsync(TerminalTab tab)
    {
        try
        {
            if (_hubConnection?.State == HubConnectionState.Connected && tab.IsConnected)
            {
                await _hubConnection.InvokeAsync("Close", tab.SessionId);
            }
        }
        catch { }

        if (_jsModule is not null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("disposeTerminal", tab.ElementId);
            }
            catch { }
        }

        _tabs.Remove(tab);
        if (_activeTabIndex >= _tabs.Count)
            _activeTabIndex = Math.Max(0, _tabs.Count - 1);
        StateHasChanged();
    }

    private void OnTerminalSessionOpened(string sessionId, bool success, string? error)
    {
        InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == sessionId);
            if (tab is null) return;

            if (success)
            {
                tab.IsConnected = true;
                tab.State = TerminalTabState.Active;
            }
            else
            {
                tab.IsConnected = false;
                tab.State = TerminalTabState.Error;
                Snackbar.Add($"Terminal session failed: {error}", Severity.Error);
            }
            StateHasChanged();
        });
    }

    private void OnTerminalOutput(string sessionId, long sequence, string payloadBase64)
    {
        InvokeAsync(async () =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == sessionId);
            if (tab is null || _jsModule is null) return;

            tab.LastSequence = sequence;

            try
            {
                await _jsModule.InvokeVoidAsync("writeTerminal", tab.ElementId, payloadBase64);
            }
            catch { }
        });
    }

    private void OnTerminalSessionClosed(string sessionId, string? reason)
    {
        InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == sessionId);
            if (tab is null) return;

            tab.IsConnected = false;
            tab.State = TerminalTabState.Closed;
            Snackbar.Add($"Terminal session closed{(reason is not null ? $": {reason}" : "")}", Severity.Info);
            StateHasChanged();
        });
    }

    private void OnTerminalSessionError(string sessionId, string error)
    {
        InvokeAsync(() =>
        {
            var tab = _tabs.FirstOrDefault(t => t.SessionId == sessionId);
            if (tab is null) return;

            tab.IsConnected = false;
            tab.State = TerminalTabState.Error;
            Snackbar.Add($"Terminal error: {error}", Severity.Error);
            StateHasChanged();
        });
    }

    [JSInvokable]
    public async Task OnTerminalData(string sessionId, string base64Input)
    {
        if (_hubConnection?.State != HubConnectionState.Connected) return;

        try
        {
            await _hubConnection.InvokeAsync("Input", sessionId, base64Input);
        }
        catch { }
    }

    [JSInvokable]
    public async Task OnTerminalResize(string sessionId, int cols, int rows)
    {
        if (_hubConnection?.State != HubConnectionState.Connected) return;

        try
        {
            await _hubConnection.InvokeAsync("Resize", sessionId, cols, rows);
        }
        catch { }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            foreach (var tab in _tabs)
            {
                try
                {
                    if (_hubConnection.State == HubConnectionState.Connected)
                        await _hubConnection.InvokeAsync("Close", tab.SessionId);
                }
                catch { }
            }
            await _hubConnection.DisposeAsync();
        }

        if (_jsModule is not null)
        {
            foreach (var tab in _tabs)
            {
                try
                {
                    await _jsModule.InvokeVoidAsync("disposeTerminal", tab.ElementId);
                }
                catch { }
            }
            await _jsModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }

    private sealed class TerminalTab
    {
        public string SessionId { get; set; } = Guid.NewGuid().ToString("N");
        public string Label { get; set; } = "Terminal";
        public string WorkerId { get; set; } = string.Empty;
        public string? RunId { get; set; }
        public bool IsConnected { get; set; }
        public TerminalTabState State { get; set; } = TerminalTabState.Connecting;
        public long LastSequence { get; set; }
        public bool NeedsInit { get; set; }
        public string ElementId => $"terminal-{SessionId}";
    }

    private enum TerminalTabState
    {
        Connecting,
        Active,
        Closed,
        Error
    }

    private sealed class WorkerInfo
    {
        public string WorkerId { get; set; } = string.Empty;
        public string HostName { get; set; } = string.Empty;
        public int ActiveSlots { get; set; }
        public int MaxSlots { get; set; }
        public long LastHeartbeat { get; set; }
    }

    private sealed class WorkerStoreInfo
    {
        public string WorkerId { get; set; } = string.Empty;
        public string? Endpoint { get; set; }
        public bool Online { get; set; }
        public int ActiveSlots { get; set; }
        public int MaxSlots { get; set; }
    }

    private sealed class RunInfo
    {
        public string Id { get; set; } = string.Empty;
        public string State { get; set; } = string.Empty;
        public string? WorkerId { get; set; }
    }
}

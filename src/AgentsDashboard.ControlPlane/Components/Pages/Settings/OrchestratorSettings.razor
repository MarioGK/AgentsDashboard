@page "/settings/task-runtimes"
@layout SettingsLayout
@rendermode InteractiveServer
@using AgentsDashboard.Contracts.Domain
@using AgentsDashboard.ControlPlane.Services
@using OrchestratorConfig = AgentsDashboard.Contracts.Domain.OrchestratorSettings
@inject AgentsDashboard.ControlPlane.Data.IOrchestratorStore Store
@inject AgentsDashboard.ControlPlane.Services.ITaskRuntimeLifecycleManager WorkerLifecycle
@inject AgentsDashboard.ControlPlane.Services.IOrchestratorRuntimeSettingsProvider RuntimeSettingsProvider
@inject AgentsDashboard.ControlPlane.Services.IBackgroundWorkCoordinator BackgroundWorkCoordinator
@inject ISnackbar Snackbar
@implements IDisposable

<PageTitle>Task Runtime Settings - AgentsDashboard</PageTitle>

<MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-4">
    <MudText Typo="Typo.h4">Task Runtime Settings</MudText>
    <MudSpacer />
    <MudButton Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Refresh" OnClick="RefreshAllAsync" Disabled="_loading || _saving">
        Refresh
    </MudButton>
</MudStack>

@if (_loading)
{
    <MudProgressLinear Indeterminate="true" />
}
else
{
    <MudGrid>
        <MudItem xs="12" md="6">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Capacity & Admission</MudText>
                <MudNumericField T="int" Label="Max Active Task Runtimes" Variant="Variant.Outlined" @bind-Value="_settings.MaxActiveTaskRuntimes" Min="1" Max="512" Class="mb-2" />
                <MudNumericField T="int" Label="Default Task Parallel Runs" Variant="Variant.Outlined" @bind-Value="_settings.DefaultTaskParallelRuns" Min="1" Max="64" Class="mb-2" />
                <MudNumericField T="int" Label="Task Runtime Inactive Timeout (minutes)" Variant="Variant.Outlined" @bind-Value="_settings.TaskRuntimeInactiveTimeoutMinutes" Min="1" Max="1440" Class="mb-2" />
                <MudNumericField T="int" Label="Max Queue Depth" Variant="Variant.Outlined" @bind-Value="_settings.MaxQueueDepth" Min="1" Max="50000" Class="mb-2" />
                <MudNumericField T="int" Label="Queue Wait Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.QueueWaitTimeoutSeconds" Min="5" Max="7200" />
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Image Lifecycle</MudText>
                <MudSelect T="WorkerImagePolicy" Label="Task Runtime Image Policy" Variant="Variant.Outlined" @bind-Value="_settings.WorkerImagePolicy" Class="mb-2">
                    @foreach (var policy in Enum.GetValues<WorkerImagePolicy>())
                    {
                        <MudSelectItem T="WorkerImagePolicy" Value="@policy">@policy</MudSelectItem>
                    }
                </MudSelect>
                <MudTextField T="string" Label="Image Registry (optional)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerImageRegistry" Class="mb-2" />
                <MudTextField T="string" Label="Canary Image (optional)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerCanaryImage" Class="mb-2" />
                <MudTextField T="string" Label="Dockerfile Path (optional)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerDockerfilePath" Class="mb-2" />
                <MudTextField T="string" Label="Build Context Path (optional)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerDockerBuildContextPath" Class="mb-2" />
                <MudNumericField T="int" Label="Max Concurrent Pulls" Variant="Variant.Outlined" @bind-Value="_settings.MaxConcurrentPulls" Min="1" Max="16" Class="mb-2" />
                <MudNumericField T="int" Label="Max Concurrent Builds" Variant="Variant.Outlined" @bind-Value="_settings.MaxConcurrentBuilds" Min="1" Max="8" Class="mb-2" />
                <MudNumericField T="int" Label="Pull Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.ImagePullTimeoutSeconds" Min="10" Max="3600" Class="mb-2" />
                <MudNumericField T="int" Label="Build Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.ImageBuildTimeoutSeconds" Min="30" Max="7200" Class="mb-2" />
                <MudNumericField T="int" Label="Image Failure Cooldown (minutes)" Variant="Variant.Outlined" @bind-Value="_settings.ImageFailureCooldownMinutes" Min="1" Max="240" Class="mb-2" />
                <MudNumericField T="int" Label="Canary Percent" Variant="Variant.Outlined" @bind-Value="_settings.CanaryPercent" Min="0" Max="100" />
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Reliability Budgets</MudText>
                <MudNumericField T="int" Label="Max Start Attempts / 10m" Variant="Variant.Outlined" @bind-Value="_settings.MaxWorkerStartAttemptsPer10Min" Min="1" Max="1000" Class="mb-2" />
                <MudNumericField T="int" Label="Max Failed Starts / 10m" Variant="Variant.Outlined" @bind-Value="_settings.MaxFailedStartsPer10Min" Min="1" Max="1000" Class="mb-2" />
                <MudNumericField T="int" Label="Cooldown Minutes" Variant="Variant.Outlined" @bind-Value="_settings.CooldownMinutes" Min="1" Max="240" Class="mb-2" />
                <MudNumericField T="int" Label="Container Start Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.ContainerStartTimeoutSeconds" Min="5" Max="600" Class="mb-2" />
                <MudNumericField T="int" Label="Container Stop Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.ContainerStopTimeoutSeconds" Min="1" Max="600" Class="mb-2" />
                <MudNumericField T="int" Label="Health Probe Interval (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.HealthProbeIntervalSeconds" Min="1" Max="300" Class="mb-2" />
                <MudNumericField T="int" Label="Container Restart Limit" Variant="Variant.Outlined" @bind-Value="_settings.ContainerRestartLimit" Min="0" Max="100" Class="mb-2" />
                <MudSelect T="ContainerUnhealthyAction" Label="Unhealthy Action" Variant="Variant.Outlined" @bind-Value="_settings.ContainerUnhealthyAction" Class="mb-2">
                    @foreach (var action in Enum.GetValues<ContainerUnhealthyAction>())
                    {
                        <MudSelectItem T="ContainerUnhealthyAction" Value="@action">@action</MudSelectItem>
                    }
                </MudSelect>
                <MudNumericField T="int" Label="Error Burst Threshold" Variant="Variant.Outlined" @bind-Value="_settings.OrchestratorErrorBurstThreshold" Min="1" Max="10000" Class="mb-2" />
                <MudNumericField T="int" Label="Error Cooldown Minutes" Variant="Variant.Outlined" @bind-Value="_settings.OrchestratorErrorCoolDownMinutes" Min="1" Max="240" />
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Lifecycle & Guardrails</MudText>
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.EnableDraining" Label="Enable Draining" Class="mb-1" />
                <MudNumericField T="int" Label="Drain Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.DrainTimeoutSeconds" Min="5" Max="7200" Class="mb-2" />
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.EnableAutoRecycle" Label="Enable Auto Recycle" Class="mb-1" />
                <MudNumericField T="int" Label="Recycle After Runs" Variant="Variant.Outlined" @bind-Value="_settings.RecycleAfterRuns" Min="1" Max="100000" Class="mb-2" />
                <MudNumericField T="int" Label="Recycle After Uptime (minutes)" Variant="Variant.Outlined" @bind-Value="_settings.RecycleAfterUptimeMinutes" Min="10" Max="10080" Class="mb-2" />
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.EnableContainerAutoCleanup" Label="Enable Container Auto Cleanup" Class="mb-2" />
                <MudTextField T="string" Label="Worker CPU Limit (cores, optional)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerCpuLimit" Class="mb-2" />
                <MudNumericField T="int" Label="Worker Memory Limit (MB, 0=unlimited)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerMemoryLimitMb" Min="0" Max="1048576" Class="mb-2" />
                <MudNumericField T="int" Label="Worker PIDs Limit (0=unlimited)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerPidsLimit" Min="0" Max="100000" Class="mb-2" />
                <MudNumericField T="int" Label="Worker FD Limit (0=unlimited)" Variant="Variant.Outlined" @bind-Value="_settings.WorkerFileDescriptorLimit" Min="0" Max="1048576" Class="mb-2" />
                <MudNumericField T="int" Label="Run Hard Timeout (seconds)" Variant="Variant.Outlined" @bind-Value="_settings.RunHardTimeoutSeconds" Min="30" Max="86400" Class="mb-2" />
                <MudNumericField T="int" Label="Max Run Log Size (MB)" Variant="Variant.Outlined" @bind-Value="_settings.MaxRunLogMb" Min="1" Max="10240" />
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Data Retention & Cleanup</MudText>
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.EnableTaskAutoCleanup" Label="Enable Task Auto Cleanup" Class="mb-2" />
                <MudNumericField T="int" Label="Cleanup Interval (minutes)" Variant="Variant.Outlined" @bind-Value="_settings.CleanupIntervalMinutes" Min="1" Max="1440" Class="mb-2" />
                <MudNumericField T="int" Label="Task Retention (days)" Variant="Variant.Outlined" @bind-Value="_settings.TaskRetentionDays" Min="1" Max="3650" Class="mb-2" />
                <MudNumericField T="int" Label="Protected Window (days)" Variant="Variant.Outlined" @bind-Value="_settings.CleanupProtectedDays" Min="0" Max="3650" Class="mb-2" />
                <MudNumericField T="int" Label="Disabled Task Inactivity (days, 0 disables)" Variant="Variant.Outlined" @bind-Value="_settings.DisabledTaskInactivityDays" Min="0" Max="3650" Class="mb-2" />
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.CleanupExcludeWorkflowReferencedTasks" Label="Exclude Workflow-Referenced Tasks" Class="mb-2" />
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.CleanupExcludeTasksWithOpenFindings" Label="Exclude Tasks With Open Findings" Class="mb-2" />
                <MudNumericField T="int" Label="DB Size Soft Limit (GB)" Variant="Variant.Outlined" @bind-Value="_settings.DbSizeSoftLimitGb" Min="1" Max="16384" Class="mb-2" />
                <MudNumericField T="int" Label="DB Size Target (GB)" Variant="Variant.Outlined" @bind-Value="_settings.DbSizeTargetGb" Min="1" Max="16384" Class="mb-2" />
                <MudNumericField T="int" Label="Max Tasks Deleted Per Tick" Variant="Variant.Outlined" @bind-Value="_settings.MaxTasksDeletedPerTick" Min="1" Max="2000" Class="mb-2" />
                <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.EnableVacuumAfterPressureCleanup" Label="Enable VACUUM After Pressure Cleanup" Class="mb-2" />
                <MudNumericField T="int" Label="VACUUM Minimum Deleted Rows" Variant="Variant.Outlined" @bind-Value="_settings.VacuumMinDeletedRows" Min="1" Max="50000000" />
            </MudPaper>
        </MudItem>

        <MudItem xs="12">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudText Typo="Typo.h6" Class="mb-3">Operator Action Center</MudText>
                <MudStack Row="true" Spacing="2" Class="mb-3">
                    <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="PauseScaleOutAsync">Pause Scale-Out</MudButton>
                    <MudButton Variant="Variant.Outlined" Color="Color.Success" OnClick="ResumeScaleOutAsync">Resume Scale-Out</MudButton>
                    <MudButton Variant="Variant.Outlined" OnClick="ClearCooldownAsync">Clear Cooldown</MudButton>
                    <MudButton Variant="Variant.Outlined" OnClick="EnsureImageAsync">Ensure Runtime Image</MudButton>
                    <MudButton Variant="Variant.Outlined" OnClick="RecyclePoolAsync">Recycle Task Runtime Pool</MudButton>
                    <MudButton Variant="Variant.Outlined" OnClick="RunReconciliationAsync">Run Reconciliation</MudButton>
                </MudStack>

                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center" Class="mb-3">
                    <MudTextField T="string" Label="Task Runtime ID" Variant="Variant.Outlined" @bind-Value="_workerActionId" Immediate="true" />
                    <MudButton Variant="Variant.Outlined" Color="Color.Warning" Disabled="@string.IsNullOrWhiteSpace(_workerActionId)" OnClick="DrainWorkerAsync">Drain Runtime</MudButton>
                    <MudButton Variant="Variant.Outlined" Disabled="@string.IsNullOrWhiteSpace(_workerActionId)" OnClick="RecycleTaskRuntimeAsync">Recycle Runtime</MudButton>
                </MudStack>

                @if (_health is not null)
                {
                    <MudText Typo="Typo.subtitle2" Class="mb-2">Current Health Snapshot</MudText>
                    <MudGrid>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="Color.Info">Running: @_health.RunningTaskRuntimes</MudChip></MudItem>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="Color.Success">Ready: @_health.ReadyTaskRuntimes</MudChip></MudItem>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="Color.Warning">Busy: @_health.BusyTaskRuntimes</MudChip></MudItem>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="Color.Default">Draining: @_health.DrainingTaskRuntimes</MudChip></MudItem>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="@(_health.ScaleOutPaused ? Color.Warning : Color.Success)">Paused: @_health.ScaleOutPaused</MudChip></MudItem>
                        <MudItem xs="6" md="2"><MudChip T="string" Color="Color.Default">Fails/10m: @_health.FailedStartsInWindow</MudChip></MudItem>
                    </MudGrid>
                }

                <MudDivider Class="my-3" />
                <MudText Typo="Typo.subtitle2" Class="mb-2">Image Resolution Activity</MudText>
                @if (_imageBackgroundWork.Count == 0)
                {
                    <MudText Typo="Typo.body2">No image resolution work has been queued.</MudText>
                }
                else
                {
                    <MudStack Spacing="1">
                        @foreach (var snapshot in _imageBackgroundWork)
                        {
                            <MudPaper Class="pa-2" Elevation="0">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                    <MudChip T="string" Size="Size.Small" Color="@MapBackgroundWorkColor(snapshot.State)">
                                        @MapBackgroundWorkState(snapshot.State)
                                    </MudChip>
                                    <MudText Typo="Typo.caption">@snapshot.UpdatedAt?.LocalDateTime.ToString("g")</MudText>
                                </MudStack>
                                <MudText Typo="Typo.caption">@snapshot.Message</MudText>
                                @if (snapshot.PercentComplete.HasValue)
                                {
                                    <MudProgressLinear Value="@snapshot.PercentComplete.Value" Class="mt-1" />
                                }
                                else if (snapshot.State == BackgroundWorkState.Running)
                                {
                                    <MudProgressLinear Indeterminate="true" Class="mt-1" />
                                }
                            </MudPaper>
                        }
                    </MudStack>
                }
            </MudPaper>
        </MudItem>
    </MudGrid>

    <MudStack Row="true" Class="mt-2">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save"
                   OnClick="SaveAsync" Disabled="_saving">
            @if (_saving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
            }
            Save Task Runtime Settings
        </MudButton>
    </MudStack>
}

@code {
    private bool _loading = true;
    private bool _saving;
    private SystemSettingsDocument _document = new();
    private OrchestratorConfig _settings = new();
    private OrchestratorHealthSnapshot? _health;
    private string _workerActionId = string.Empty;
    private IReadOnlyList<BackgroundWorkSnapshot> _imageBackgroundWork = [];
    private Action<BackgroundWorkSnapshot>? _backgroundWorkHandler;

    protected override async Task OnInitializedAsync()
    {
        _backgroundWorkHandler = OnBackgroundWorkUpdated;
        BackgroundWorkCoordinator.Updated += _backgroundWorkHandler;
        await RefreshAllAsync();
    }

    private async Task RefreshAllAsync()
    {
        _loading = true;
        try
        {
            _document = await Store.GetSettingsAsync(CancellationToken.None);
            _settings = CloneOrchestratorSettings(_document.Orchestrator);
            _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
            RefreshImageBackgroundWork();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load orchestrator settings: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task SaveAsync()
    {
        _saving = true;
        try
        {
            ValidateSettings(_settings);
            _document.Orchestrator = CloneOrchestratorSettings(_settings);
            _document.UpdatedAtUtc = DateTime.UtcNow;

            await Store.UpdateSettingsAsync(_document, CancellationToken.None);
            RuntimeSettingsProvider.Invalidate();

            _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
            Snackbar.Add("Orchestrator settings saved", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save orchestrator settings: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private async Task PauseScaleOutAsync()
    {
        await WorkerLifecycle.SetScaleOutPausedAsync(true, CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add("Scale-out paused", Severity.Info);
    }

    private async Task ResumeScaleOutAsync()
    {
        await WorkerLifecycle.SetScaleOutPausedAsync(false, CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add("Scale-out resumed", Severity.Success);
    }

    private async Task ClearCooldownAsync()
    {
        await WorkerLifecycle.ClearScaleOutCooldownAsync(CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add("Scale-out cooldown cleared", Severity.Success);
    }

    private async Task EnsureImageAsync()
    {
        const string operationKey = "manual:worker-image-resolution";
        var workId = BackgroundWorkCoordinator.Enqueue(
            BackgroundWorkKind.WorkerImageResolution,
            operationKey,
            async (cancellationToken, progress) =>
            {
                await WorkerLifecycle.EnsureTaskRuntimeImageAvailableAsync(cancellationToken, progress);
            },
            dedupeByOperationKey: true,
            isCritical: false);

        RefreshImageBackgroundWork();
        Snackbar.Add($"Worker image ensure queued ({workId[..8]})", Severity.Info);
    }

    private async Task RecyclePoolAsync()
    {
        await WorkerLifecycle.RecycleTaskRuntimePoolAsync(CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add("Worker pool marked for recycle", Severity.Info);
    }

    private async Task RunReconciliationAsync()
    {
        await WorkerLifecycle.RunReconciliationAsync(CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add("Reconciliation executed", Severity.Success);
    }

    private async Task DrainWorkerAsync()
    {
        if (string.IsNullOrWhiteSpace(_workerActionId))
        {
            return;
        }

        await WorkerLifecycle.SetTaskRuntimeDrainingAsync(_workerActionId.Trim(), true, CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add($"Worker {_workerActionId.Trim()} marked as draining", Severity.Info);
    }

    private async Task RecycleTaskRuntimeAsync()
    {
        if (string.IsNullOrWhiteSpace(_workerActionId))
        {
            return;
        }

        await WorkerLifecycle.RecycleTaskRuntimeAsync(_workerActionId.Trim(), CancellationToken.None);
        _health = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        Snackbar.Add($"Worker {_workerActionId.Trim()} recycle requested", Severity.Info);
    }

    private void OnBackgroundWorkUpdated(BackgroundWorkSnapshot snapshot)
    {
        if (snapshot.Kind != BackgroundWorkKind.WorkerImageResolution)
        {
            return;
        }

        _ = InvokeAsync(() =>
        {
            RefreshImageBackgroundWork();
            StateHasChanged();
        });
    }

    private void RefreshImageBackgroundWork()
    {
        _imageBackgroundWork = BackgroundWorkCoordinator.Snapshot()
            .Where(snapshot => snapshot.Kind == BackgroundWorkKind.WorkerImageResolution)
            .OrderByDescending(snapshot => snapshot.UpdatedAt ?? snapshot.StartedAt ?? DateTimeOffset.MinValue)
            .Take(8)
            .ToArray();
    }

    private static string MapBackgroundWorkState(BackgroundWorkState state)
    {
        return state switch
        {
            BackgroundWorkState.Pending => "Pending",
            BackgroundWorkState.Running => "Running",
            BackgroundWorkState.Succeeded => "Succeeded",
            BackgroundWorkState.Failed => "Failed",
            BackgroundWorkState.Cancelled => "Cancelled",
            _ => state.ToString(),
        };
    }

    private static Color MapBackgroundWorkColor(BackgroundWorkState state)
    {
        return state switch
        {
            BackgroundWorkState.Pending => Color.Info,
            BackgroundWorkState.Running => Color.Primary,
            BackgroundWorkState.Succeeded => Color.Success,
            BackgroundWorkState.Failed => Color.Error,
            BackgroundWorkState.Cancelled => Color.Warning,
            _ => Color.Default,
        };
    }

    private static OrchestratorConfig CloneOrchestratorSettings(OrchestratorConfig source)
    {
        return new OrchestratorConfig
        {
            MaxActiveTaskRuntimes = source.MaxActiveTaskRuntimes,
            DefaultTaskParallelRuns = source.DefaultTaskParallelRuns,
            TaskRuntimeInactiveTimeoutMinutes = source.TaskRuntimeInactiveTimeoutMinutes,
            MinWorkers = source.MinWorkers,
            MaxWorkers = source.MaxWorkers,
            MaxProcessesPerWorker = source.MaxProcessesPerWorker,
            ReserveWorkers = source.ReserveWorkers,
            MaxQueueDepth = source.MaxQueueDepth,
            QueueWaitTimeoutSeconds = source.QueueWaitTimeoutSeconds,
            WorkerImagePolicy = source.WorkerImagePolicy,
            WorkerImageRegistry = source.WorkerImageRegistry,
            WorkerCanaryImage = source.WorkerCanaryImage,
            WorkerDockerBuildContextPath = source.WorkerDockerBuildContextPath,
            WorkerDockerfilePath = source.WorkerDockerfilePath,
            MaxConcurrentPulls = source.MaxConcurrentPulls,
            MaxConcurrentBuilds = source.MaxConcurrentBuilds,
            ImagePullTimeoutSeconds = source.ImagePullTimeoutSeconds,
            ImageBuildTimeoutSeconds = source.ImageBuildTimeoutSeconds,
            WorkerImageCacheTtlMinutes = source.WorkerImageCacheTtlMinutes,
            ImageFailureCooldownMinutes = source.ImageFailureCooldownMinutes,
            CanaryPercent = source.CanaryPercent,
            MaxWorkerStartAttemptsPer10Min = source.MaxWorkerStartAttemptsPer10Min,
            MaxFailedStartsPer10Min = source.MaxFailedStartsPer10Min,
            CooldownMinutes = source.CooldownMinutes,
            ContainerStartTimeoutSeconds = source.ContainerStartTimeoutSeconds,
            ContainerStopTimeoutSeconds = source.ContainerStopTimeoutSeconds,
            HealthProbeIntervalSeconds = source.HealthProbeIntervalSeconds,
            ContainerRestartLimit = source.ContainerRestartLimit,
            ContainerUnhealthyAction = source.ContainerUnhealthyAction,
            OrchestratorErrorBurstThreshold = source.OrchestratorErrorBurstThreshold,
            OrchestratorErrorCoolDownMinutes = source.OrchestratorErrorCoolDownMinutes,
            EnableDraining = source.EnableDraining,
            DrainTimeoutSeconds = source.DrainTimeoutSeconds,
            EnableAutoRecycle = source.EnableAutoRecycle,
            RecycleAfterRuns = source.RecycleAfterRuns,
            RecycleAfterUptimeMinutes = source.RecycleAfterUptimeMinutes,
            EnableContainerAutoCleanup = source.EnableContainerAutoCleanup,
            WorkerCpuLimit = source.WorkerCpuLimit,
            WorkerMemoryLimitMb = source.WorkerMemoryLimitMb,
            WorkerPidsLimit = source.WorkerPidsLimit,
            WorkerFileDescriptorLimit = source.WorkerFileDescriptorLimit,
            RunHardTimeoutSeconds = source.RunHardTimeoutSeconds,
            MaxRunLogMb = source.MaxRunLogMb,
            EnableTaskAutoCleanup = source.EnableTaskAutoCleanup,
            CleanupIntervalMinutes = source.CleanupIntervalMinutes,
            TaskRetentionDays = source.TaskRetentionDays,
            CleanupProtectedDays = source.CleanupProtectedDays,
            DisabledTaskInactivityDays = source.DisabledTaskInactivityDays,
            CleanupExcludeWorkflowReferencedTasks = source.CleanupExcludeWorkflowReferencedTasks,
            CleanupExcludeTasksWithOpenFindings = source.CleanupExcludeTasksWithOpenFindings,
            DbSizeSoftLimitGb = source.DbSizeSoftLimitGb,
            DbSizeTargetGb = source.DbSizeTargetGb,
            MaxTasksDeletedPerTick = source.MaxTasksDeletedPerTick,
            EnableVacuumAfterPressureCleanup = source.EnableVacuumAfterPressureCleanup,
            VacuumMinDeletedRows = source.VacuumMinDeletedRows,
        };
    }

    private static void ValidateSettings(OrchestratorConfig settings)
    {
        if (settings.MaxActiveTaskRuntimes < 1)
        {
            throw new InvalidOperationException("MaxActiveTaskRuntimes must be at least 1");
        }

        if (settings.DefaultTaskParallelRuns < 1)
        {
            throw new InvalidOperationException("DefaultTaskParallelRuns must be at least 1");
        }

        if (settings.TaskRuntimeInactiveTimeoutMinutes < 1 || settings.TaskRuntimeInactiveTimeoutMinutes > 1440)
        {
            throw new InvalidOperationException("TaskRuntimeInactiveTimeoutMinutes must be between 1 and 1440");
        }

        if (settings.MaxWorkers < 1)
        {
            throw new InvalidOperationException("MaxWorkers must be at least 1");
        }

        if (settings.MinWorkers < 1)
        {
            throw new InvalidOperationException("MinWorkers must be at least 1");
        }

        if (settings.MinWorkers > settings.MaxWorkers)
        {
            throw new InvalidOperationException("MinWorkers cannot exceed MaxWorkers");
        }

        if (settings.MaxProcessesPerWorker < 1)
        {
            throw new InvalidOperationException("MaxProcessesPerWorker must be at least 1");
        }

        if (settings.MaxConcurrentPulls < 1 || settings.MaxConcurrentBuilds < 1)
        {
            throw new InvalidOperationException("Concurrent pull/build limits must be at least 1");
        }

        if (settings.MaxQueueDepth < 1)
        {
            throw new InvalidOperationException("MaxQueueDepth must be at least 1");
        }

        if (settings.CleanupIntervalMinutes < 1 || settings.CleanupIntervalMinutes > 1440)
        {
            throw new InvalidOperationException("CleanupIntervalMinutes must be between 1 and 1440");
        }

        if (settings.TaskRetentionDays < 1)
        {
            throw new InvalidOperationException("TaskRetentionDays must be at least 1");
        }

        if (settings.DisabledTaskInactivityDays < 0 || settings.DisabledTaskInactivityDays > 3650)
        {
            throw new InvalidOperationException("DisabledTaskInactivityDays must be between 0 and 3650");
        }

        if (settings.CleanupProtectedDays < 0)
        {
            throw new InvalidOperationException("CleanupProtectedDays cannot be negative");
        }

        if (settings.CleanupProtectedDays > settings.TaskRetentionDays)
        {
            throw new InvalidOperationException("CleanupProtectedDays cannot exceed TaskRetentionDays");
        }

        if (settings.DbSizeSoftLimitGb < 1)
        {
            throw new InvalidOperationException("DbSizeSoftLimitGb must be at least 1");
        }

        if (settings.DbSizeTargetGb < 1 || settings.DbSizeTargetGb >= settings.DbSizeSoftLimitGb)
        {
            throw new InvalidOperationException("DbSizeTargetGb must be at least 1 and lower than DbSizeSoftLimitGb");
        }

        if (settings.MaxTasksDeletedPerTick < 1 || settings.MaxTasksDeletedPerTick > 2000)
        {
            throw new InvalidOperationException("MaxTasksDeletedPerTick must be between 1 and 2000");
        }

        if (settings.VacuumMinDeletedRows < 1)
        {
            throw new InvalidOperationException("VacuumMinDeletedRows must be at least 1");
        }
    }

    public void Dispose()
    {
        if (_backgroundWorkHandler is not null)
        {
            BackgroundWorkCoordinator.Updated -= _backgroundWorkHandler;
            _backgroundWorkHandler = null;
        }
    }
}

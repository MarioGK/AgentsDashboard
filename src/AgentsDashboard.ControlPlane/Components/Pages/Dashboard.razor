@page "/overview"
@rendermode InteractiveServer
@inject Data.IOrchestratorStore Store
@inject Services.IGlobalSelectionService SelectionService
@inject Services.ITaskRuntimeLifecycleManager WorkerLifecycle
@inject Services.IBackgroundWorkCoordinator BackgroundWorkCoordinator
@inject Microsoft.Extensions.Options.IOptions<Configuration.OrchestratorOptions> OrchestratorOptions
@inject NavigationManager NavigationManager
@implements IDisposable
@using AgentsDashboard.ControlPlane.Services
@using System.Diagnostics

<PageTitle>Overview</PageTitle>

@if (_loading)
{
    <MudStack Class="overview-loading" AlignItems="AlignItems.Center" Justify="Justify.Center">
        <MudProgressCircular Indeterminate="true" Size="Size.Large" />
    </MudStack>
}
else
{
    <MudStack Spacing="4" Class="overview-shell">
        <MudPaper Class="overview-hero" Elevation="0">
            <MudText Typo="Typo.h4">Command Center</MudText>
            <MudText Typo="Typo.body2" Class="overview-hero-subtitle">Launch into settings pages quickly and keep operational context in one place.</MudText>

            <MudTextField T="string"
                          @bind-Value="_commandText"
                          Placeholder="Type a command like 'runs', 'findings', 'workflows stages', 'runtimes'"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="true"
                          OnKeyDown="OnCommandKeyDown" />

            <MudStack Row="true" Class="mt-3" Spacing="1">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="OpenCommandTarget">Open</MudButton>
                <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="ClearCommand">Clear</MudButton>
                <MudButton Variant="Variant.Text" Color="Color.Info" OnClick="LoadDataAsync" Disabled="_loading">Refresh metrics</MudButton>
            </MudStack>
        </MudPaper>

        <MudGrid>
            <MudItem xs="12" md="4">
                <MudPaper Class="overview-stat-card" Elevation="0">
                    <MudText Typo="Typo.caption">Repositories</MudText>
                    <MudText Typo="Typo.h4">@_repositories.Count</MudText>
                </MudPaper>
            </MudItem>
            <MudItem xs="12" md="4">
                <MudPaper Class="overview-stat-card" Elevation="0">
                    <MudText Typo="Typo.caption">Open Findings</MudText>
                    <MudText Typo="Typo.h4">@_openFindings</MudText>
                </MudPaper>
            </MudItem>
            <MudItem xs="12" md="4">
                <MudPaper Class="overview-stat-card" Elevation="0">
                    <MudText Typo="Typo.caption">Active Runs</MudText>
                    <MudText Typo="Typo.h4">@_activeRuns</MudText>
                </MudPaper>
            </MudItem>
        </MudGrid>

        <MudGrid>
            <MudItem xs="12">
                <MudPaper Class="overview-card" Elevation="0">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
                        <MudText Typo="Typo.h6">Startup Background Tasks</MudText>
                        <MudText Typo="Typo.caption">Queued, running, and recent terminal background work</MudText>
                    </MudStack>

                    @if (_startupBackgroundWork.Count == 0)
                    {
                        <MudText Typo="Typo.body2">No startup background tasks are currently tracked.</MudText>
                    }
                    else
                    {
                        <MudStack Spacing="1">
                            @foreach (var snapshot in _startupBackgroundWork)
                            {
                                <MudPaper Class="overview-stat-card" Elevation="0">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                        <MudText Typo="Typo.caption">@snapshot.Kind</MudText>
                                        <MudChip T="string" Size="Size.Small" Color="@MapBackgroundWorkColor(snapshot.State)">
                                            @snapshot.State
                                        </MudChip>
                                    </MudStack>
                                    <MudText Typo="Typo.caption">@snapshot.Message</MudText>
                                    <MudText Typo="Typo.caption">@snapshot.UpdatedAt?.LocalDateTime.ToString("g")</MudText>
                                    @if (snapshot.PercentComplete.HasValue)
                                    {
                                        <MudProgressLinear Value="@snapshot.PercentComplete.Value" Class="mt-1" />
                                    }
                                    else if (snapshot.State is BackgroundWorkState.Pending or BackgroundWorkState.Running)
                                    {
                                        <MudProgressLinear Indeterminate="true" Class="mt-1" />
                                    }
                                </MudPaper>
                            }
                        </MudStack>
                    }
                </MudPaper>
            </MudItem>
        </MudGrid>

        <MudGrid>
            <MudItem xs="12">
                <MudPaper Class="overview-card" Elevation="0">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
                        <MudText Typo="Typo.h6">Current Server & Worker Metrics</MudText>
                        <MudText Typo="Typo.caption">@GetLastUpdatedText()</MudText>
                    </MudStack>
                    @if (!string.IsNullOrWhiteSpace(_workerRuntimeMessage))
                    {
                        <MudAlert Severity="Severity.Warning" Variant="Variant.Text" Dense="true" Class="mb-2">@_workerRuntimeMessage</MudAlert>
                    }
                    @if (!string.IsNullOrWhiteSpace(_orchestratorHealthError))
                    {
                        <MudAlert Severity="Severity.Warning" Variant="Variant.Text" Dense="true" Class="mb-2">@_orchestratorHealthError</MudAlert>
                    }

                    <MudGrid>
                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Control Plane CPU</MudText>
                                <MudText Typo="Typo.h4">@GetControlPlaneCpuText()</MudText>
                                <MudText Typo="Typo.caption">Uptime: @GetControlPlaneUptimeText()</MudText>
                                <MudText Typo="Typo.caption">Threads: @_controlPlaneThreads · Handles: @GetControlPlaneHandleText()</MudText>
                                <MudText Typo="Typo.caption">Private: @FormatBytes(_controlPlanePrivateBytes) · GC Heap: @FormatBytes(_controlPlaneGcBytes) · PID: @_controlPlaneProcessId</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_controlPlaneCpuGaugeSeries"
                                                         Name="Control Plane"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Worker CPU</MudText>
                                <MudText Typo="Typo.h4">@GetWorkerCpuText()</MudText>
                                <MudText Typo="Typo.caption">Peak: @GetWorkerCpuPeakText() · Running: @_workerContainersRunning / @_workerContainersTotal</MudText>
                                <MudText Typo="Typo.caption">Memory: @GetWorkerMemoryText() · Peak: @GetWorkerMemoryPeakText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_workerCpuGaugeSeries"
                                                         Name="Workers"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Host Load / Memory</MudText>
                                <MudText Typo="Typo.h4">@GetHostLoadPercentText()</MudText>
                                <MudText Typo="Typo.caption">Used: @GetHostMemoryUsedText() / @GetHostMemoryTotalText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_hostMemoryGaugeSeries"
                                                         Name="Host Memory"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Worker Capacity</MudText>
                                <MudText Typo="Typo.h4">@GetWorkerCapacityPercentText()</MudText>
                                <MudText Typo="Typo.caption">Ready: @_workerReadyCount · Busy: @_workerBusyCount · Draining: @_workerDrainingCount · Offline: @_workerOfflineCount</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_workerCapacityGaugeSeries"
                                                         Name="Workers"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Host Disk Utilization</MudText>
                                <MudText Typo="Typo.h4">@GetHostDiskUsageText()</MudText>
                                <MudText Typo="Typo.caption">Used: @FormatBytes(_hostDiskUsedBytes) / @FormatBytes(_hostDiskTotalBytes)</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_hostDiskUsageGaugeSeries"
                                                         Name="Host Disk"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" sm="6" lg="3">
                            <MudPaper Class="overview-stat-card" Elevation="0">
                                <MudText Typo="Typo.caption">Host Load Index</MudText>
                                <MudText Typo="Typo.h4">@GetHostLoadPercentText()</MudText>
                                <MudText Typo="Typo.caption">1m / 5m / 15m: @GetHostLoadAverageText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="168">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_hostLoadGaugeSeries"
                                                         Name="Host Load"
                                                         SeriesType="SeriesType.RadialBar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="8">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Live Throughput Trends</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="MetricPoint" Height="340">
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_controlPlaneCpuTrend"
                                                         Name="Control Plane CPU"
                                                         SeriesType="SeriesType.Area"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_workerCpuTrend"
                                                         Name="Worker CPU"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_hostLoadTrend"
                                                         Name="Host Load"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="4">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Orchestrator Snapshot</MudText>
                                <MudText Typo="Typo.caption">Scale-out paused: @(_orchestratorHealth?.ScaleOutPaused ?? false)</MudText>
                                <MudText Typo="Typo.caption">Start failures (10m): @(_orchestratorHealth?.FailedStartsInWindow ?? 0)</MudText>
                                <MudText Typo="Typo.caption">Running workers: @_orchestratorHealth?.RunningTaskRuntimes ?? 0</MudText>
                                <MudText Typo="Typo.caption">Queued starts in window: @(_orchestratorHealth?.StartAttemptsInWindow ?? 0)</MudText>
                                <MudText Typo="Typo.caption">@(_orchestratorHealth?.ScaleOutCooldownUntilUtc is null ? "No scale-out cooldown" : $"Cooldown until {_orchestratorHealth?.ScaleOutCooldownUntilUtc.Value.ToLocalTime():g}")</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="230">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_workerStateSeries"
                                                         Name="Workers"
                                                         SeriesType="SeriesType.Donut"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="4">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Worker State Distribution</MudText>
                                <MudText Typo="Typo.caption">Breakout of worker lifecycle states for quick tuning.</MudText>
                                <MudText Typo="Typo.caption">Ready: @_workerReadyCount · Busy: @_workerBusyCount · Offline: @_workerOfflineCount · Draining: @_workerDrainingCount</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="230">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_workerStateSeries"
                                                         Name="Worker State"
                                                         SeriesType="SeriesType.Bar"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="4">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Runtime Cold-Start & Inactivity</MudText>
                                <MudText Typo="Typo.caption">Tune timeout and parallel slots from observed lifecycle behavior.</MudText>
                                <MudText Typo="Typo.caption">Avg cold-start: @FormatDurationSeconds(_taskRuntimeTelemetry.AverageColdStartSeconds) · Last: @FormatDurationSeconds(_taskRuntimeTelemetry.LastColdStartSeconds)</MudText>
                                <MudText Typo="Typo.caption">Cold-start samples: @_taskRuntimeTelemetry.TotalColdStarts</MudText>
                                <MudText Typo="Typo.caption">Avg inactive window: @FormatDurationSeconds(_taskRuntimeTelemetry.AverageInactiveSeconds) · Last: @FormatDurationSeconds(_taskRuntimeTelemetry.LastInactiveSeconds)</MudText>
                                <MudText Typo="Typo.caption">Inactive transitions: @_taskRuntimeTelemetry.TotalInactiveTransitions · Inactive runtimes: @_taskRuntimeTelemetry.InactiveRuntimes</MudText>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="4">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Run Outcome Distribution</MudText>
                                <MudText Typo="Typo.caption">@GetRunDistributionText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="GaugePoint" Height="230">
                                        <ApexPointSeries TItem="GaugePoint"
                                                         Items="@_runStateSeries"
                                                         Name="Runs"
                                                         SeriesType="SeriesType.Donut"
                                                         XValue="point => point.Label"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="8">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Run Throughput Trends</MudText>
                                <MudText Typo="Typo.caption">Queued · Running · Succeeded · Failed over time</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="MetricPoint" Height="300">
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_runQueuedTrend"
                                                         Name="Queued"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_runRunningTrend"
                                                         Name="Running"
                                                         SeriesType="SeriesType.Area"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_runSucceededTrend"
                                                         Name="Succeeded"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_runFailedTrend"
                                                         Name="Failed"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="6">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Memory Pressure</MudText>
                                <MudText Typo="Typo.caption">Control plane: @FormatBytes(_controlPlaneWorkingSetBytes) · Host: @GetHostMemoryUsedText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="MetricPoint" Height="300">
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_controlPlaneWorkingSetTrend"
                                                         Name="Control Plane GB"
                                                         SeriesType="SeriesType.Area"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_hostMemoryUsedTrend"
                                                         Name="Host Memory GB"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="6">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">Control Plane Handles & Resources</MudText>
                                <MudText Typo="Typo.caption">Threads: @_controlPlaneThreads · Handles: @GetControlPlaneHandleText() · Open FDs: @GetOpenFileDescriptorText()</MudText>
                                <MudText Typo="Typo.caption">PID: @_controlPlaneProcessId</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="MetricPoint" Height="300">
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_controlPlaneThreadTrend"
                                                         Name="Threads"
                                                         SeriesType="SeriesType.Area"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_controlPlaneHandleTrend"
                                                         Name="Handles"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_openFileDescriptorTrend"
                                                         Name="Open FDs"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>

                        <MudItem xs="12" lg="6">
                            <MudPaper Class="overview-card" Elevation="0">
                                <MudText Typo="Typo.h6" Class="mb-2">SQLite + Disk Trends</MudText>
                                <MudText Typo="Typo.caption">SQLite: @GetDatabaseSizeText() @(_databasePath)</MudText>
                                <MudText Typo="Typo.caption">Host disk usage: @GetHostDiskUsageText()</MudText>
                                <div class="overview-chart-surface">
                                    <ApexChart TItem="MetricPoint" Height="300">
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_databaseSizeTrend"
                                                         Name="SQLite GB"
                                                         SeriesType="SeriesType.Area"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                        <ApexPointSeries TItem="MetricPoint"
                                                         Items="@_hostDiskUsedTrend"
                                                         Name="Host Disk Used GB"
                                                         SeriesType="SeriesType.Line"
                                                         XValue="point => point.Time"
                                                         YValue="point => point.Value" />
                                    </ApexChart>
                                </div>
                            </MudPaper>
                        </MudItem>
                    </MudGrid>
                </MudPaper>
            </MudItem>
        </MudGrid>

        <MudGrid>
            <MudItem xs="12" lg="7">
                <MudPaper Class="overview-card" Elevation="0">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
                        <MudText Typo="Typo.h6">Quick Actions</MudText>
                        <MudLink Href="/settings">View all settings sections</MudLink>
                    </MudStack>

                    <MudGrid>
                        @foreach (var action in _quickActions)
                        {
                            <MudItem xs="12" sm="6">
                                <MudPaper Class="overview-quick-action" Elevation="0" @onclick="() => NavigationManager.NavigateTo(action.Href)">
                                    <MudIcon Icon="@action.Icon" Class="mr-2" />
                                    <div>
                                        <MudText Typo="Typo.subtitle2">@action.Title</MudText>
                                        <MudText Typo="Typo.caption">@action.Description</MudText>
                                    </div>
                                </MudPaper>
                            </MudItem>
                        }
                    </MudGrid>
                </MudPaper>
            </MudItem>

            <MudItem xs="12" lg="5">
                <MudPaper Class="overview-card" Elevation="0">
                    <MudText Typo="Typo.h6" Class="mb-2">Recent Runs</MudText>

                    @if (_runs.Count == 0)
                    {
                        <MudText Typo="Typo.body2">No runs available for the current selection.</MudText>
                    }
                    else
                    {
                        <MudList T="RunDocument" Dense="true">
                            @foreach (var run in _runs.Take(8))
                            {
                                <MudListItem>
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Style="width:100%">
                                        <MudStack Spacing="0">
                                            <MudLink Href="@($"/settings/runs/{run.Id}")">@run.Id[..Math.Min(8, run.Id.Length)]</MudLink>
                                            <MudText Typo="Typo.caption">@run.CreatedAtUtc.ToLocalTime().ToString("g")</MudText>
                                        </MudStack>
                                        <MudChip T="string" Size="Size.Small" Color="@GetRunStateColor(run.State)">
                                            @GetRunStateLabel(run.State)
                                        </MudChip>
                                    </MudStack>
                                </MudListItem>
                            }
                        </MudList>
                    }
                </MudPaper>
            </MudItem>
        </MudGrid>
    </MudStack>
}

@code {
    private readonly List<QuickAction> _quickActions =
    [
        new("Runs", "Inspect queues, active and finished runs", "/settings/runs", Icons.Material.Filled.PlayCircle),
        new("Findings", "Triage failures and quality issues", "/settings/findings", Icons.Material.Filled.BugReport),
        new("Workflows", "Manage stage workflows", "/settings/workflows/stages", Icons.Material.Filled.AccountTree),
        new("Repositories", "Manage git-linked repositories", "/settings/repositories", Icons.Material.Filled.AccountTree),
        new("Session Profiles", "Manage per-run behavior presets", "/settings/session-profiles", Icons.Material.Filled.Person),
        new("Orchestrator", "Inspect task runtime status and queueing", "/settings/task-runtimes", Icons.Material.Filled.Engineering),
        new("Automations", "Manage cron/webhook automation definitions", "/settings/automations", Icons.Material.Filled.AutoMode),
        new("MCP", "Configure model context protocol routing snapshot", "/settings/mcp", Icons.Material.Filled.Extension),
        new("Orchestrator Policy", "Tune task runtime reliability and scaling", "/settings/task-runtimes", Icons.Material.Filled.Memory),
        new("System", "Update retention and docker policies", "/settings/system", Icons.Material.Filled.Tune)
    ];

    private bool _loading = true;
    private string _commandText = string.Empty;
    private int _openFindings;
    private int _activeRuns;
    private int _runQueuedCount;
    private int _runRunningCount;
    private int _runSucceededCount;
    private int _runFailedCount;
    private int _runCancelledCount;
    private int _runPendingApprovalCount;
    private int _runObsoleteCount;

    private int _workerContainersTotal;
    private int _workerContainersRunning;
    private int _workerReadyCount;
    private int _workerBusyCount;
    private int _workerDrainingCount;
    private int _workerOfflineCount;
    private bool _workerRuntimeSampleAvailable;
    private double _workerCpuAvgPercent;
    private double _workerCpuMaxPercent;
    private double _workerMemoryAvgPercent;
    private double _workerMemoryMaxPercent;
    private string? _workerRuntimeMessage;

    private DateTime? _lastMetricsRefreshUtc;
    private bool _controlPlaneHasCpuSample;
    private TimeSpan _lastProcessCpuTime;
    private DateTime? _lastProcessSampleUtc;
    private double _controlPlaneCpuPercent;
    private long _controlPlaneWorkingSetBytes;
    private long _controlPlanePrivateBytes;
    private long _controlPlaneGcBytes;
    private int _controlPlaneThreads;
    private int _controlPlaneHandleCount;
    private TimeSpan _controlPlaneUptime;
    private int _controlPlaneProcessId;

    private const int MaxMetricHistoryPoints = 120;
    private bool _dbSnapshotAvailable;
    private string _databasePath = "Unknown";
    private long _databaseSizeBytes;

    private readonly List<MetricPoint> _controlPlaneCpuTrend = [];
    private readonly List<MetricPoint> _workerCpuTrend = [];
    private readonly List<MetricPoint> _hostLoadTrend = [];
    private readonly List<MetricPoint> _controlPlaneWorkingSetTrend = [];
    private readonly List<MetricPoint> _hostMemoryUsedTrend = [];
    private readonly List<MetricPoint> _databaseSizeTrend = [];
    private readonly List<MetricPoint> _hostDiskUsedTrend = [];
    private readonly List<MetricPoint> _runQueuedTrend = [];
    private readonly List<MetricPoint> _runRunningTrend = [];
    private readonly List<MetricPoint> _runSucceededTrend = [];
    private readonly List<MetricPoint> _runFailedTrend = [];
    private readonly List<GaugePoint> _controlPlaneCpuGaugeSeries = [];
    private readonly List<GaugePoint> _workerCpuGaugeSeries = [];
    private readonly List<GaugePoint> _hostMemoryGaugeSeries = [];
    private readonly List<GaugePoint> _workerCapacityGaugeSeries = [];
    private readonly List<GaugePoint> _workerStateSeries = [];
    private readonly List<GaugePoint> _runStateSeries = [];
    private readonly List<GaugePoint> _hostLoadGaugeSeries = [];
    private readonly List<GaugePoint> _hostDiskUsageGaugeSeries = [];
    private readonly List<MetricPoint> _controlPlaneHandleTrend = [];
    private readonly List<MetricPoint> _controlPlaneThreadTrend = [];
    private readonly List<MetricPoint> _openFileDescriptorTrend = [];

    private OrchestratorHealthSnapshot? _orchestratorHealth;
    private string? _orchestratorHealthError;
    private TaskRuntimeTelemetrySnapshot _taskRuntimeTelemetry = new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    private bool _hostDiskAvailable;
    private string _hostDiskLabel = "/";
    private long _hostDiskUsedBytes;
    private long _hostDiskTotalBytes;
    private double _hostDiskUsagePercent;

    private bool _systemMemoryAvailable;
    private long _systemMemoryTotalBytes;
    private long _systemMemoryUsedBytes;
    private long _systemMemoryAvailableBytes;
    private double _systemMemoryUsedPercent;

    private bool _hostLoadAvailable;
    private double _hostLoadAverage1m;
    private double _hostLoadAverage5m;
    private double _hostLoadAverage15m;

    private bool _systemFileDescriptorSupported;
    private int _openFileDescriptorCount;

    private List<RepositoryDocument> _repositories = [];
    private List<RunDocument> _runs = [];
    private IDisposable? _selectionSubscription;
    private Action<BackgroundWorkSnapshot>? _backgroundWorkUpdatedHandler;
    private IReadOnlyList<BackgroundWorkSnapshot> _backgroundWorkSnapshots = [];
    private IReadOnlyList<BackgroundWorkSnapshot> _startupBackgroundWork = [];

    protected override async Task OnInitializedAsync()
    {
        _backgroundWorkUpdatedHandler = OnBackgroundWorkUpdated;
        BackgroundWorkCoordinator.Updated += _backgroundWorkUpdatedHandler;
        RefreshBackgroundWorkSnapshots();
        _selectionSubscription = SelectionService.Subscribe(async _ => await LoadDataAsync());
        await LoadDataAsync();
    }

    private async Task LoadDataAsync()
    {
        _loading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            _repositories = await Store.ListRepositoriesAsync(CancellationToken.None);

            if (SelectionService.SelectedRepositoryId is not null)
            {
                _runs = await Store.ListRunsByRepositoryAsync(SelectionService.SelectedRepositoryId, CancellationToken.None);
                var findings = await Store.ListFindingsAsync(SelectionService.SelectedRepositoryId, CancellationToken.None);
                _openFindings = findings.Count(IsOpenFinding);
            }
            else
            {
                _runs = await Store.ListRecentRunsAsync(CancellationToken.None);
                var findings = await Store.ListAllFindingsAsync(CancellationToken.None);
                _openFindings = findings.Count(IsOpenFinding);
            }

            _activeRuns = _runs.Count(r => TaskRunStatusPresentation.FromRunState(r.State).IsWorking);
            RefreshBackgroundWorkSnapshots();

            await LoadServerMetricsAsync();
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task LoadServerMetricsAsync()
    {
        await LoadWorkerMetricsAsync();
        await LoadOrchestratorCheckHealthAsync();
        await LoadStorageSnapshotAsync();
        LoadControlPlaneMetrics();
        LoadHostSystemMetrics();
        LoadHostDiskMetrics();
        BuildOverviewChartSeries();
        _lastMetricsRefreshUtc = DateTime.UtcNow;
    }

    private async Task LoadOrchestratorCheckHealthAsync()
    {
        _orchestratorHealth = null;
        _orchestratorHealthError = null;

        try
        {
            _orchestratorHealth = await WorkerLifecycle.GetHealthSnapshotAsync(CancellationToken.None);
        }
        catch
        {
            _orchestratorHealthError = "Orchestrator health snapshot unavailable";
        }
    }

    private async Task LoadWorkerMetricsAsync()
    {
        _workerRuntimeMessage = null;
        _workerRuntimeSampleAvailable = false;
        _workerCpuAvgPercent = 0;
        _workerCpuMaxPercent = 0;
        _workerMemoryAvgPercent = 0;
        _workerMemoryMaxPercent = 0;
        _taskRuntimeTelemetry = await Store.GetTaskRuntimeTelemetryAsync(CancellationToken.None);

        var runtimeRegistrations = await Store.ListTaskRuntimeRegistrationsAsync(CancellationToken.None);
        _workerContainersTotal = runtimeRegistrations.Count;
        _workerContainersRunning = runtimeRegistrations.Count(w => w.Online);
        _workerOfflineCount = _workerContainersTotal - _workerContainersRunning;

        _workerReadyCount = _workerContainersRunning;
        _workerBusyCount = 0;
        _workerDrainingCount = 0;

        try
        {
            var workerRuntimes = await WorkerLifecycle.ListTaskRuntimesAsync(CancellationToken.None);
            if (workerRuntimes.Count > 0)
            {
                _workerContainersTotal = workerRuntimes.Count;
                _workerContainersRunning = workerRuntimes.Count(w => w.IsRunning);
                _workerOfflineCount = _workerContainersTotal - _workerContainersRunning;
                _workerReadyCount = workerRuntimes.Count(w => w.LifecycleState is TaskRuntimeLifecycleState.Ready);
                _workerBusyCount = workerRuntimes.Count(w => w.LifecycleState is TaskRuntimeLifecycleState.Busy);
                _workerDrainingCount = workerRuntimes.Count(w => w.LifecycleState is TaskRuntimeLifecycleState.Draining);

                var runningWorkers = workerRuntimes
                    .Where(w => w.IsRunning)
                    .ToList();

                _workerRuntimeSampleAvailable = runningWorkers.Count > 0;

                if (_workerRuntimeSampleAvailable)
                {
                    _workerCpuAvgPercent = runningWorkers.Average(w => w.CpuPercent);
                    _workerCpuMaxPercent = runningWorkers.Max(w => w.CpuPercent);
                    _workerMemoryAvgPercent = runningWorkers.Average(w => w.MemoryPercent);
                    _workerMemoryMaxPercent = runningWorkers.Max(w => w.MemoryPercent);
                }
            }
        }
        catch
        {
            _workerRuntimeMessage = "Worker runtime metrics unavailable";
        }
    }

    private async Task LoadStorageSnapshotAsync()
    {
        try
        {
            var snapshot = await Store.GetStorageSnapshotAsync(CancellationToken.None);
            _dbSnapshotAvailable = snapshot.Exists;
            _databasePath = string.IsNullOrWhiteSpace(snapshot.DatabasePath)
                ? "Unknown path"
                : snapshot.DatabasePath;
            _databaseSizeBytes = snapshot.TotalBytes;
        }
        catch
        {
            _dbSnapshotAvailable = false;
            _databasePath = "Snapshot unavailable";
            _databaseSizeBytes = 0;
        }
    }

    private void LoadControlPlaneMetrics()
    {
        try
        {
            using var process = Process.GetCurrentProcess();

            _controlPlaneProcessId = process.Id;
            _controlPlaneThreads = process.Threads.Count;
            _controlPlaneHandleCount = process.HandleCount;
            _controlPlaneWorkingSetBytes = process.WorkingSet64;
            _controlPlanePrivateBytes = process.PrivateMemorySize64;
            _controlPlaneGcBytes = GC.GetTotalMemory(false);
            _controlPlaneUptime = DateTime.UtcNow - process.StartTime.ToUniversalTime();

            var currentSampleUtc = DateTime.UtcNow;
            var currentCpuTime = process.TotalProcessorTime;

            if (_controlPlaneHasCpuSample && _lastProcessSampleUtc is not null)
            {
                var wallClockMs = (currentSampleUtc - _lastProcessSampleUtc.Value).TotalMilliseconds;
                if (wallClockMs > 0)
                {
                    var cpuMs = (currentCpuTime - _lastProcessCpuTime).TotalMilliseconds;
                    var cpuPercent = cpuMs / (System.Environment.ProcessorCount * wallClockMs) * 100;
                    _controlPlaneCpuPercent = Math.Max(0, Math.Round(cpuPercent, 1));
                }
            }

            _lastProcessSampleUtc = currentSampleUtc;
            _lastProcessCpuTime = currentCpuTime;
            _controlPlaneHasCpuSample = true;
        }
        catch
        {
            _controlPlaneHasCpuSample = false;
            _controlPlaneProcessId = 0;
            _controlPlaneCpuPercent = 0;
            _controlPlaneThreads = 0;
            _controlPlaneHandleCount = 0;
            _controlPlaneWorkingSetBytes = 0;
            _controlPlanePrivateBytes = 0;
            _controlPlaneGcBytes = 0;
            _controlPlaneUptime = TimeSpan.Zero;
            _lastProcessSampleUtc = null;
            _lastProcessCpuTime = TimeSpan.Zero;
        }
    }

    private void LoadHostSystemMetrics()
    {
        try
        {
            _systemMemoryAvailable = false;
            _systemMemoryTotalBytes = 0;
            _systemMemoryUsedBytes = 0;
            _systemMemoryAvailableBytes = 0;
            _systemMemoryUsedPercent = 0;

            _hostLoadAvailable = false;
            _hostLoadAverage1m = 0;
            _hostLoadAverage5m = 0;
            _hostLoadAverage15m = 0;

            _systemFileDescriptorSupported = false;
            _openFileDescriptorCount = 0;

            if (!OperatingSystem.IsLinux())
            {
                return;
            }

            var memInfoLines = System.IO.File.ReadAllLines("/proc/meminfo");
            var totalKb = ParseMemInfoKb(memInfoLines, "MemTotal:");
            var availableKb = ParseMemInfoKb(memInfoLines, "MemAvailable:")
                              ?? (ParseMemInfoKb(memInfoLines, "MemFree:")
                                  + ParseMemInfoKb(memInfoLines, "Buffers:")
                                  + ParseMemInfoKb(memInfoLines, "Cached:"));

            if (totalKb > 0 && availableKb > 0)
            {
                _systemMemoryTotalBytes = totalKb.Value * 1024;
                _systemMemoryAvailableBytes = availableKb.Value * 1024;
                _systemMemoryUsedBytes = Math.Max(0, _systemMemoryTotalBytes - _systemMemoryAvailableBytes);
                _systemMemoryUsedPercent = _systemMemoryTotalBytes > 0
                    ? _systemMemoryUsedBytes * 100d / _systemMemoryTotalBytes
                    : 0;
                _systemMemoryAvailable = true;
            }

            var loadLine = System.IO.File.ReadAllText("/proc/loadavg");
            var loadParts = loadLine.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (loadParts.Length >= 3
                && double.TryParse(loadParts[0], System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var load1)
                && double.TryParse(loadParts[1], System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var load5)
                && double.TryParse(loadParts[2], System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var load15))
            {
                _hostLoadAverage1m = load1;
                _hostLoadAverage5m = load5;
                _hostLoadAverage15m = load15;
                _hostLoadAvailable = true;
            }

            const string fileDescriptorsPath = "/proc/self/fd";
            if (System.IO.Directory.Exists(fileDescriptorsPath))
            {
                _systemFileDescriptorSupported = true;
                _openFileDescriptorCount = System.IO.Directory.GetFiles(fileDescriptorsPath).Length;
            }
        }
        catch
        {
            _systemMemoryAvailable = false;
            _hostLoadAvailable = false;
            _systemFileDescriptorSupported = false;
            _openFileDescriptorCount = 0;
        }
    }

    private static long? ParseMemInfoKb(string[] memInfoLines, string key)
    {
        var entry = memInfoLines.FirstOrDefault(x => x.StartsWith(key, StringComparison.OrdinalIgnoreCase));
        if (entry is null)
        {
            return null;
        }

        var valuePart = entry.Split(':', 2);
        if (valuePart.Length != 2)
        {
            return null;
        }

        var valueTokens = valuePart[1].Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (valueTokens.Length == 0)
        {
            return null;
        }

        return long.TryParse(valueTokens[0], out var parsed)
            ? parsed
            : null;
    }

    private void LoadHostDiskMetrics()
    {
        try
        {
            var artifactsPath = OrchestratorOptions.Value.ArtifactsRootPath;
            if (string.IsNullOrWhiteSpace(artifactsPath))
            {
                artifactsPath = System.IO.Directory.GetCurrentDirectory();
            }

            var pathRoot = System.IO.Path.GetPathRoot(System.IO.Path.GetFullPath(artifactsPath));
            if (string.IsNullOrWhiteSpace(pathRoot))
            {
                _hostDiskAvailable = false;
                return;
            }

            var normalizedRoot = NormalizeDriveRoot(pathRoot);
            var drives = System.IO.DriveInfo.GetDrives().Where(d => d.IsReady).ToList();
            var selectedDrive = drives.FirstOrDefault(d =>
                string.Equals(NormalizeDriveRoot(d.Name), normalizedRoot, StringComparison.OrdinalIgnoreCase));

            if (selectedDrive is null)
            {
                selectedDrive = drives.FirstOrDefault();
            }

            if (selectedDrive is null)
            {
                _hostDiskAvailable = false;
                return;
            }

            _hostDiskAvailable = true;
            _hostDiskLabel = selectedDrive.Name;
            _hostDiskTotalBytes = selectedDrive.TotalSize;
            _hostDiskUsedBytes = Math.Max(0L, _hostDiskTotalBytes - selectedDrive.AvailableFreeSpace);
            _hostDiskUsagePercent = _hostDiskTotalBytes > 0
                ? _hostDiskUsedBytes * 100d / _hostDiskTotalBytes
                : 0;
        }
        catch
        {
            _hostDiskAvailable = false;
            _hostDiskLabel = "/";
            _hostDiskTotalBytes = 0;
            _hostDiskUsedBytes = 0;
            _hostDiskUsagePercent = 0;
        }
    }

    private static string NormalizeDriveRoot(string value)
    {
        var trimmed = value.Trim();
        if (trimmed.Length == 1 && (trimmed[0] == '/' || trimmed[0] == '\\'))
        {
            return trimmed;
        }

        return trimmed.TrimEnd(System.IO.Path.DirectorySeparatorChar, System.IO.Path.AltDirectorySeparatorChar).ToUpperInvariant();
    }

    private static string FormatBytes(long bytes)
    {
        var normalizedBytes = Math.Max(0, bytes);
        var units = new[] { "B", "KB", "MB", "GB", "TB", "PB" };
        var value = (double)normalizedBytes;
        var unitIndex = 0;

        while (value >= 1024 && unitIndex < units.Length - 1)
        {
            value /= 1024;
            unitIndex++;
        }

        return $"{value:0.0} {units[unitIndex]}";
    }

    private static string FormatPercent(double value)
    {
        return $"{Math.Max(0, value):0.0}%";
    }

    private static string FormatDurationSeconds(double value)
    {
        if (value <= 0)
        {
            return "0.0s";
        }

        return $"{value:0.0}s";
    }

    private static string FormatTimespan(TimeSpan value)
    {
        if (value <= TimeSpan.Zero)
        {
            return "00:00:00";
        }

        return value.Days > 0
            ? $"{value.Days}d {value:hh\\:mm\\:ss}"
            : $"{(int)value.TotalHours:00}:{value.Minutes:00}:{value.Seconds:00}";
    }

    private string GetOpenFileDescriptorText()
    {
        if (!_systemFileDescriptorSupported)
        {
            return "N/A";
        }

        return _openFileDescriptorCount.ToString("N0");
    }

    private string GetRunDistributionText()
    {
        if (_runs.Count == 0)
        {
            return "No runs in current scope";
        }

        var terminalFailures = _runFailedCount + _runCancelledCount;
        return $"Total: {_runs.Count} · Queued: {_runQueuedCount} · Running: {_runRunningCount} · Pending: {_runPendingApprovalCount} · Succeeded: {_runSucceededCount} · Failed: {terminalFailures}";
    }

    private string GetWorkerCapacityPercentText()
    {
        if (_workerContainersTotal <= 0)
        {
            return "N/A";
        }

        var occupied = _workerReadyCount + _workerBusyCount;
        var percent = occupied / (double)_workerContainersTotal * 100;
        return FormatPercent(Math.Round(Math.Clamp(percent, 0, 100), 1));
    }

    private static decimal ToGigabytes(long bytes)
    {
        if (bytes <= 0)
        {
            return 0m;
        }

        return bytes / (1024m * 1024m * 1024m);
    }

    private void BuildOverviewChartSeries()
    {
        var timestamp = DateTime.UtcNow;
        var capacityDenominator = Math.Max(1, _workerContainersTotal);
        var capacityPercent = (_workerReadyCount + _workerBusyCount) / (decimal)capacityDenominator * 100m;
        var hostLoadPercent = _hostLoadAvailable
            ? (decimal)Math.Clamp(_hostLoadAverage1m / Math.Max(1, System.Environment.ProcessorCount) * 100d, 0d, 100d)
            : 0m;
        var hostDiskPercent = _hostDiskAvailable
            ? (decimal)Math.Clamp(_hostDiskUsagePercent, 0, 100)
            : 0m;

        _runQueuedCount = _runs.Count(run => run.State is RunState.Queued);
        _runRunningCount = _runs.Count(run => TaskRunStatusPresentation.FromRunState(run.State).IsWorking);
        _runSucceededCount = _runs.Count(run => run.State is RunState.Succeeded);
        _runFailedCount = _runs.Count(run => run.State is RunState.Failed);
        _runCancelledCount = _runs.Count(run => run.State is RunState.Cancelled);
        _runPendingApprovalCount = _runs.Count(run => run.State is RunState.PendingApproval);
        _runObsoleteCount = _runs.Count(run => run.State is RunState.Obsolete);

        _controlPlaneCpuGaugeSeries.Clear();
        _workerCpuGaugeSeries.Clear();
        _hostMemoryGaugeSeries.Clear();
        _workerCapacityGaugeSeries.Clear();
        _workerStateSeries.Clear();
        _runStateSeries.Clear();
        _hostLoadGaugeSeries.Clear();
        _hostDiskUsageGaugeSeries.Clear();

        _controlPlaneCpuGaugeSeries.Add(new GaugePoint("Control Plane CPU", _controlPlaneHasCpuSample ? (decimal)Math.Clamp(_controlPlaneCpuPercent, 0, 100) : 0m));
        _workerCpuGaugeSeries.Add(new GaugePoint("Worker CPU", _workerRuntimeSampleAvailable ? (decimal)Math.Clamp(_workerCpuAvgPercent, 0, 100) : 0m));
        _hostMemoryGaugeSeries.Add(new GaugePoint("Host Memory", (decimal)Math.Clamp(_systemMemoryUsedPercent, 0, 100)));
        _workerCapacityGaugeSeries.Add(new GaugePoint("Worker Capacity", Math.Clamp(capacityPercent, 0m, 100m)));
        _hostLoadGaugeSeries.Add(new GaugePoint("Host Load", hostLoadPercent));
        _hostDiskUsageGaugeSeries.Add(new GaugePoint("Host Disk", hostDiskPercent));

        if (_workerBusyCount > 0)
        {
            _workerStateSeries.Add(new GaugePoint("Busy", _workerBusyCount));
        }

        if (_workerReadyCount > 0)
        {
            _workerStateSeries.Add(new GaugePoint("Ready", _workerReadyCount));
        }

        if (_workerDrainingCount > 0)
        {
            _workerStateSeries.Add(new GaugePoint("Draining", _workerDrainingCount));
        }

        if (_workerOfflineCount > 0)
        {
            _workerStateSeries.Add(new GaugePoint("Offline", _workerOfflineCount));
        }

        if (_workerStateSeries.Count == 0)
        {
            _workerStateSeries.Add(new GaugePoint("No workers", 1));
        }

        if (_runQueuedCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Queued", _runQueuedCount));
        }

        if (_runRunningCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Running", _runRunningCount));
        }

        if (_runSucceededCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Succeeded", _runSucceededCount));
        }

        if (_runFailedCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Failed", _runFailedCount));
        }

        if (_runCancelledCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Cancelled", _runCancelledCount));
        }

        if (_runPendingApprovalCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("PendingApproval", _runPendingApprovalCount));
        }

        if (_runObsoleteCount > 0)
        {
            _runStateSeries.Add(new GaugePoint("Obsolete", _runObsoleteCount));
        }

        if (_runStateSeries.Count == 0)
        {
            _runStateSeries.Add(new GaugePoint("No runs", 1));
        }

        AppendMetricPoint(_controlPlaneCpuTrend, new MetricPoint(timestamp, _controlPlaneHasCpuSample ? (decimal)_controlPlaneCpuPercent : 0m));
        AppendMetricPoint(_workerCpuTrend, new MetricPoint(timestamp, _workerRuntimeSampleAvailable ? (decimal)_workerCpuAvgPercent : 0m));
        AppendMetricPoint(_hostLoadTrend, new MetricPoint(timestamp, _hostLoadAvailable ? (decimal)_hostLoadAverage1m : 0m));
        AppendMetricPoint(_controlPlaneWorkingSetTrend, new MetricPoint(timestamp, ToGigabytes(_controlPlaneWorkingSetBytes)));
        AppendMetricPoint(_hostMemoryUsedTrend, new MetricPoint(timestamp, ToGigabytes(_systemMemoryUsedBytes)));
        AppendMetricPoint(_databaseSizeTrend, new MetricPoint(timestamp, ToGigabytes(_databaseSizeBytes)));
        AppendMetricPoint(_hostDiskUsedTrend, new MetricPoint(timestamp, ToGigabytes(_hostDiskUsedBytes)));
        AppendMetricPoint(_controlPlaneHandleTrend, new MetricPoint(timestamp, _controlPlaneHandleCount));
        AppendMetricPoint(_controlPlaneThreadTrend, new MetricPoint(timestamp, _controlPlaneThreads));
        AppendMetricPoint(_openFileDescriptorTrend, new MetricPoint(timestamp, _systemFileDescriptorSupported ? _openFileDescriptorCount : 0));
        AppendMetricPoint(_runQueuedTrend, new MetricPoint(timestamp, _runQueuedCount));
        AppendMetricPoint(_runRunningTrend, new MetricPoint(timestamp, _runRunningCount));
        AppendMetricPoint(_runSucceededTrend, new MetricPoint(timestamp, _runSucceededCount));
        AppendMetricPoint(_runFailedTrend, new MetricPoint(timestamp, _runFailedCount));
    }

    private void AppendMetricPoint(IList<MetricPoint> points, MetricPoint point)
    {
        points.Add(point);
        while (points.Count > MaxMetricHistoryPoints)
        {
            points.RemoveAt(0);
        }
    }

    private string GetLastUpdatedText()
    {
        if (_lastMetricsRefreshUtc is null)
        {
            return "Metrics not loaded";
        }

        return $"Updated {_lastMetricsRefreshUtc.Value.ToLocalTime():yyyy-MM-dd HH:mm:ss}";
    }

    private string GetControlPlaneCpuText()
    {
        return _controlPlaneHasCpuSample ? FormatPercent(_controlPlaneCpuPercent) : "N/A";
    }

    private string GetControlPlaneUptimeText() => FormatTimespan(_controlPlaneUptime);

    private string GetWorkerCpuText() => _workerRuntimeSampleAvailable ? FormatPercent(_workerCpuAvgPercent) : "N/A";

    private string GetWorkerCpuPeakText() => _workerRuntimeSampleAvailable ? FormatPercent(_workerCpuMaxPercent) : "N/A";

    private string GetWorkerMemoryText() => _workerRuntimeSampleAvailable ? FormatPercent(_workerMemoryAvgPercent) : "N/A";

    private string GetWorkerMemoryPeakText() => _workerRuntimeSampleAvailable ? FormatPercent(_workerMemoryMaxPercent) : "N/A";

    private string GetDatabaseSizeText()
    {
        if (!_dbSnapshotAvailable)
        {
            return "Unavailable";
        }

        return FormatBytes(_databaseSizeBytes);
    }

    private string GetHostDiskUsageText()
    {
        if (!_hostDiskAvailable || _hostDiskTotalBytes == 0)
        {
            return "Unavailable";
        }

        return FormatPercent(_hostDiskUsagePercent);
    }

    private string GetHostMemoryText()
    {
        if (!_systemMemoryAvailable || _systemMemoryTotalBytes <= 0)
        {
            return "Unavailable";
        }

        return FormatPercent(_systemMemoryUsedPercent);
    }

    private string GetHostMemoryUsedText()
    {
        if (!_systemMemoryAvailable)
        {
            return "Unavailable";
        }

        return FormatBytes(_systemMemoryUsedBytes);
    }

    private string GetHostMemoryTotalText()
    {
        if (!_systemMemoryAvailable)
        {
            return "Unavailable";
        }

        return FormatBytes(_systemMemoryTotalBytes);
    }

    private string GetHostMemoryAvailableText()
    {
        if (!_systemMemoryAvailable)
        {
            return "Unavailable";
        }

        return FormatBytes(_systemMemoryAvailableBytes);
    }

    private string GetHostLoadAverageText()
    {
        if (!_hostLoadAvailable)
        {
            return "Unavailable";
        }

        return $"{_hostLoadAverage1m:0.00} / {_hostLoadAverage5m:0.00} / {_hostLoadAverage15m:0.00}";
    }

    private string GetHostLoadPercentText()
    {
        if (!_hostLoadAvailable)
        {
            return "Unavailable";
        }

        var normalized = _hostLoadAverage1m / Math.Max(1, System.Environment.ProcessorCount);
        return FormatPercent(Math.Round(normalized * 100, 1));
    }

    private string GetControlPlaneHandleText()
    {
        return _controlPlaneHasCpuSample
            ? _controlPlaneHandleCount.ToString("N0")
            : "N/A";
    }

    private void OpenCommandTarget()
    {
        NavigationManager.NavigateTo(ResolveCommandRoute(_commandText));
    }

    private void ClearCommand()
    {
        _commandText = string.Empty;
    }

    private Task OnCommandKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            OpenCommandTarget();
        }

        return Task.CompletedTask;
    }

    private static string ResolveCommandRoute(string? command)
    {
        var normalized = command?.Trim().ToLowerInvariant() ?? string.Empty;

        if (normalized.Contains("run")) return "/settings/runs";
        if (normalized.Contains("finding")) return "/settings/findings";
        if (normalized.Contains("project") || normalized.Contains("repo")) return "/settings/repositories";
        if (normalized.Contains("session") || normalized.Contains("profile")) return "/settings/session-profiles";
        if (normalized.Contains("automation")) return "/settings/automations";
        if (normalized.Contains("mcp")) return "/settings/mcp";
        if (normalized.Contains("workflow") && normalized.Contains("stage")) return "/settings/workflows/stages";
        if (normalized.Contains("workflow") || normalized.Contains("stage")) return "/settings/workflows/stages";
        if (normalized.Contains("provider")) return "/providers";
        if (normalized.Contains("tool")) return "/settings/task-runtimes";
        if (normalized.Contains("worker")) return "/settings/task-runtimes";
        if (normalized.Contains("runtime")) return "/settings/task-runtimes";
        if (normalized.Contains("template")) return "/settings/templates";
        if (normalized.Contains("alert")) return "/settings/alerts";
        if (normalized.Contains("orchestrator")) return "/settings/task-runtimes";
        if (normalized.Contains("system") || normalized.Contains("settings")) return "/settings/system";
        return "/settings";
    }

    private static Color GetRunStateColor(RunState state) => TaskRunStatusPresentation.FromRunState(state).Color;

    private static string GetRunStateLabel(RunState state) => TaskRunStatusPresentation.FromRunState(state).Label;

    private static bool IsOpenFinding(FindingDocument finding) => finding.State is FindingState.New or FindingState.Acknowledged or FindingState.InProgress;

    private void OnBackgroundWorkUpdated(BackgroundWorkSnapshot snapshot)
    {
        _ = InvokeAsync(() =>
        {
            var updated = _backgroundWorkSnapshots
                .Where(existing => !string.Equals(existing.WorkId, snapshot.WorkId, StringComparison.OrdinalIgnoreCase))
                .Append(snapshot);
            _backgroundWorkSnapshots = BuildBackgroundWorkCache(updated);
            _startupBackgroundWork = BuildStartupBackgroundWork(_backgroundWorkSnapshots);
            StateHasChanged();
        });
    }

    private void RefreshBackgroundWorkSnapshots()
    {
        _backgroundWorkSnapshots = BuildBackgroundWorkCache(BackgroundWorkCoordinator.Snapshot());
        _startupBackgroundWork = BuildStartupBackgroundWork(_backgroundWorkSnapshots);
    }

    private static IReadOnlyList<BackgroundWorkSnapshot> BuildBackgroundWorkCache(IEnumerable<BackgroundWorkSnapshot> snapshots)
    {
        return snapshots
            .OrderByDescending(snapshot => snapshot.UpdatedAt ?? snapshot.StartedAt ?? DateTimeOffset.MinValue)
            .Take(100)
            .ToArray();
    }

    private static IReadOnlyList<BackgroundWorkSnapshot> BuildStartupBackgroundWork(
        IEnumerable<BackgroundWorkSnapshot> snapshots)
    {
        return snapshots
            .Where(snapshot =>
                snapshot.OperationKey.StartsWith("startup:", StringComparison.OrdinalIgnoreCase) ||
                snapshot.Kind is BackgroundWorkKind.TaskRuntimeImageResolution or BackgroundWorkKind.LiteDbVectorBootstrap or BackgroundWorkKind.Recovery or BackgroundWorkKind.TaskTemplateInit)
            .OrderByDescending(snapshot => snapshot.UpdatedAt ?? snapshot.StartedAt ?? DateTimeOffset.MinValue)
            .Take(12)
            .ToArray();
    }

    private static Color MapBackgroundWorkColor(BackgroundWorkState state)
    {
        return state switch
        {
            BackgroundWorkState.Pending => Color.Info,
            BackgroundWorkState.Running => Color.Primary,
            BackgroundWorkState.Succeeded => Color.Success,
            BackgroundWorkState.Failed => Color.Error,
            BackgroundWorkState.Cancelled => Color.Warning,
            _ => Color.Default,
        };
    }

    public void Dispose()
    {
        _selectionSubscription?.Dispose();
        if (_backgroundWorkUpdatedHandler is not null)
        {
            BackgroundWorkCoordinator.Updated -= _backgroundWorkUpdatedHandler;
            _backgroundWorkUpdatedHandler = null;
        }
    }

    private sealed record MetricPoint(DateTime Time, decimal Value);

    private sealed record GaugePoint(string Label, decimal Value);

    private record QuickAction(string Title, string Description, string Href, string Icon);
}

@page "/settings/sounds"
@layout SettingsLayout
@rendermode InteractiveServer
@inject IJSRuntime JS
@inject ISnackbar Snackbar

@namespace AgentsDashboard.ControlPlane.Components.Pages
<PageTitle>Sound Settings - AgentsDashboard</PageTitle>

<MudText Typo="Typo.h4" Class="mb-4">Sound Settings</MudText>
<MudText Typo="Typo.body2" Class="mb-3">
    Configure completion audio behavior for succeeded, failed, and cancelled runs.
</MudText>

@if (_loading)
{
    <MudProgressLinear Indeterminate />
}
else
{
    <SettingsActionBar IsDirty="@HasUnsavedChanges"
                       IsSaving="_saving"
                       SaveLabel="Save Settings"
                       OnSave="SaveAsync"
                       OnRevert="RevertChangesAsync"
                       OnResetDefaults="ResetToDefaultsAsync" />
    <MudGrid>
        <MudItem xs="12" md="6" lg="4">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-2">
                    <MudText Typo="Typo.h6">Audio Engine</MudText>
                    <SettingsHintIcon Text="Global toggle and engine metadata for run completion audio." />
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">Version</MudText>
                <MudChip T="string" Color="Color.Info" Variant="Variant.Text">@_info?.Version</MudChip>
                <SettingsHintedField ContainerClass="mt-3" Hint="Master switch for all run completion sounds.">
                    <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.Enabled">
                        Play sound when a task ends
                    </MudSwitch>
                </SettingsHintedField>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6" lg="4">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-2">
                    <MudText Typo="Typo.h6">Profile</MudText>
                    <SettingsHintIcon Text="Profile defines tone style for all completion sounds." />
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">Choose a tone profile.</MudText>
                <SettingsHintedField ContainerClass="" Hint="Switch profile to change the sound character without changing trigger states.">
                    <MudSelect T="string" Label="Profile" Variant="Variant.Outlined"
                               @bind-Value="_settings.SelectedProfile"
                               Class="mud-width-full mb-3">
                        @foreach (var profile in _info?.Profiles ?? [])
                        {
                            <MudSelectItem Value="@profile.Id">@profile.Label</MudSelectItem>
                        }
                    </MudSelect>
                </SettingsHintedField>

                <MudText Typo="Typo.body2" Class="mb-2">
                    @(_info?.Profiles.FirstOrDefault(p => string.Equals(p.Id, _settings.SelectedProfile, StringComparison.OrdinalIgnoreCase))?.Description)
                </MudText>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6" lg="4">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-2">
                    <MudText Typo="Typo.h6">Volume</MudText>
                    <SettingsHintIcon Text="Volume applies to generated completion tones only." />
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">Current volume: @Math.Round(_settings.Volume * 100, 0)%</MudText>
                <SettingsHintedField ContainerClass="" Hint="0 is mute and 1 is maximum output volume.">
                    <MudSlider T="double" Min="0"
                                     Max="1"
                                     Step="0.01"
                                     @bind-Value="_settings.Volume"
                                     Class="mud-width-full" />
                </SettingsHintedField>
                <MudText Typo="Typo.caption" Class="d-block mt-1">0% muted, 100% max.</MudText>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6" lg="4">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-2">
                    <MudText Typo="Typo.h6">Play State</MudText>
                    <SettingsHintIcon Text="Choose which terminal run states trigger playback." />
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">Pick which run completion states should trigger audio.</MudText>
                <MudStack Spacing="1">
                    <MudSwitch T="bool" Color="Color.Primary" @bind-Value="_settings.PlaySucceeded">Succeeded</MudSwitch>
                    <MudSwitch T="bool" Color="Color.Error" @bind-Value="_settings.PlayFailed">Failed</MudSwitch>
                    <MudSwitch T="bool" Color="Color.Warning" @bind-Value="_settings.PlayCancelled">Cancelled</MudSwitch>
                </MudStack>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="6" lg="4">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-2">
                    <MudText Typo="Typo.h6">Sound Preview</MudText>
                    <SettingsHintIcon Text="Preview verifies browser audio permissions and the selected profile/state behavior." />
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">Play a sample without waiting for a run.</MudText>
                <SettingsHintedField ContainerClass="" Hint="Preview uses selected profile and current sound settings for this state.">
                    <MudSelect T="string" Label="Preview state" Variant="Variant.Outlined"
                               @bind-Value="_previewState"
                               Class="mud-width-full mb-3">
                        @foreach (var state in _previewStateOptions)
                        {
                            <MudSelectItem Value="@state">@state</MudSelectItem>
                        }
                    </MudSelect>
                </SettingsHintedField>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.PlayArrow"
                           OnClick="TestAsync" Disabled="_testing">
                    @if (_testing)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate Class="mr-2" />
                    }
                    Test Sound
                </MudButton>
            </MudPaper>
        </MudItem>

        <MudItem xs="12">
            <SettingsActionBar IsDirty="@HasUnsavedChanges"
                               IsSaving="_saving"
                               SaveLabel="Save Settings"
                               Class="mt-2"
                               OnSave="SaveAsync"
                               OnRevert="RevertChangesAsync"
                               OnResetDefaults="ResetToDefaultsAsync" />
        </MudItem>
    </MudGrid>
}

@code {
    private static readonly string[] _previewStateOptions = ["succeeded", "failed", "cancelled"];

    private bool _loading = true;
    private bool _saving;
    private bool _testing;
    private string _previewState = "succeeded";
    private RunCompletionAudioSettings _settings = new();
    private RunCompletionAudioSettings _savedSettings = new();
    private RunCompletionAudioInfo? _info;
    private bool HasUnsavedChanges => !AreSettingsEqual(_settings, _savedSettings);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadAsync();
        }
    }

    private async Task LoadAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            _info = await JS.InvokeAsync<RunCompletionAudioInfo>("agentsDashboard.getRunCompletionAudioInfo");
            var settings = await JS.InvokeAsync<RunCompletionAudioSettings>("agentsDashboard.getRunCompletionAudioSettings");
            _settings = Normalize(settings ?? new RunCompletionAudioSettings(), _info);
            _savedSettings = CloneSettings(_settings);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load sound settings: {ex.Message}", Severity.Error);
            _info = GetFallbackInfo();
            _settings = Normalize(_settings, _info);
            _savedSettings = CloneSettings(_settings);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task SaveAsync()
    {
        _saving = true;
        StateHasChanged();

        try
        {
            _settings = Normalize(_settings, _info ?? GetFallbackInfo());
            _settings = await JS.InvokeAsync<RunCompletionAudioSettings>("agentsDashboard.setRunCompletionAudioSettings", _settings);
            _savedSettings = CloneSettings(_settings);
            Snackbar.Add("Sound settings saved", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save sound settings: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    private async Task TestAsync()
    {
        _testing = true;
        StateHasChanged();

        try
        {
            var canTest = await JS.InvokeAsync<bool>("agentsDashboard.testRunCompletionSound", _previewState, Normalize(_settings, _info));
            Snackbar.Add(canTest ? "Test sound played" : "Sound test could not be played", canTest ? Severity.Info : Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to play test sound: {ex.Message}", Severity.Error);
        }
        finally
        {
            _testing = false;
            StateHasChanged();
        }
    }

    private Task RevertChangesAsync()
    {
        _settings = CloneSettings(_savedSettings);
        return Task.CompletedTask;
    }

    private Task ResetToDefaultsAsync()
    {
        _settings = Normalize(new RunCompletionAudioSettings(), _info ?? GetFallbackInfo());
        return Task.CompletedTask;
    }

    private static RunCompletionAudioSettings Normalize(RunCompletionAudioSettings settings, RunCompletionAudioInfo? info = null)
    {
        if (settings is null)
        {
            return new RunCompletionAudioSettings();
        }

        settings.Volume = Math.Clamp(settings.Volume, 0, 1);
        var selectedProfile = string.IsNullOrWhiteSpace(settings.SelectedProfile) ? "mixkit" : settings.SelectedProfile.ToLowerInvariant();
        var profileExists = info?.Profiles.Any(p => string.Equals(p.Id, selectedProfile, StringComparison.OrdinalIgnoreCase)) == true;
        settings.SelectedProfile = profileExists ? selectedProfile : (info?.Profiles.FirstOrDefault()?.Id ?? "mixkit");

        return settings;
    }

    private static RunCompletionAudioInfo GetFallbackInfo()
    {
        return new RunCompletionAudioInfo
        {
            Version = "unknown",
            Profiles =
            [
                new RunCompletionAudioProfile { Id = "mixkit", Label = "Mixkit Minimal", Description = "Minimal, modern notification tones from your selected Mixkit sounds." },
                new RunCompletionAudioProfile { Id = "modern", Label = "Modern", Description = "Bright layered arpeggios with soft attack for a contemporary finish." },
                new RunCompletionAudioProfile { Id = "ambient", Label = "Ambient", Description = "Softer, rounded tones that linger for a calmer finish." },
                new RunCompletionAudioProfile { Id = "clean", Label = "Clean", Description = "Tight, focused tones with immediate attack for clear status changes." },
                new RunCompletionAudioProfile { Id = "sparkle", Label = "Sparkle", Description = "A crisp notification style with playful, bright harmonic motion." }
            ]
        };
    }

    private sealed class RunCompletionAudioInfo
    {
        public string Version { get; set; } = "unknown";
        public List<RunCompletionAudioProfile> Profiles { get; set; } = [];
    }

    private sealed class RunCompletionAudioProfile
    {
        public string Id { get; set; } = "mixkit";
        public string Label { get; set; } = "Mixkit Minimal";
        public string Description { get; set; } = string.Empty;
    }

    private sealed class RunCompletionAudioSettings
    {
        public bool Enabled { get; set; } = true;
        public double Volume { get; set; } = 0.65;
        public string SelectedProfile { get; set; } = "mixkit";
        public bool PlaySucceeded { get; set; } = true;
        public bool PlayFailed { get; set; } = true;
        public bool PlayCancelled { get; set; } = true;
    }

    private static RunCompletionAudioSettings CloneSettings(RunCompletionAudioSettings source)
    {
        return new RunCompletionAudioSettings
        {
            Enabled = source.Enabled,
            Volume = source.Volume,
            SelectedProfile = source.SelectedProfile,
            PlaySucceeded = source.PlaySucceeded,
            PlayFailed = source.PlayFailed,
            PlayCancelled = source.PlayCancelled
        };
    }

    private static bool AreSettingsEqual(RunCompletionAudioSettings left, RunCompletionAudioSettings right)
    {
        return left.Enabled == right.Enabled
            && Math.Abs(left.Volume - right.Volume) < 0.0001
            && string.Equals(left.SelectedProfile, right.SelectedProfile, StringComparison.Ordinal)
            && left.PlaySucceeded == right.PlaySucceeded
            && left.PlayFailed == right.PlayFailed
            && left.PlayCancelled == right.PlayCancelled;
    }
}

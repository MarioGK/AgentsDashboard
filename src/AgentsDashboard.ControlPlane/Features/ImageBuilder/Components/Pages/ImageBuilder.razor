@page "/settings/image-builder"
@layout SettingsLayout
@rendermode InteractiveServer
@using BlazorMonaco.Editor
@using AgentsDashboard.ControlPlane.Services
@using AgentsDashboard.ControlPlane.Data
@inject ImageBuilderService ImageBuilderService
@inject IOrchestratorStore Store
@inject ISecretCryptoService SecretCrypto
@inject ISnackbar Snackbar

@namespace AgentsDashboard.ControlPlane.Components.Pages
<PageTitle>Container Image Builder</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-3">
        <MudText Typo="Typo.h4">Container Image Builder</MudText>
        <SettingsHintIcon Text="Build and manage runtime images used by harness execution environments." />
    </MudStack>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-6">
        Build custom Docker images for use with harness execution. Images are built on the local Docker daemon.
    </MudText>

        <MudExpansionPanels>
            <MudExpansionPanel Text="Dockerfile Generator" Icon="@Icons.Material.Filled.AutoAwesome">
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                    <strong>Template:</strong> Generates Dockerfile using predefined rules based on your selections.<br/>
                    <strong>AI Generate:</strong> Uses the global LlmTornado key to create a custom Dockerfile from your natural language description.
                </MudText>
                <MudGrid Class="mt-2">
                <MudItem xs="12">
                    <SettingsHintedField ContainerClass="" Hint="Natural language requirements used by template and AI generation flows.">
                        <MudTextField @bind-Value="_aiDescription"
                                      Label="Describe your container requirements"
                                      Variant="Variant.Outlined"
                                      HelperText="E.g., 'Python 3.12 with Playwright and secure defaults for web testing'"
                                      Lines="2" />
                    </SettingsHintedField>
                </MudItem>
                <MudItem xs="12" md="4">
                    <SettingsHintedField ContainerClass="" Hint="Base image used as the starting point for generated Dockerfile.">
                        <MudSelect @bind-Value="_aiBaseImage" Label="Base Image" Variant="Variant.Outlined" T="string">
                            <MudSelectItem Value="@("ubuntu:24.04")">Ubuntu 24.04</MudSelectItem>
                            <MudSelectItem Value="@("alpine:3.19")">Alpine 3.19 (Minimal)</MudSelectItem>
                            <MudSelectItem Value="@("node:20-slim")">Node 20 Slim</MudSelectItem>
                            <MudSelectItem Value="@("python:3.12-slim")">Python 3.12 Slim</MudSelectItem>
                            <MudSelectItem Value="@("mcr.microsoft.com/dotnet/sdk:10.0")">.NET 10 SDK</MudSelectItem>
                            <MudSelectItem Value="@("golang:1.23-alpine")">Go 1.23 Alpine</MudSelectItem>
                        </MudSelect>
                    </SettingsHintedField>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudSelect SelectedValues="_aiRuntimes" SelectedValuesChanged="v => _aiRuntimes = v.ToList()" Label="Runtimes" Variant="Variant.Outlined" T="string" MultiSelection="true">
                        <MudSelectItem Value="@("node")">Node.js</MudSelectItem>
                        <MudSelectItem Value="@("python")">Python</MudSelectItem>
                        <MudSelectItem Value="@("dotnet")">.NET</MudSelectItem>
                        <MudSelectItem Value="@("go")">Go</MudSelectItem>
                        <MudSelectItem Value="@("bun")">Bun</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudSelect SelectedValues="_aiHarnesses" SelectedValuesChanged="v => _aiHarnesses = v.ToList()" Label="Harnesses" Variant="Variant.Outlined" T="string" MultiSelection="true">
                        <MudSelectItem Value="@("codex")">Codex (OpenAI)</MudSelectItem>
                        <MudSelectItem Value="@("opencode")">OpenCode</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudSelect SelectedValues="_aiTools" SelectedValuesChanged="v => _aiTools = v.ToList()" Label="Dev Tools" Variant="Variant.Outlined" T="string" MultiSelection="true">
                        <MudSelectItem Value="@("git")">Git</MudSelectItem>
                        <MudSelectItem Value="@("ripgrep")">Ripgrep</MudSelectItem>
                        <MudSelectItem Value="@("fd-find")">fd-find</MudSelectItem>
                        <MudSelectItem Value="@("jq")">jq</MudSelectItem>
                        <MudSelectItem Value="@("build-essential")">Build Essential</MudSelectItem>
                        <MudSelectItem Value="@("playwright")">Playwright</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudSwitch @bind-Value="_aiIncludeDockerCli" Label="Include Docker CLI" Color="Color.Primary" />
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Filled.Code"
                               OnClick="GenerateDockerfileAsync"
                               Disabled="string.IsNullOrWhiteSpace(_aiDescription)"
                               Class="mr-2">
                        Template
                    </MudButton>
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Secondary"
                               StartIcon="@Icons.Material.Filled.AutoAwesome"
                               OnClick="GenerateDockerfileWithAiAsync"
                               Disabled="@(_isAiGenerating || string.IsNullOrWhiteSpace(_aiDescription))">
                        @if (_isAiGenerating)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        }
                        AI Generate
                    </MudButton>
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Info"
                               StartIcon="@Icons.Material.Filled.Security"
                               OnClick="ApplyHardeningPassAsync"
                               Disabled="@(_isHardening || string.IsNullOrWhiteSpace(_dockerfileContent))"
                               Class="ml-2">
                        @if (_isHardening)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Hardening...</span>
                        }
                        else
                        {
                            <span>Harden Image</span>
                        }
                    </MudButton>
                </MudItem>
                <MudItem xs="12">
                    <MudPaper Elevation="1" Class="pa-3 mt-3">
                        <MudText Typo="Typo.h6" Class="mb-2">Dependency Matrix</MudText>
                        <MudText Typo="Typo.body2" Class="mb-1">
                            <strong>Languages:</strong> @FormatDependencyValues(_dependencyMatrix?.Languages)
                        </MudText>
                        <MudText Typo="Typo.body2" Class="mb-1">
                            <strong>Package Managers:</strong> @FormatDependencyValues(_dependencyMatrix?.PackageManagers)
                        </MudText>
                        <MudText Typo="Typo.body2" Class="mb-1">
                            <strong>Harness CLIs:</strong> @FormatDependencyValues(_dependencyMatrix?.Harnesses)
                        </MudText>
                        <MudText Typo="Typo.body2">
                            <strong>Security Tools:</strong> @FormatDependencyValues(_dependencyMatrix?.SecurityTools)
                        </MudText>
                    </MudPaper>
                </MudItem>
                @if (_aiError != null)
                {
                    <MudItem xs="12">
                        <MudAlert Severity="Severity.Warning" Dense="true">@_aiError</MudAlert>
                    </MudItem>
                }
            </MudGrid>
        </MudExpansionPanel>
    </MudExpansionPanels>

    <MudPaper Elevation="2" Class="pa-4 mb-4 mt-4">
        <MudGrid>
            <MudItem xs="12" md="6">
                <MudSelect Value="_selectedTemplate"
                           ValueChanged="OnTemplateChangedAsync"
                           Label="Template"
                           Variant="Variant.Outlined"
                           T="string"
                           ToStringFunc="@(x => x ?? "Custom")"
                           Class="mb-2">
                    @foreach (var template in _templates.Keys)
                    {
                        <MudSelectItem Value="@template">@template</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
                <MudItem xs="12" md="6">
                <SettingsHintedField ContainerClass="" Hint="Final image reference used for push/pull and orchestrator selection.">
                    <MudTextField @bind-Value="_imageTag"
                                  Label="Image Tag"
                                  Variant="Variant.Outlined"
                                  Required="true"
                                  HelperText="Format: name:version (e.g., myharness:latest)"
                                  Class="mb-2" />
                </SettingsHintedField>
            </MudItem>
        </MudGrid>

        <MudText Typo="Typo.h6" Class="mb-2 mt-4">Dockerfile</MudText>
        <div style="height: 620px;">
            <StandaloneCodeEditor @ref="_dockerfileEditor"
                                  ConstructionOptions="EditorOptions"
                                  CssClass="mb-4 monaco-fill-parent" />
        </div>

        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.Build"
                   OnClick="BuildImageAsync"
                   Disabled="@(_isBuilding || string.IsNullOrWhiteSpace(_imageTag))">
            @if (_isBuilding)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>Building...</span>
            }
            else
            {
                <span>Build Image</span>
            }
        </MudButton>

        <MudButton Variant="Variant.Outlined"
                   Color="Color.Secondary"
                   StartIcon="@Icons.Material.Filled.Refresh"
                   Class="ml-2"
                   OnClick="RefreshImagesAsync"
                   Disabled="_isBuilding">
            Refresh Images
        </MudButton>
    </MudPaper>

    @if (_buildResult != null)
    {
        <MudAlert Severity="@(_buildResult.Success ? Severity.Success : Severity.Error)" Class="mb-4" CloseIconClicked="() => _buildResult = null" ShowCloseIcon="true">
            @if (_buildResult.Success)
            {
                <text>Successfully built image: <strong>@_buildResult.ImageId</strong></text>
            }
            else
            {
                <text>Build failed. Check the logs below for details.</text>
            }
        </MudAlert>
    }

    @if (_buildLogs.Count > 0)
    {
        <MudPaper Elevation="2" Class="pa-4 mb-4">
            <MudText Typo="Typo.h6" Class="mb-2">Build Logs</MudText>
            <MudPaper Elevation="0" Class="pa-3" Style="max-height: 400px; overflow-y: auto; background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace; font-size: 12px;">
                @foreach (var log in _buildLogs)
                {
                    <div>@log</div>
                }
            </MudPaper>
            <MudButton Variant="Variant.Text"
                       Color="Color.Secondary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Clear"
                       Class="mt-2"
                       OnClick="() => _buildLogs.Clear()">
                Clear Logs
            </MudButton>
        </MudPaper>
    }

    @if (_images.Count > 0)
    {
        <MudPaper Elevation="2" Class="pa-4">
            <MudText Typo="Typo.h6" Class="mb-3">Available Images (@_images.Count)</MudText>
            <MudTable Items="_images" Dense="true" Hover="true" Striped="true" Class="mb-0">
                <HeaderContent>
                    <MudTh>Tag</MudTh>
                    <MudTh>Image ID</MudTh>
                    <MudTh>Size</MudTh>
                    <MudTh>Created</MudTh>
                    <MudTh Style="text-align: right">Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Tag">
                        <MudIcon Icon="@Icons.Material.Filled.Image" Size="Size.Small" Class="mr-2" />
                        <code>@context.Tag</code>
                    </MudTd>
                    <MudTd DataLabel="Image ID">
                        <code style="font-size: 0.8em;">@(context.Id.Length > 19 ? context.Id.Substring(7, 12) : context.Id)</code>
                    </MudTd>
                    <MudTd DataLabel="Size">@FormatBytes(context.Size)</MudTd>
                    <MudTd DataLabel="Created">@context.Created.ToString("yyyy-MM-dd HH:mm")</MudTd>
                    <MudTd DataLabel="Actions" Style="text-align: right">
                        <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                       Color="Color.Error"
                                       Size="Size.Small"
                                       OnClick="() => DeleteImageAsync(context.Tag)" />
                    </MudTd>
                </RowTemplate>
            </MudTable>
        </MudPaper>
    }
    else
    {
        <MudPaper Elevation="2" Class="pa-4">
            <MudText Typo="Typo.h6" Class="mb-2">Available Images</MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">No images found. Build an image to get started.</MudText>
        </MudPaper>
    }
</MudContainer>

@code {
    private string _dockerfileContent = string.Empty;
    private string _imageTag = "myharness:latest";
    private string _selectedTemplate = "Full Harness";
    private bool _isBuilding = false;
    private ImageBuildResult? _buildResult;
    private List<string> _buildLogs = new();
    private List<ImageInfo> _images = new();

    private string _aiDescription = string.Empty;
    private string _aiBaseImage = "ubuntu:24.04";
    private List<string> _aiRuntimes = new();
    private List<string> _aiHarnesses = new();
    private List<string> _aiTools = new();
    private ImageDependencyMatrix? _dependencyMatrix;
    private bool _aiIncludeDockerCli = false;
    private bool _isAiGenerating = false;
    private bool _isHardening = false;
    private string? _aiError;
    private StandaloneCodeEditor? _dockerfileEditor;
    private const string MonacoTheme = "agents-dashboard-dark";

    private readonly Dictionary<string, string> _templates = new()
    {
        ["Full Harness"] = @"# AI Orchestrator - All-in-One Harness Execution Environment
# Contains all harness tools: codex, opencode
# Build: docker build -t ghcr.io/mariogk/ai-harness:latest .

# Must build harness-base first from deploy/harness-images/
# For local builds: docker build -f deploy/harness-images/Dockerfile.harness-base -t ai-harness-base:latest .
# For CI/CD: Use ghcr.io/mariogk/ai-harness-base:latest
ARG BASE_IMAGE=ghcr.io/mariogk/ai-harness-base:latest
FROM ${BASE_IMAGE}

LABEL org.opencontainers.image.source=https://github.com/mariogk/AgentsDashboard \
      org.opencontainers.image.description=""All-in-one harness execution environment for AI Orchestrator"" \
      org.opencontainers.image.licenses=MIT

USER root

RUN npm install -g openai && echo ""OpenAI SDK installed successfully""
RUN npm install -g @openai/codex 2>/dev/null || echo ""Codex CLI not yet available, using API fallback""
RUN mkdir -p /home/agent/.config \
    && chown -R agent:agent /home/agent/.config

COPY --chmod=755 <<'EOF' /usr/local/bin/codex
#!/bin/bash
# Codex CLI wrapper for AI Orchestrator

set -e

if [ -z ""$OPENAI_API_KEY"" ]; then
    echo '{""status"": ""failed"", ""error"": ""OPENAI_API_KEY not set""}' >&2
    exit 1
fi

PROMPT=""${CODEX_PROMPT:-$PROMPT}""
if [ -z ""$PROMPT"" ]; then
    if [ $# -gt 0 ]; then
        PROMPT=""$*""
    else
        echo '{""status"": ""failed"", ""error"": ""No prompt provided""}' >&2
        exit 1
    fi
fi

MODEL=""${CODEX_MODEL:-gpt-4o}""

if command -v codex &> /dev/null && [ ""$CODEX_FORMAT"" != ""api"" ]; then
    OUTPUT=$(codex ""$PROMPT"" 2>&1)
    EXIT_CODE=$?
else
    RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
        -H ""Content-Type: application/json"" \
        -H ""Authorization: Bearer $OPENAI_API_KEY"" \
        -d ""{
            \""model\"": \""$MODEL\"",
            \""messages\"": [{\""role\"": \""user\"", \""content\"": $(echo ""$PROMPT"" | jq -Rs .)}],
            \""max_tokens\"": 4096
        }"")
    
    if echo ""$RESPONSE"" | jq -e '.error' > /dev/null 2>&1; then
        cat <<ENVELOPE
{
    ""runId"": ""${CODEX_RUN_ID:-unknown}"",
    ""taskId"": ""${CODEX_TASK_ID:-unknown}"",
    ""status"": ""failed"",
    ""summary"": ""OpenAI API call failed"",
    ""error"": $(echo ""$RESPONSE"" | jq -r '.error.message // .error // ""Unknown error""' | jq -Rs .)
}
ENVELOPE
        exit 1
    fi
    
    CONTENT=$(echo ""$RESPONSE"" | jq -r '.choices[0].message.content // empty')
    
    cat <<ENVELOPE
{
    ""runId"": ""${CODEX_RUN_ID:-unknown}"",
    ""taskId"": ""${CODEX_TASK_ID:-unknown}"",
    ""status"": ""succeeded"",
    ""summary"": ""Codex execution completed"",
    ""metadata"": {
        ""model"": ""$MODEL"",
        ""contentLength"": ""${#CONTENT}"",
        ""provider"": ""openai""
    }
}
ENVELOPE
    exit 0
fi

if [ ""$CODEX_FORMAT"" = ""json"" ]; then
    cat <<ENVELOPE
{
    ""runId"": ""${CODEX_RUN_ID:-unknown}"",
    ""taskId"": ""${CODEX_TASK_ID:-unknown}"",
    ""status"": ""$([ $EXIT_CODE -eq 0 ] && echo 'succeeded' || echo 'failed')"",
    ""summary"": ""Codex execution completed"",
    ""error"": ""$([ $EXIT_CODE -ne 0 ] && echo ""$OUTPUT"" | head -1 | jq -Rs . || echo 'null')"",
    ""metadata"": {
        ""exitCode"": $EXIT_CODE,
        ""outputLength"": ${#OUTPUT}
    }
}
ENVELOPE
else
    echo ""$OUTPUT""
fi
EOF

COPY --chmod=755 <<'EOF' /usr/local/bin/opencode-wrapper
#!/bin/bash
# OpenCode wrapper for AI Orchestrator

set -e

PROMPT=""${OPENCODE_PROMPT:-$PROMPT}""
if [ -z ""$PROMPT"" ]; then
    if [ $# -gt 0 ]; then
        PROMPT=""$*""
    else
        echo '{""status"": ""failed"", ""error"": ""No prompt provided""}' >&2
        exit 1
    fi
fi

if command -v opencode &> /dev/null; then
    OUTPUT=$(opencode ""$PROMPT"" 2>&1)
    EXIT_CODE=$?
else
    echo '{""status"": ""failed"", ""error"": ""OpenCode CLI not available""}' >&2
    exit 1
fi

if [ ""$OPENCODE_OUTPUT_ENVELOPE"" = ""true"" ]; then
    cat <<ENVELOPE
{
    ""runId"": ""${OPENCODE_RUN_ID:-unknown}"",
    ""taskId"": ""${OPENCODE_TASK_ID:-unknown}"",
    ""status"": ""$([ $EXIT_CODE -eq 0 ] && echo 'succeeded' || echo 'failed')"",
    ""summary"": ""OpenCode execution completed"",
    ""error"": ""$([ $EXIT_CODE -ne 0 ] && echo ""$OUTPUT"" | head -1 | jq -Rs . || echo 'null')"",
    ""metadata"": {
        ""exitCode"": $EXIT_CODE,
        ""outputLength"": ${#OUTPUT}
    }
}
ENVELOPE
else
    echo ""$OUTPUT""
fi
EOF

RUN go install github.com/opencode-ai/opencode@latest 2>/dev/null || echo ""OpenCode CLI installed"" \
    && cp /root/go/bin/opencode /usr/local/bin/opencode 2>/dev/null || cp /home/agent/go/bin/opencode /usr/local/bin/opencode 2>/dev/null || echo ""OpenCode binary location varies""

USER agent
WORKDIR /workspace

ENV CODEX_FORMAT=json \
    CODEX_MODEL=gpt-4o \
    OPENCODE_OUTPUT_ENVELOPE=true

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD node --version && python --version && dotnet --version || exit 1

CMD [""/bin/bash""]
",


        ["Node + Codex"] = @"FROM node:20-slim

RUN apt-get update && apt-get install -y \
    git \
    curl \
    && rm -rf /var/lib/apt/lists/*

RUN npm install -g @opencode/cli typescript

WORKDIR /workspace

CMD [""node""]",

        ["Go + Tools"] = @"FROM golang:1.22-alpine

RUN apk add --no-cache \
    git \
    curl \
    bash

WORKDIR /workspace

CMD [""/bin/bash""]",

        ["Rust Dev"] = @"FROM rust:1.75-slim

RUN apt-get update && apt-get install -y \
    git \
    curl \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /workspace

CMD [""/bin/bash""]",

        ["Minimal Alpine"] = @"FROM alpine:3.19

RUN apk add --no-cache \
    bash \
    git \
    curl

WORKDIR /workspace

CMD [""/bin/bash""]"
    };

    private StandaloneEditorConstructionOptions EditorOptions(StandaloneCodeEditor editor) => new()
    {
        Language = "dockerfile",
        Theme = MonacoTheme,
        AutomaticLayout = true,
        Minimap = new EditorMinimapOptions { Enabled = false },
        FontSize = 13,
        TabSize = 4,
        ScrollBeyondLastLine = false,
        Value = _dockerfileContent
    };

    protected override async Task OnInitializedAsync()
    {
        _dockerfileContent = _templates[_selectedTemplate];
        await UpdateDependencyMatrixAsync();
        await RefreshImagesAsync();
    }

    private async Task OnTemplateChangedAsync(string template)
    {
        _selectedTemplate = template;
        if (_templates.TryGetValue(template, out var content))
        {
            _dockerfileContent = content;
            if (_dockerfileEditor is not null)
                await _dockerfileEditor.SetValue(_dockerfileContent);
            await UpdateDependencyMatrixAsync();
        }
    }

    private async Task BuildImageAsync()
    {
        if (_dockerfileEditor is not null)
            _dockerfileContent = await _dockerfileEditor.GetValue();
        await UpdateDependencyMatrixAsync();

        if (string.IsNullOrWhiteSpace(_dockerfileContent) || string.IsNullOrWhiteSpace(_imageTag))
        {
            Snackbar.Add("Please provide both Dockerfile content and image tag", Severity.Warning);
            return;
        }

        _isBuilding = true;
        _buildResult = null;
        _buildLogs.Clear();
        StateHasChanged();

        try
        {
            _buildResult = await ImageBuilderService.BuildImageAsync(
                _dockerfileContent,
                _imageTag,
                logLine =>
                {
                    _buildLogs.Add(logLine);
                    InvokeAsync(StateHasChanged);
                },
                CancellationToken.None);

            if (_buildResult.Success)
            {
                Snackbar.Add($"Successfully built image: {_buildResult.ImageId}", Severity.Success);
                await RefreshImagesAsync();
            }
            else
            {
                Snackbar.Add("Build failed. Check logs for details.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Build error: {ex.Message}", Severity.Error);
            _buildLogs.Add($"Exception: {ex.Message}");
        }
        finally
        {
            _isBuilding = false;
            StateHasChanged();
        }
    }

    private async Task RefreshImagesAsync()
    {
        try
        {
            _images = await ImageBuilderService.ListImagesAsync(null, CancellationToken.None);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to refresh images: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteImageAsync(string tag)
    {
        try
        {
            var deleted = await ImageBuilderService.DeleteImageAsync(tag, CancellationToken.None);
            if (deleted)
            {
                Snackbar.Add($"Deleted image: {tag}", Severity.Success);
                await RefreshImagesAsync();
            }
            else
            {
                Snackbar.Add($"Failed to delete image: {tag}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting image: {ex.Message}", Severity.Error);
        }
    }

    private async Task GenerateDockerfileAsync()
    {
        try
        {
            var request = new DockerfileGenerationRequest(
                _aiDescription,
                _aiBaseImage,
                _aiRuntimes.ToArray(),
                _aiTools.ToArray(),
                _aiHarnesses.ToArray(),
                _aiTools.Contains("git"),
                _aiIncludeDockerCli,
                0);

            _dockerfileContent = ImageBuilderService.GenerateDockerfile(request);
            _selectedTemplate = string.Empty;
            if (_dockerfileEditor is not null)
                await _dockerfileEditor.SetValue(_dockerfileContent);
            await UpdateDependencyMatrixAsync();
            _aiError = null;
            Snackbar.Add("Dockerfile generated from template! Review and customize as needed.", Severity.Info);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to generate Dockerfile: {ex.Message}", Severity.Error);
        }
    }

    private async Task GenerateDockerfileWithAiAsync()
    {
        if (string.IsNullOrWhiteSpace(_aiDescription))
        {
            Snackbar.Add("Please describe your container requirements", Severity.Warning);
            return;
        }

        _isAiGenerating = true;
        _aiError = null;
        StateHasChanged();

        try
        {
            var llmTornadoSecret = await Store.GetProviderSecretAsync("global", "llmtornado", CancellationToken.None);
            string? apiKey = null;

            if (llmTornadoSecret != null && !string.IsNullOrWhiteSpace(llmTornadoSecret.EncryptedValue))
            {
                apiKey = SecretCrypto.Decrypt(llmTornadoSecret.EncryptedValue);
            }

            var result = await ImageBuilderService.GenerateDockerfileWithAiAsync(_aiDescription, apiKey, CancellationToken.None);

            if (result.Success)
            {
                _dockerfileContent = result.Dockerfile;
                _selectedTemplate = string.Empty;
                if (_dockerfileEditor is not null)
                    await _dockerfileEditor.SetValue(_dockerfileContent);
                await UpdateDependencyMatrixAsync();
                Snackbar.Add("Dockerfile generated by AI! Review and customize as needed.", Severity.Success);
            }
            else
            {
                _aiError = result.Error;
                Snackbar.Add(result.Error ?? "AI generation failed", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            _aiError = ex.Message;
            Snackbar.Add($"AI generation error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAiGenerating = false;
            StateHasChanged();
        }
    }

    private async Task ApplyHardeningPassAsync()
    {
        if (_dockerfileEditor is not null)
        {
            _dockerfileContent = await _dockerfileEditor.GetValue();
        }

        if (string.IsNullOrWhiteSpace(_dockerfileContent))
        {
            Snackbar.Add("Please provide a Dockerfile before hardening.", Severity.Warning);
            return;
        }

        _isHardening = true;
        _aiError = null;
        StateHasChanged();

        try
        {
            _dockerfileContent = ImageBuilderService.HardenDockerfile(_dockerfileContent);
            _selectedTemplate = string.Empty;
            if (_dockerfileEditor is not null)
            {
                await _dockerfileEditor.SetValue(_dockerfileContent);
            }

            await UpdateDependencyMatrixAsync();
            Snackbar.Add("Applied hardening pass. Review non-root user, workspace permissions, and healthcheck additions.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Hardening pass failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isHardening = false;
            StateHasChanged();
        }
    }

    private Task UpdateDependencyMatrixAsync()
    {
        _dependencyMatrix = string.IsNullOrWhiteSpace(_dockerfileContent)
            ? null
            : ImageBuilderService.AnalyzeDependencyMatrix(_dockerfileContent);
        return Task.CompletedTask;
    }

    private static string FormatDependencyValues(IEnumerable<string>? values)
    {
        if (values is null || !values.Any())
        {
            return "None detected";
        }

        return string.Join(", ", values);
    }

    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}

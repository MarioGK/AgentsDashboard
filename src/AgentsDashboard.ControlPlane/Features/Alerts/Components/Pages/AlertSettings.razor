@page "/settings/alerts"
@layout SettingsLayout
@rendermode InteractiveServer
@inject IOrchestratorStore Store
@inject IDialogService DialogService
@inject ISnackbar Snackbar

@namespace AgentsDashboard.ControlPlane.Components.Pages
<PageTitle>Alert Settings - AgentsDashboard</PageTitle>

<MudStack Row AlignItems="AlignItems.Center" Class="mb-4">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
        <MudText Typo="Typo.h4">Alert Settings</MudText>
        <SettingsHintIcon Text="Configure threshold-driven alert rules and review recent alert activity." />
    </MudStack>
    <MudSpacer />
    <MudTooltip Text="Create a new rule that can trigger notifications or webhook calls.">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Add"
                   OnClick="OpenAddRuleDialog">
            New Alert Rule
        </MudButton>
    </MudTooltip>
</MudStack>

<MudPaper Elevation="2" Class="mb-4">
    <MudTable Items="@_rules" Hover Dense Striped>
        <ToolBarContent>
            <MudText Typo="Typo.h6">Alert Rules</MudText>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Threshold</MudTh>
            <MudTh>Window</MudTh>
            <MudTh>Webhook</MudTh>
            <MudTh>Status</MudTh>
            <MudTh>Actions</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Name">@context.Name</MudTd>
            <MudTd DataLabel="Type">
                <MudChip T="string" Size="Size.Small" Color="GetRuleTypeColor(context.RuleType)">
                    @GetRuleTypeDisplayName(context.RuleType)
                </MudChip>
            </MudTd>
            <MudTd DataLabel="Threshold">@context.Threshold</MudTd>
            <MudTd DataLabel="Window">@context.WindowMinutes min</MudTd>
            <MudTd DataLabel="Webhook">
                @if (!string.IsNullOrWhiteSpace(context.WebhookUrl))
                {
                    <MudIcon Icon="@Icons.Material.Filled.Check" Size="Size.Small" Color="Color.Success" />
                }
                else
                {
                    <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" Color="Color.Default" />
                }
            </MudTd>
            <MudTd DataLabel="Status">
                <MudChip T="string" Size="Size.Small" Color="@(context.Enabled ? Color.Success : Color.Default)">
                    @(context.Enabled ? "Enabled" : "Disabled")
                </MudChip>
            </MudTd>
            <MudTd DataLabel="Actions">
                <MudTooltip Text="Edit this rule">
                    <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small"
                                   OnClick="() => OpenEditRuleDialog(context)" />
                </MudTooltip>
                <MudTooltip Text="Delete this rule">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error"
                                   OnClick="() => DeleteRule(context.Id)" />
                </MudTooltip>
            </MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
</MudPaper>

<MudPaper Elevation="2">
    <MudTimeline TimelinePosition="TimelinePosition.Start" TimelineOrientation="TimelineOrientation.Vertical">
        <MudTimelineItem Color="Color.Primary" Size="Size.Small" Elevation="2">
            <ItemOpposite>
                <MudText Typo="Typo.h6">Recent Alert Events</MudText>
            </ItemOpposite>
        </MudTimelineItem>

        @foreach (var evt in _events)
        {
            <MudTimelineItem Color="@(evt.Resolved ? Color.Success : Color.Warning)" Size="Size.Small">
                <ItemOpposite>
                    <MudText Typo="Typo.body2" Color="Color.Default">
                        @evt.FiredAtUtc.ToLocalTime().ToString("g")
                    </MudText>
                </ItemOpposite>
                <ItemContent>
                    <MudCard Elevation="3">
                        <MudCardContent>
                            <MudStack Row AlignItems="AlignItems.Center">
                                <MudText Typo="Typo.subtitle2">@evt.RuleName</MudText>
                                <MudSpacer />
                                @if (evt.Resolved)
                                {
                                    <MudChip T="string" Size="Size.Small" Color="Color.Success">Resolved</MudChip>
                                }
                            </MudStack>
                            <MudText Typo="Typo.body2">@evt.Message</MudText>
                        </MudCardContent>
                    </MudCard>
                </ItemContent>
            </MudTimelineItem>
        }

        @if (_events.Count == 0)
        {
            <MudTimelineItem Color="Color.Default" Size="Size.Small">
                <ItemContent>
                    <MudText Typo="Typo.body2" Color="Color.Default">No recent alert events</MudText>
                </ItemContent>
            </MudTimelineItem>
        }
    </MudTimeline>
</MudPaper>

@code {
    private List<AlertRuleDocument> _rules = [];
    private List<AlertEventDocument> _events = [];

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        _rules = await Store.ListAlertRulesAsync(CancellationToken.None);
        _events = await Store.ListRecentAlertEventsAsync(50, CancellationToken.None);
    }

    private async Task OpenAddRuleDialog()
    {
        var parameters = new DialogParameters<AlertRuleDialog>
        {
            { x => x.IsEdit, false }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<AlertRuleDialog>("New Alert Rule", parameters, options);
        var result = await dialog.Result;

        if (result is not null && !result.Canceled && result.Data is AlertRuleDocument newRule)
        {
            await Store.CreateAlertRuleAsync(newRule, CancellationToken.None);
            await LoadAsync();
            Snackbar.Add("Alert rule created", Severity.Success);
        }
    }

    private async Task OpenEditRuleDialog(AlertRuleDocument rule)
    {
        var parameters = new DialogParameters<AlertRuleDialog>
        {
            { x => x.IsEdit, true },
            { x => x.Rule, rule }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<AlertRuleDialog>("Edit Alert Rule", parameters, options);
        var result = await dialog.Result;

        if (result is not null && !result.Canceled && result.Data is AlertRuleDocument updatedRule)
        {
            await Store.UpdateAlertRuleAsync(rule.Id, updatedRule, CancellationToken.None);
            await LoadAsync();
            Snackbar.Add("Alert rule updated", Severity.Success);
        }
    }

    private async Task DeleteRule(string ruleId)
    {
        var confirm = await DialogService.ShowMessageBox(
            "Confirm Delete",
            "Are you sure you want to delete this alert rule?",
            yesText: "Delete", cancelText: "Cancel");

        if (confirm == true)
        {
            await Store.DeleteAlertRuleAsync(ruleId, CancellationToken.None);
            await LoadAsync();
            Snackbar.Add("Alert rule deleted", Severity.Success);
        }
    }

    private static string GetRuleTypeDisplayName(AlertRuleType ruleType) => ruleType switch
    {
        AlertRuleType.MissingHeartbeat => "Missing Heartbeat",
        AlertRuleType.FailureRateSpike => "Failure Rate Spike",
        AlertRuleType.QueueBacklog => "Queue Backlog",
        AlertRuleType.RepeatedPrFailures => "Repeated PR Failures",
        _ => ruleType.ToString()
    };

    private static Color GetRuleTypeColor(AlertRuleType ruleType) => ruleType switch
    {
        AlertRuleType.MissingHeartbeat => Color.Warning,
        AlertRuleType.FailureRateSpike => Color.Error,
        AlertRuleType.QueueBacklog => Color.Info,
        AlertRuleType.RepeatedPrFailures => Color.Warning,
        _ => Color.Default
    };
}

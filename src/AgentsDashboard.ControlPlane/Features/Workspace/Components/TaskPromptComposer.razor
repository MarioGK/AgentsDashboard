@namespace AgentsDashboard.ControlPlane.Components.Shared
@implements IAsyncDisposable

@using System.IO
@using Microsoft.JSInterop
@inject IJSRuntime JS

<div class="workspace-composer-surface">
    <div class="workspace-composer-wrap">
        <InputFile id="@_fileInputId"
                   class="workspace-hidden-file-input"
                   data-testid="workspace-composer-file-input"
                   OnChange="OnFileUploadChangedAsync"
                   accept="image/png,image/jpeg,image/webp,image/gif"
                   multiple />

        <div class="workspace-composer-topbar">
            <div class="workspace-composer-topbar-left">
                <MudTooltip Text="Upload image">
                    <label for="@_fileInputId"
                           class="workspace-composer-icon-action workspace-composer-icon-action-upload @(Disabled ? "workspace-composer-icon-action-disabled" : string.Empty)"
                           data-testid="workspace-composer-upload-trigger">
                        <MudIcon Icon="@Icons.Material.Filled.Upload" Size="Size.Small" />
                    </label>
                </MudTooltip>

                @if (_images.Count == 0)
                {
                    <span class="workspace-composer-attachments-empty">No files</span>
                }
                else
                {
                    @foreach (var image in _images)
                    {
                        <span class="workspace-composer-file-chip" title="@image.FileName">
                            <MudIcon Icon="@Icons.Material.Filled.Image" Size="Size.Small" />
                            <span class="workspace-composer-file-chip-name">@image.FileName</span>
                            <MudIconButton Icon="@Icons.Material.Filled.Close"
                                           Size="Size.Small"
                                           Class="workspace-composer-file-chip-close"
                                           OnClick="() => RemoveImageAsync(image.Id)"
                                           Disabled="@Disabled" />
                        </span>
                    }
                }
            </div>

            <div class="workspace-composer-topbar-right">
                @if (OnImprove.HasDelegate)
                {
                    <MudTooltip Text="Improve prompt">
                        <MudIconButton Icon="@Icons.Material.Filled.Tune"
                                       Size="Size.Small"
                                       Class="workspace-composer-action-button"
                                       OnClick="TriggerImproveAsync"
                                       Disabled="@Disabled" />
                    </MudTooltip>
                }

                @if (OnGenerate.HasDelegate)
                {
                    <MudTooltip Text="Generate prompt from context">
                        <MudIconButton Icon="@Icons.Material.Filled.AutoAwesome"
                                       Size="Size.Small"
                                       Class="workspace-composer-action-button workspace-composer-generate-action"
                                       OnClick="TriggerGenerateAsync"
                                       Disabled="@Disabled" />
                    </MudTooltip>
                }

                <MudTooltip Text="Clear prompt and files">
                    <MudIconButton Icon="@Icons.Material.Filled.Clear"
                                   Size="Size.Small"
                                   Class="workspace-composer-action-button"
                                   OnClick="ClearComposerAsync"
                                   Disabled="@(Disabled || !CanClearComposer)"
                                   data-testid="workspace-composer-clear" />
                </MudTooltip>
            </div>
        </div>

        @if (ShowGhostSuggestion)
        {
            <div class="workspace-composer-ghost-layer" aria-hidden="true">
                <span class="workspace-composer-ghost-typed">@Value</span><span class="workspace-composer-ghost-suggestion">@GhostSuffix</span>
            </div>
        }

        <textarea id="@InputId"
                  class="workspace-composer-input"
                  data-testid="workspace-composer-input"
                  rows="@Rows"
                  value="@Value"
                  @oninput="OnInputChangedAsync"
                  @onkeydown="OnKeyDownAsync"
                  disabled="@Disabled"></textarea>

        @if (ShowSubmitButton && OnSubmit.HasDelegate)
        {
            <div class="workspace-composer-send-button-anchor">
                <MudTooltip Text="@SubmitTooltip">
                    <MudIconButton Icon="@Icons.Material.Filled.Send"
                                   Size="Size.Small"
                                   Class="workspace-composer-send-button"
                                   OnClick="SubmitAsync"
                                   Disabled="@(!CanSubmit)"
                                   data-testid="workspace-composer-send" />
                </MudTooltip>
            </div>
        }
    </div>

    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="workspace-composer-helper-text">@HelperText</MudText>
</div>

@code {
    [Parameter, EditorRequired] public string InputId { get; set; } = string.Empty;
    [Parameter] public string Value { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public IReadOnlyList<WorkspaceImageInput> Images { get; set; } = [];
    [Parameter] public EventCallback<IReadOnlyList<WorkspaceImageInput>> ImagesChanged { get; set; }
    [Parameter] public EventCallback<KeyboardEventArgs> OnKeyDown { get; set; }
    [Parameter] public EventCallback<string> OnValidationError { get; set; }
    [Parameter] public EventCallback OnImprove { get; set; }
    [Parameter] public EventCallback OnGenerate { get; set; }
    [Parameter] public bool ShowGhostSuggestion { get; set; }
    [Parameter] public string GhostSuffix { get; set; } = string.Empty;
    [Parameter] public string HelperText { get; set; } = "Enter to send. Shift+Enter inserts a new line. Paste or upload images.";
    [Parameter] public bool ShowSubmitButton { get; set; }
    [Parameter] public string SubmitTooltip { get; set; } = "Send";
    [Parameter] public EventCallback OnSubmit { get; set; }
    [Parameter] public int Rows { get; set; } = 6;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string PasteBridgeKey { get; set; } = string.Empty;
    [Parameter] public int MaxImages { get; set; } = 6;
    [Parameter] public long MaxImageBytes { get; set; } = 8L * 1024L * 1024L;
    [Parameter] public int MaxAutoHeightPx { get; set; } = 240;

    private static readonly HashSet<string> s_allowedMimeTypes =
    [
        "image/png",
        "image/jpeg",
        "image/webp",
        "image/gif",
    ];

    private static readonly Dictionary<string, string> s_extensionToMimeType = new(StringComparer.OrdinalIgnoreCase)
    {
        [".png"] = "image/png",
        [".jpg"] = "image/jpeg",
        [".jpeg"] = "image/jpeg",
        [".webp"] = "image/webp",
        [".gif"] = "image/gif",
    };

    private readonly string _fileInputId = $"composer-file-{Guid.NewGuid():N}";
    private List<WorkspaceImageInput> _images = [];
    private IJSObjectReference? _workspaceJsModule;
    private DotNetObjectReference<TaskPromptComposer>? _dotNetRef;
    private string? _pasteBridgeHandle;

    private bool CanClearComposer => !string.IsNullOrEmpty(Value) || _images.Count > 0;
    private bool CanSubmit => !Disabled && (!string.IsNullOrWhiteSpace(Value) || _images.Count > 0);

    protected override void OnParametersSet()
    {
        _images = Images.ToList();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_workspaceJsModule is null)
        {
            _workspaceJsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./workspace.js");
            _dotNetRef = DotNetObjectReference.Create(this);
        }

        if (_workspaceJsModule is not null &&
            _dotNetRef is not null &&
            _pasteBridgeHandle is null &&
            !string.IsNullOrWhiteSpace(InputId))
        {
            _pasteBridgeHandle = await _workspaceJsModule.InvokeAsync<string?>(
                "registerComposerImagePasteBridge",
                InputId,
                _dotNetRef,
                PasteBridgeKey);
        }

        await AdjustInputHeightAsync();
    }

    private async Task OnInputChangedAsync(ChangeEventArgs args)
    {
        await ValueChanged.InvokeAsync(args.Value?.ToString() ?? string.Empty);
        await AdjustInputHeightAsync();
    }

    private async Task OnKeyDownAsync(KeyboardEventArgs args)
    {
        if (OnKeyDown.HasDelegate)
        {
            await OnKeyDown.InvokeAsync(args);
        }
    }

    private async Task TriggerImproveAsync()
    {
        if (!Disabled && OnImprove.HasDelegate)
        {
            await OnImprove.InvokeAsync();
        }
    }

    private async Task TriggerGenerateAsync()
    {
        if (!Disabled && OnGenerate.HasDelegate)
        {
            await OnGenerate.InvokeAsync();
        }
    }

    private async Task ClearComposerAsync()
    {
        if (Disabled || !CanClearComposer)
        {
            return;
        }

        if (!string.IsNullOrEmpty(Value))
        {
            await ValueChanged.InvokeAsync(string.Empty);
        }

        if (_images.Count > 0)
        {
            _images.Clear();
            await ImagesChanged.InvokeAsync(_images.ToList());
        }

        await AdjustInputHeightAsync();
    }

    private async Task OnFileUploadChangedAsync(InputFileChangeEventArgs args)
    {
        if (Disabled)
        {
            return;
        }

        var selected = args.GetMultipleFiles(MaxImages);
        var incoming = new List<WorkspaceImageInput>(selected.Count);

        foreach (var file in selected)
        {
            var normalizedMimeType = NormalizeImageMimeType(file.ContentType, file.Name);
            if (!s_allowedMimeTypes.Contains(normalizedMimeType))
            {
                await NotifyValidationErrorAsync($"Unsupported image type '{file.ContentType}'.");
                continue;
            }

            if (file.Size > MaxImageBytes)
            {
                await NotifyValidationErrorAsync($"Image '{file.Name}' exceeds {MaxImageBytes / (1024 * 1024)} MB.");
                continue;
            }

            await using var read = file.OpenReadStream(MaxImageBytes);
            await using var memory = new MemoryStream();
            await read.CopyToAsync(memory);
            var bytes = memory.ToArray();
            var payload = Convert.ToBase64String(bytes);
            var dataUrl = $"data:{normalizedMimeType};base64,{payload}";

            incoming.Add(new WorkspaceImageInput(
                Id: Guid.NewGuid().ToString("N"),
                FileName: file.Name,
                MimeType: normalizedMimeType,
                SizeBytes: bytes.Length,
                DataUrl: dataUrl));
        }

        await AppendImagesAsync(incoming);
    }

    [JSInvokable]
    public async Task OnComposerImagesPastedFromJs(string bridgeKey, IReadOnlyList<PastedImagePayload> pastedImages)
    {
        if (Disabled ||
            !string.Equals(bridgeKey, PasteBridgeKey, StringComparison.Ordinal) ||
            pastedImages.Count == 0)
        {
            return;
        }

        var incoming = new List<WorkspaceImageInput>(pastedImages.Count);
        foreach (var pasted in pastedImages)
        {
            var mimeType = NormalizeImageMimeType(pasted.MimeType, pasted.FileName);
            if (!s_allowedMimeTypes.Contains(mimeType))
            {
                await NotifyValidationErrorAsync($"Unsupported image type '{mimeType}'.");
                continue;
            }

            if (pasted.SizeBytes > MaxImageBytes)
            {
                await NotifyValidationErrorAsync($"Image '{pasted.FileName}' exceeds {MaxImageBytes / (1024 * 1024)} MB.");
                continue;
            }

            if (string.IsNullOrWhiteSpace(pasted.DataUrl))
            {
                continue;
            }

            incoming.Add(new WorkspaceImageInput(
                Id: string.IsNullOrWhiteSpace(pasted.Id) ? Guid.NewGuid().ToString("N") : pasted.Id,
                FileName: string.IsNullOrWhiteSpace(pasted.FileName) ? "pasted-image" : pasted.FileName,
                MimeType: mimeType,
                SizeBytes: pasted.SizeBytes,
                DataUrl: pasted.DataUrl,
                Width: pasted.Width,
                Height: pasted.Height));
        }

        await AppendImagesAsync(incoming);
        await InvokeAsync(StateHasChanged);
    }

    private static string NormalizeImageMimeType(string? mimeType, string fileName)
    {
        var normalizedMimeType = (mimeType ?? string.Empty).Trim().ToLowerInvariant();

        if (string.Equals(normalizedMimeType, "image/jpg", StringComparison.OrdinalIgnoreCase))
        {
            return "image/jpeg";
        }

        if (normalizedMimeType.Length > 0)
        {
            return normalizedMimeType;
        }

        var extension = Path.GetExtension(fileName ?? string.Empty);
        return s_extensionToMimeType.TryGetValue(extension, out var inferredMimeType)
            ? inferredMimeType
            : string.Empty;
    }

    private async Task AppendImagesAsync(IReadOnlyList<WorkspaceImageInput> incoming)
    {
        if (incoming.Count == 0)
        {
            return;
        }

        var availableSlots = Math.Max(0, MaxImages - _images.Count);
        if (availableSlots == 0)
        {
            await NotifyValidationErrorAsync($"Maximum of {MaxImages} images reached.");
            return;
        }

        var accepted = incoming.Take(availableSlots).ToList();
        if (accepted.Count < incoming.Count)
        {
            await NotifyValidationErrorAsync($"Only {accepted.Count} image(s) were added due to limit {MaxImages}.");
        }

        _images.AddRange(accepted);
        await ImagesChanged.InvokeAsync(_images.ToList());
        await AdjustInputHeightAsync();
    }

    private async Task RemoveImageAsync(string imageId)
    {
        if (Disabled)
        {
            return;
        }

        var removed = _images.RemoveAll(image => string.Equals(image.Id, imageId, StringComparison.Ordinal));
        if (removed > 0)
        {
            await ImagesChanged.InvokeAsync(_images.ToList());
            await AdjustInputHeightAsync();
        }
    }

    private async Task SubmitAsync()
    {
        if (!CanSubmit || !OnSubmit.HasDelegate)
        {
            return;
        }

        await OnSubmit.InvokeAsync();
    }

    private async Task AdjustInputHeightAsync()
    {
        if (_workspaceJsModule is null || string.IsNullOrWhiteSpace(InputId))
        {
            return;
        }

        await _workspaceJsModule.InvokeVoidAsync("autoSizeTextarea", InputId, MaxAutoHeightPx);
    }

    private async Task NotifyValidationErrorAsync(string message)
    {
        if (OnValidationError.HasDelegate)
        {
            await OnValidationError.InvokeAsync(message);
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_workspaceJsModule is not null && _pasteBridgeHandle is not null)
            {
                await _workspaceJsModule.InvokeVoidAsync("unregisterComposerImagePasteBridge", _pasteBridgeHandle);
            }
        }
        catch
        {
        }

        _dotNetRef?.Dispose();

        if (_workspaceJsModule is not null)
        {
            try
            {
                await _workspaceJsModule.DisposeAsync();
            }
            catch
            {
            }
        }
    }

    public sealed class PastedImagePayload
    {
        public string Id { get; set; } = string.Empty;
        public string FileName { get; set; } = string.Empty;
        public string MimeType { get; set; } = string.Empty;
        public long SizeBytes { get; set; }
        public string DataUrl { get; set; } = string.Empty;
        public int? Width { get; set; }
        public int? Height { get; set; }
    }
}

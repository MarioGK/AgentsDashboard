@namespace AgentsDashboard.ControlPlane.Components.Pages
<script type="module" src="@Assets["Components/Pages/Runs/RunDetail.razor.js"]"></script>

@page "/settings/runs/{Id}"
@layout SettingsLayout
@rendermode InteractiveServer

@using System.Text.Json
@using AgentsDashboard.ControlPlane.Components.Shared

@inject IRepositoryStore RepositoryStore
@inject ITaskStore TaskStore
@inject IRunStore RunStore
@inject RunDispatcher Dispatcher
@inject IUiRealtimeBroker UiRealtimeBroker
@inject IRunStructuredViewService RunStructuredViewService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@implements IDisposable

<PageTitle>Run @Id?[..8] - AgentsDashboard</PageTitle>

@if (_run is null)
{
    <MudProgressLinear Indeterminate="true" />
}
else
{
    <MudStack Row AlignItems="AlignItems.Center" Class="mb-3">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" Href="/settings/runs" />
        <MudText Typo="Typo.h4">Run @_run.Id[..Math.Min(8, _run.Id.Length)]</MudText>
        <MudChip T="string" Color="@GetRunStateColor(_run.State)" Class="ml-2">@GetRunStateLabel(_run.State)</MudChip>
        <MudChip T="string" Variant="Variant.Outlined">@GetExecutionModeLabel(_run.ExecutionMode)</MudChip>
        <MudChip T="string" Variant="Variant.Outlined">@GetRunHarness(_run)</MudChip>
        @if (_run.Attempt > 1)
        {
            <MudChip T="string" Variant="Variant.Outlined">Attempt @_run.Attempt</MudChip>
        }
        <MudSpacer />
        @if (_run.State is RunState.PendingApproval)
        {
            <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Filled.CheckCircle" OnClick="ApproveRunAsync">Approve</MudButton>
            <MudButton Variant="Variant.Outlined" Color="Color.Error" StartIcon="@Icons.Material.Filled.Cancel" OnClick="RejectRunAsync">Reject</MudButton>
        }
        @if (_run.State is RunState.Queued or RunState.Running or RunState.PendingApproval)
        {
            <MudButton Variant="Variant.Outlined" Color="Color.Error" StartIcon="@Icons.Material.Filled.Stop" OnClick="CancelRunAsync">Cancel</MudButton>
        }
        <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="RefreshAsync" />
    </MudStack>

    <MudGrid>
        <MudItem xs="12" lg="8">
            <MudGrid Class="mb-3">
                <MudItem xs="6" md="2">
                    <MudPaper Class="pa-2">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Thinking</MudText>
                        <MudText Typo="Typo.h6">@_structuredView.Thinking.Count</MudText>
                    </MudPaper>
                </MudItem>
                <MudItem xs="6" md="2">
                    <MudPaper Class="pa-2">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Tools</MudText>
                        <MudText Typo="Typo.h6">@Math.Max(_toolProjections.Count, _structuredView.Tools.Count)</MudText>
                    </MudPaper>
                </MudItem>
                <MudItem xs="6" md="2">
                    <MudPaper Class="pa-2">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Diff</MudText>
                        <MudText Typo="Typo.h6">@RunDiffParser.Parse(GetResolvedDiffPatch()).Count</MudText>
                    </MudPaper>
                </MudItem>
                <MudItem xs="6" md="2">
                    <MudPaper Class="pa-2">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Summary</MudText>
                        <MudText Typo="Typo.h6">@(string.IsNullOrWhiteSpace(_run.Summary) ? "-" : "1")</MudText>
                    </MudPaper>
                </MudItem>
                <MudItem xs="6" md="2">
                    <MudPaper Class="pa-2">
                        <MudText Typo="Typo.caption" Color="Color.Secondary">Errors</MudText>
                        <MudText Typo="Typo.h6">@GetErrorCount()</MudText>
                    </MudPaper>
                </MudItem>
            </MudGrid>

            <MudTabs Elevation="2" Rounded ApplyEffectsToContainer>
                <MudTabPanel Text="Timeline" Icon="@Icons.Material.Filled.Timeline">
                    <MudPaper Class="pa-3">
                        @if (_structuredView.Timeline.Count == 0)
                        {
                            <MudText Color="Color.Secondary">No structured timeline events.</MudText>
                        }
                        else
                        {
                            <MudTimeline TimelinePosition="TimelinePosition.Start" TimelineOrientation="TimelineOrientation.Vertical">
                                @foreach (var item in _structuredView.Timeline.TakeLast(300))
                                {
                                    <MudTimelineItem Color="Color.Info" Size="Size.Small">
                                        <ItemOpposite>
                                            <MudText Typo="Typo.caption">#@item.Sequence</MudText>
                                            <MudText Typo="Typo.caption">@item.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")</MudText>
                                        </ItemOpposite>
                                        <ItemContent>
                                            <MudPaper Class="pa-2" Elevation="0">
                                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@item.Category</MudChip>
                                                <MudText Typo="Typo.body2" Class="mt-1">@item.Message</MudText>
                                            </MudPaper>
                                        </ItemContent>
                                    </MudTimelineItem>
                                }
                            </MudTimeline>
                        }
                    </MudPaper>
                </MudTabPanel>

                <MudTabPanel Text="Thinking" Icon="@Icons.Material.Filled.Psychology">
                    <MudPaper Class="pa-3">
                        @if (_structuredView.Thinking.Count == 0)
                        {
                            <MudText Color="Color.Secondary">No thinking traces captured.</MudText>
                        }
                        else
                        {
                            @foreach (var item in _structuredView.Thinking.TakeLast(120))
                            {
                                <MudPaper Class="pa-2 mb-2" Elevation="0">
                                    <MudStack Row AlignItems="AlignItems.Center">
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">#@item.Sequence</MudChip>
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@item.Category</MudChip>
                                        <MudSpacer />
                                        <MudText Typo="Typo.caption">@item.TimestampUtc.ToLocalTime().ToString("g")</MudText>
                                    </MudStack>
                                    <pre class="run-detail-pre">@item.Content</pre>
                                </MudPaper>
                            }
                        }
                    </MudPaper>
                </MudTabPanel>

                <MudTabPanel Text="Tools" Icon="@Icons.Material.Filled.Build">
                    <MudPaper Class="pa-3">
                        @if (_toolProjections.Count == 0 && _structuredView.Tools.Count == 0)
                        {
                            <MudText Color="Color.Secondary">No tool calls captured.</MudText>
                        }
                        else if (_toolProjections.Count > 0)
                        {
                            <MudSimpleTable Dense Hover Striped>
                                <thead>
                                    <tr>
                                        <th>Tool</th>
                                        <th>State</th>
                                        <th>Call</th>
                                        <th>When</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var tool in _toolProjections.TakeLast(200))
                                    {
                                        <tr>
                                            <td>@tool.ToolName</td>
                                            <td>@tool.Status</td>
                                            <td>@(string.IsNullOrWhiteSpace(tool.ToolCallId) ? "-" : tool.ToolCallId)</td>
                                            <td>@tool.TimestampUtc.ToLocalTime().ToString("g")</td>
                                        </tr>
                                    }
                                </tbody>
                            </MudSimpleTable>
                        }
                        else
                        {
                            <MudSimpleTable Dense Hover Striped>
                                <thead>
                                    <tr>
                                        <th>Tool</th>
                                        <th>State</th>
                                        <th>Call</th>
                                        <th>When</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var tool in _structuredView.Tools.TakeLast(200))
                                    {
                                        <tr>
                                            <td>@tool.ToolName</td>
                                            <td>@tool.State</td>
                                            <td>@(string.IsNullOrWhiteSpace(tool.ToolCallId) ? "-" : tool.ToolCallId)</td>
                                            <td>@tool.TimestampUtc.ToLocalTime().ToString("g")</td>
                                        </tr>
                                    }
                                </tbody>
                            </MudSimpleTable>
                        }
                    </MudPaper>
                </MudTabPanel>

                        <MudTabPanel Text="Diff" Icon="@Icons.Material.Filled.Difference">
                    <MudPaper Class="pa-3">
                        <RunDiffViewer RunId="@_run.Id"
                                       Patch="@GetResolvedDiffPatch()"
                                       DiffStat="@GetResolvedDiffStat()"
                                       OpenFileBaseUrl="@($"/runs/{_run.Id}/app")" />
                    </MudPaper>
                </MudTabPanel>

                <MudTabPanel Text="Raw" Icon="@Icons.Material.Filled.DataObject">
                    <MudPaper Class="pa-3">
                        <MudStack Row Spacing="1" Class="mb-2">
                            <MudButton Variant="Variant.Outlined" Size="Size.Small" StartIcon="@Icons.Material.Filled.ContentCopy" OnClick="CopyRunJsonAsync">Copy JSON</MudButton>
                            <MudButton Variant="Variant.Outlined" Size="Size.Small" StartIcon="@Icons.Material.Filled.ContentCopy" OnClick="CopyPatchAsync">Copy Patch</MudButton>
                            <MudButton Variant="Variant.Outlined" Size="Size.Small" StartIcon="@Icons.Material.Filled.Share" OnClick="ExportRunShareBundleAsync">Export Share Bundle</MudButton>
                        </MudStack>

                        <MudText Typo="Typo.caption">Run Output JSON</MudText>
                        <pre class="run-detail-pre">@GetRunOutputJson()</pre>

                        <MudText Typo="Typo.caption" Class="mt-2">Structured Events (@_structuredEvents.Count)</MudText>
                        <pre class="run-detail-pre">@GetStructuredEventsJson()</pre>
                    </MudPaper>
                </MudTabPanel>

                <MudTabPanel Text="Logs" Icon="@Icons.Material.Filled.Terminal">
                    <MudPaper Class="pa-3 run-detail-log-pane">
                        @if (_logs.Count == 0)
                        {
                            <MudText Color="Color.Secondary">No logs yet.</MudText>
                        }
                        else
                        {
                            @foreach (var log in _logs.TakeLast(500))
                            {
                                <MudText Class="run-detail-log-line">[@log.TimestampUtc.ToString("HH:mm:ss")] @log.Message</MudText>
                            }
                        }
                    </MudPaper>
                </MudTabPanel>

                <MudTabPanel Text="Artifacts" Icon="@Icons.Material.Filled.Inventory">
                    <MudPaper Class="pa-3">
                        @if (_storedArtifacts.Count == 0 && _artifacts.Count == 0)
                        {
                            <MudText Color="Color.Secondary">No artifacts produced.</MudText>
                        }
                        else
                        {
                            <MudSimpleTable Dense Hover Striped>
                                <thead>
                                    <tr>
                                        <th>Artifact</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var artifact in _storedArtifacts)
                                    {
                                        <tr>
                                            <td>@artifact</td>
                                            <td>
                                                <MudIconButton Icon="@Icons.Material.Filled.Download" Size="Size.Small" OnClick="() => DownloadArtifactAsync(artifact)" />
                                            </td>
                                        </tr>
                                    }
                                    @foreach (var artifact in _artifacts.Where(a => !_storedArtifacts.Contains(a)))
                                    {
                                        <tr>
                                            <td>@artifact</td>
                                            <td><MudText Typo="Typo.caption" Color="Color.Secondary">Referenced only</MudText></td>
                                        </tr>
                                    }
                                </tbody>
                            </MudSimpleTable>
                        }
                    </MudPaper>
                </MudTabPanel>

            </MudTabs>
        </MudItem>

        <MudItem xs="12" lg="4">
            <MudPaper Class="pa-3">
                <MudStack Row AlignItems="AlignItems.Center" Class="mb-2">
                    <MudText Typo="Typo.h6">Fast Filters</MudText>
                    <MudSpacer />
                    <MudChip T="string" Variant="Variant.Outlined">@FilteredRuns.Count runs</MudChip>
                </MudStack>

                <MudStack Spacing="1" Class="mb-2">
                    <MudSelect T="string" Label="Mode" Variant="Variant.Outlined" Dense @bind-Value="_modeFilter">
                        <MudSelectItem T="string" Value="@("all")">All</MudSelectItem>
                        <MudSelectItem T="string" Value="@("default")">Default</MudSelectItem>
                        <MudSelectItem T="string" Value="@("plan")">Plan</MudSelectItem>
                        <MudSelectItem T="string" Value="@("review")">Review</MudSelectItem>
                    </MudSelect>

                    <MudSelect T="string" Label="Harness" Variant="Variant.Outlined" Dense @bind-Value="_harnessFilter">
                        <MudSelectItem T="string" Value="@("all")">All</MudSelectItem>
                        @foreach (var harness in AvailableHarnesses)
                        {
                            <MudSelectItem T="string" Value="@harness">@harness</MudSelectItem>
                        }
                    </MudSelect>

                    <MudSelect T="string" Label="State" Variant="Variant.Outlined" Dense @bind-Value="_stateFilter">
                        <MudSelectItem T="string" Value="@("all")">All</MudSelectItem>
                        @foreach (var state in Enum.GetValues<RunState>())
                        {
                            <MudSelectItem T="string" Value="@state.ToString()">@state</MudSelectItem>
                        }
                    </MudSelect>
                </MudStack>

                <MudDivider Class="mb-2" />

                @if (FilteredRuns.Count == 0)
                {
                    <MudText Color="Color.Secondary">No runs match these filters.</MudText>
                }
                else
                {
                    @foreach (var run in FilteredRuns)
                    {
                        <MudPaper Class="pa-2 mb-1" Elevation="0" Style="cursor: pointer;" @onclick="@(() => Navigation.NavigateTo($"/settings/runs/{run.Id}"))">
                            <MudStack Spacing="0">
                                <MudStack Row AlignItems="AlignItems.Center">
                                    <MudText Typo="Typo.caption">@run.Id[..Math.Min(8, run.Id.Length)]</MudText>
                                    <MudSpacer />
                                    <MudChip T="string" Size="Size.Small" Color="@GetRunStateColor(run.State)">@run.State</MudChip>
                                </MudStack>
                                <MudStack Row Spacing="1">
                                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@GetExecutionModeLabel(run.ExecutionMode)</MudChip>
                                    <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">@GetRunHarness(run)</MudChip>
                                </MudStack>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">@run.CreatedAtUtc.ToLocalTime().ToString("g")</MudText>
                            </MudStack>
                        </MudPaper>
                    }
                }
            </MudPaper>
        </MudItem>
    </MudGrid>
}

@code {
    [Parameter] public string? Id { get; set; }

    private RunDocument? _run;
    private List<RunDocument> _repositoryRuns = [];
    private readonly Dictionary<string, TaskDocument> _tasksById = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, RunDocument> _runsById = new(StringComparer.OrdinalIgnoreCase);
    private List<RunLogEvent> _logs = [];
    private List<string> _artifacts = [];
    private List<string> _storedArtifacts = [];
    private List<RunStructuredEventDocument> _structuredEvents = [];
    private List<RunToolProjectionDocument> _toolProjections = [];
    private RunDiffSnapshotDocument? _diffSnapshot;
    private RunStructuredViewSnapshot _structuredView = new(string.Empty, 0, [], [], [], null, DateTime.UtcNow);

    private IDisposable? _runLogSubscription;
    private IDisposable? _runStatusSubscription;
    private IDisposable? _structuredSubscription;
    private IDisposable? _diffSubscription;
    private IDisposable? _toolSubscription;

    private string _modeFilter = "all";
    private string _harnessFilter = "all";
    private string _stateFilter = "all";

    private List<RunDocument> FilteredRuns =>
        _repositoryRuns
            .Where(run => string.Equals(_modeFilter, "all", StringComparison.OrdinalIgnoreCase) ||
                          string.Equals(GetExecutionModeValue(run.ExecutionMode), _modeFilter, StringComparison.OrdinalIgnoreCase))
            .Where(run => string.Equals(_harnessFilter, "all", StringComparison.OrdinalIgnoreCase) ||
                          string.Equals(GetRunHarness(run), _harnessFilter, StringComparison.OrdinalIgnoreCase))
            .Where(run => string.Equals(_stateFilter, "all", StringComparison.OrdinalIgnoreCase) ||
                          string.Equals(run.State.ToString(), _stateFilter, StringComparison.OrdinalIgnoreCase))
            .OrderByDescending(run => run.CreatedAtUtc)
            .Take(60)
            .ToList();

    private List<string> AvailableHarnesses =>
        _repositoryRuns
            .Select(GetRunHarness)
            .Where(harness => !string.IsNullOrWhiteSpace(harness))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(harness => harness, StringComparer.OrdinalIgnoreCase)
            .ToList();

    protected override async Task OnInitializedAsync()
    {
        await LoadRunAsync();

        _runLogSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunLogChunkEvent>(logEvent =>
        {
            if (_run is null || logEvent.RunId != _run.Id)
            {
                return Task.CompletedTask;
            }

            _logs.Add(new RunLogEvent
            {
                RunId = logEvent.RunId,
                Level = logEvent.Level,
                Message = logEvent.Message,
                TimestampUtc = logEvent.Timestamp,
            });

            return InvokeAsync(StateHasChanged);
        });

        _runStatusSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunStatusChangedEvent>(async status =>
        {
            if (_run is null || status.RunId != _run.Id)
            {
                return;
            }

            await RefreshAsync();
        });

        _structuredSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunStructuredEventChangedEvent>(async evt =>
        {
            if (_run is null || evt.RunId != _run.Id)
            {
                return;
            }

            await RefreshStructuredAsync();
            await InvokeAsync(StateHasChanged);
        });

        _diffSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunDiffUpdatedEvent>(async evt =>
        {
            if (_run is null || evt.RunId != _run.Id)
            {
                return;
            }

            await RefreshStructuredAsync();
            await InvokeAsync(StateHasChanged);
        });

        _toolSubscription = UiRealtimeBroker.Subscribe<AgentsDashboard.Contracts.Features.Realtime.Models.Events.RunToolTimelineUpdatedEvent>(async evt =>
        {
            if (_run is null || evt.RunId != _run.Id)
            {
                return;
            }

            await RefreshStructuredAsync();
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task LoadRunAsync()
    {
        if (string.IsNullOrWhiteSpace(Id))
        {
            return;
        }

        _run = await RunStore.GetRunAsync(Id, CancellationToken.None);
        if (_run is null)
        {
            return;
        }

        _logs = await RunStore.ListRunLogsAsync(_run.Id, CancellationToken.None);
        _storedArtifacts = await RunStore.ListArtifactsAsync(_run.Id, CancellationToken.None);
        _structuredEvents = await RunStore.ListRunStructuredEventsAsync(_run.Id, 4000, CancellationToken.None);
        _toolProjections = await RunStore.ListRunToolProjectionsAsync(_run.Id, CancellationToken.None);
        _diffSnapshot = await RunStore.GetLatestRunDiffSnapshotAsync(_run.Id, CancellationToken.None);
        _structuredView = await RunStructuredViewService.GetViewAsync(_run.Id, CancellationToken.None);

        _repositoryRuns = await RunStore.ListRunsByRepositoryAsync(_run.RepositoryId, CancellationToken.None);
        _runsById.Clear();
        foreach (var run in _repositoryRuns)
        {
            _runsById[run.Id] = run;
        }

        var repositoryTasks = await TaskStore.ListTasksAsync(_run.RepositoryId, CancellationToken.None);
        _tasksById.Clear();
        foreach (var task in repositoryTasks)
        {
            _tasksById[task.Id] = task;
        }

        _artifacts = ParseReferencedArtifacts(_run.OutputJson);
    }

    private async Task RefreshAsync()
    {
        await LoadRunAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RefreshStructuredAsync()
    {
        if (_run is null)
        {
            return;
        }

        _structuredEvents = await RunStore.ListRunStructuredEventsAsync(_run.Id, 4000, CancellationToken.None);
        _toolProjections = await RunStore.ListRunToolProjectionsAsync(_run.Id, CancellationToken.None);
        _diffSnapshot = await RunStore.GetLatestRunDiffSnapshotAsync(_run.Id, CancellationToken.None);
        _structuredView = await RunStructuredViewService.GetViewAsync(_run.Id, CancellationToken.None);
    }

    private static List<string> ParseReferencedArtifacts(string outputJson)
    {
        if (string.IsNullOrWhiteSpace(outputJson))
        {
            return [];
        }

        try
        {
            var envelope = JsonSerializer.Deserialize<HarnessResultEnvelope>(outputJson);
            return envelope?.Artifacts ?? [];
        }
        catch
        {
            return [];
        }
    }

    private string GetRunHarness(RunDocument run)
    {
        if (_tasksById.TryGetValue(run.TaskId, out var task))
        {
            return task.Harness;
        }

        return "unknown";
    }

    private static string GetExecutionModeValue(HarnessExecutionMode mode)
    {
        return mode switch
        {
            HarnessExecutionMode.Plan => "plan",
            HarnessExecutionMode.Review => "review",
            _ => "default",
        };
    }

    private static string GetExecutionModeLabel(HarnessExecutionMode mode)
    {
        return mode switch
        {
            HarnessExecutionMode.Plan => "Plan",
            HarnessExecutionMode.Review => "Review",
            _ => "Default",
        };
    }

    private int GetErrorCount()
    {
        var logErrors = _logs.Count(log =>
            log.Level.Contains("error", StringComparison.OrdinalIgnoreCase) ||
            log.Message.Contains("error", StringComparison.OrdinalIgnoreCase));

        if (_run is not null && _run.State == RunState.Failed)
        {
            logErrors++;
        }

        return logErrors;
    }

    private string GetRunOutputJson()
    {
        if (_run is null || string.IsNullOrWhiteSpace(_run.OutputJson))
        {
            return "{}";
        }

        return _run.OutputJson;
    }

    private string GetStructuredEventsJson()
    {
        if (_structuredEvents.Count == 0)
        {
            return "[]";
        }

        return JsonSerializer.Serialize(_structuredEvents, new JsonSerializerOptions
        {
            WriteIndented = true,
        });
    }

    private string GetResolvedDiffPatch()
    {
        if (!string.IsNullOrWhiteSpace(_diffSnapshot?.DiffPatch))
        {
            return _diffSnapshot.DiffPatch;
        }

        if (!string.IsNullOrWhiteSpace(_structuredView.Diff?.DiffPatch))
        {
            return _structuredView.Diff.DiffPatch;
        }

        return string.Empty;
    }

    private string GetResolvedDiffStat()
    {
        if (!string.IsNullOrWhiteSpace(_diffSnapshot?.DiffStat))
        {
            return _diffSnapshot.DiffStat;
        }

        if (!string.IsNullOrWhiteSpace(_structuredView.Diff?.DiffStat))
        {
            return _structuredView.Diff.DiffStat;
        }

        return string.Empty;
    }

    private RunDocument? GetRunById(string runId)
    {
        return _runsById.TryGetValue(runId, out var run)
            ? run
            : null;
    }

    private async Task CopyRunJsonAsync()
    {
        await CopyTextAsync(GetRunOutputJson(), "Run JSON copied.");
    }

    private async Task CopyPatchAsync()
    {
        await CopyTextAsync(GetResolvedDiffPatch(), "Patch copied.");
    }

    private async Task ExportRunShareBundleAsync()
    {
        if (_run is null)
        {
            return;
        }

        var artifacts = await RunStore.ListArtifactsAsync(_run.Id, CancellationToken.None);
        var instructionStack = await RunStore.GetRunInstructionStackAsync(_run.Id, CancellationToken.None);
        var payload = new
        {
            exportedAtUtc = DateTime.UtcNow,
            run = _run,
            summary = _run.Summary,
            outputJson = _run.OutputJson,
            structuredEvents = _structuredEvents,
            toolProjections = _toolProjections,
            diff = new
            {
                stat = GetResolvedDiffStat(),
                patch = GetResolvedDiffPatch()
            },
            artifacts,
            instructionStack
        };

        var bundleJson = JsonSerializer.Serialize(payload, new JsonSerializerOptions
        {
            WriteIndented = true
        });

        await RunStore.UpsertRunShareBundleAsync(new RunShareBundleDocument
        {
            RunId = _run.Id,
            RepositoryId = _run.RepositoryId,
            TaskId = _run.TaskId,
            BundleJson = bundleJson,
            CreatedAtUtc = DateTime.UtcNow
        }, CancellationToken.None);

        await CopyTextAsync(bundleJson, "Run share bundle copied.");
    }

    private async Task CopyTextAsync(string text, string successMessage)
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text ?? string.Empty);
            Snackbar.Add(successMessage, Severity.Success);
        }
        catch
        {
            Snackbar.Add("Clipboard write failed.", Severity.Warning);
        }
    }

    private async Task CancelRunAsync()
    {
        if (_run is null)
        {
            return;
        }

        var priorState = _run.State;
        var taskId = _run.TaskId;

        await Dispatcher.CancelAsync(_run.Id, CancellationToken.None);
        var cancelled = await RunStore.MarkRunCancelledAsync(_run.Id, CancellationToken.None);
        if (cancelled is not null)
        {
            _run = cancelled;
        }

        if (priorState is RunState.Queued or RunState.PendingApproval)
        {
            await Dispatcher.DispatchNextQueuedRunForTaskAsync(taskId, CancellationToken.None);
        }

        await RefreshAsync();
    }

    private Task RetryRunAsync()
    {
        if (_run is null)
        {
            return Task.CompletedTask;
        }

        Navigation.NavigateTo($"/settings/runs/{_run.Id}");
        return Task.CompletedTask;
    }

    private async Task ApproveRunAsync()
    {
        if (_run is null || _run.State != RunState.PendingApproval)
        {
            return;
        }

        var approved = await RunStore.ApproveRunAsync(_run.Id, CancellationToken.None);
        if (approved is null)
        {
            return;
        }

        var task = await TaskStore.GetTaskAsync(approved.TaskId, CancellationToken.None);
        if (task is null)
        {
            _run = approved;
            return;
        }

        var repository = await RepositoryStore.GetRepositoryAsync(task.RepositoryId, CancellationToken.None);
        if (repository is null)
        {
            _run = approved;
            return;
        }

        await Dispatcher.DispatchAsync(repository, task, approved, CancellationToken.None);
        await RefreshAsync();
    }

    private async Task RejectRunAsync()
    {
        if (_run is null || _run.State != RunState.PendingApproval)
        {
            return;
        }

        var taskId = _run.TaskId;
        var rejected = await RunStore.RejectRunAsync(_run.Id, CancellationToken.None);
        if (rejected is not null)
        {
            _run = rejected;
            await Dispatcher.DispatchNextQueuedRunForTaskAsync(taskId, CancellationToken.None);
            await RefreshAsync();
        }
    }

    private async Task DownloadArtifactAsync(string artifact)
    {
        if (_run is null || string.IsNullOrWhiteSpace(artifact))
        {
            return;
        }

        await using var stream = await RunStore.GetArtifactAsync(_run.Id, artifact, CancellationToken.None);
        if (stream is null)
        {
            return;
        }

        using var memory = new MemoryStream();
        await stream.CopyToAsync(memory, CancellationToken.None);
        var payload = Convert.ToBase64String(memory.ToArray());
        await JS.InvokeVoidAsync("agentsDashboard.downloadBase64File", artifact, "application/octet-stream", payload);
    }

    private static Color GetRunStateColor(RunState state) => TaskRunStatusPresentation.FromRunState(state).Color;
    private static string GetRunStateLabel(RunState state) => TaskRunStatusPresentation.FromRunState(state).Label;

    public void Dispose()
    {
        _runLogSubscription?.Dispose();
        _runStatusSubscription?.Dispose();
        _structuredSubscription?.Dispose();
        _diffSubscription?.Dispose();
        _toolSubscription?.Dispose();
    }
}

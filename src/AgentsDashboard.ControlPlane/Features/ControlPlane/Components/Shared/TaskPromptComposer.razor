@namespace AgentsDashboard.ControlPlane.Components.Shared
@implements IAsyncDisposable
@using AgentsDashboard.ControlPlane.Services
@inject IJSRuntime JS

<div class="workspace-composer-surface">
    <div class="workspace-composer-wrap">
        @if (ShowGhostSuggestion)
        {
            <div class="workspace-composer-ghost-layer" aria-hidden="true">
                <span class="workspace-composer-ghost-typed">@Value</span><span class="workspace-composer-ghost-suggestion">@GhostSuffix</span>
            </div>
        }

        <textarea id="@InputId"
                  class="workspace-composer-input"
                  rows="@Rows"
                  value="@Value"
                  @oninput="OnInputChangedAsync"
                  @onkeydown="OnKeyDownAsync"
                  placeholder="@Placeholder"
                  disabled="@Disabled"></textarea>
    </div>

    <MudStack Row AlignItems="AlignItems.Center" Spacing="1" Class="workspace-image-toolbar">
        <MudText Typo="Typo.caption" Color="Color.Secondary">@HelperText</MudText>
        <MudSpacer />

        <InputFile id="@_fileInputId"
                   class="workspace-hidden-file-input"
                   OnChange="OnFileUploadChangedAsync"
                   accept="image/png,image/jpeg,image/webp,image/gif"
                   multiple />

        <label for="@_fileInputId" class="workspace-image-upload-label @(Disabled ? "workspace-image-upload-label-disabled" : string.Empty)">
            <MudIcon Icon="@Icons.Material.Filled.Upload" Size="Size.Small" />
            <span>Upload</span>
        </label>

        <MudButton Variant="Variant.Text"
                   Color="Color.Default"
                   Size="Size.Small"
                   OnClick="ClearImagesAsync"
                   Disabled="@(Disabled || _images.Count == 0)">
            Clear
        </MudButton>
    </MudStack>

    @if (_images.Count > 0)
    {
        <div class="workspace-image-strip">
            @foreach (var image in _images)
            {
                <MudPaper Class="workspace-image-card" Elevation="0">
                    <img src="@image.DataUrl" alt="@image.FileName" class="workspace-image-card-preview" />
                    <div class="workspace-image-card-meta">
                        <MudText Typo="Typo.caption">@image.FileName</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">@FormatSize(image.SizeBytes)</MudText>
                    </div>
                    <MudStack Row Spacing="0">
                        <MudIconButton Icon="@Icons.Material.Filled.ShortText"
                                       Size="Size.Small"
                                       Color="Color.Primary"
                                       OnClick="() => InsertImageReferenceAsync(image)"
                                       Disabled="@Disabled" />
                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                       Size="Size.Small"
                                       Color="Color.Error"
                                       OnClick="() => RemoveImageAsync(image.Id)"
                                       Disabled="@Disabled" />
                    </MudStack>
                </MudPaper>
            }
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired] public string InputId { get; set; } = string.Empty;
    [Parameter] public string Value { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public IReadOnlyList<WorkspaceImageInput> Images { get; set; } = [];
    [Parameter] public EventCallback<IReadOnlyList<WorkspaceImageInput>> ImagesChanged { get; set; }
    [Parameter] public EventCallback<KeyboardEventArgs> OnKeyDown { get; set; }
    [Parameter] public EventCallback<string> OnValidationError { get; set; }
    [Parameter] public bool ShowGhostSuggestion { get; set; }
    [Parameter] public string GhostSuffix { get; set; } = string.Empty;
    [Parameter] public string Placeholder { get; set; } = string.Empty;
    [Parameter] public string HelperText { get; set; } = "Paste image with Ctrl/Cmd+V or upload from disk.";
    [Parameter] public int Rows { get; set; } = 6;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string PasteBridgeKey { get; set; } = string.Empty;
    [Parameter] public int MaxImages { get; set; } = 6;
    [Parameter] public long MaxImageBytes { get; set; } = 8L * 1024L * 1024L;

    private static readonly HashSet<string> s_allowedMimeTypes =
    [
        "image/png",
        "image/jpeg",
        "image/webp",
        "image/gif",
    ];

    private readonly string _fileInputId = $"composer-file-{Guid.NewGuid():N}";
    private List<WorkspaceImageInput> _images = [];
    private IJSObjectReference? _workspaceJsModule;
    private DotNetObjectReference<TaskPromptComposer>? _dotNetRef;
    private string? _pasteBridgeHandle;

    protected override void OnParametersSet()
    {
        _images = Images.ToList();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_workspaceJsModule is null)
        {
            _workspaceJsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./workspace.js");
            _dotNetRef = DotNetObjectReference.Create(this);
        }

        if (_workspaceJsModule is not null &&
            _dotNetRef is not null &&
            _pasteBridgeHandle is null &&
            !string.IsNullOrWhiteSpace(InputId))
        {
            _pasteBridgeHandle = await _workspaceJsModule.InvokeAsync<string?>(
                "registerComposerImagePasteBridge",
                InputId,
                _dotNetRef,
                PasteBridgeKey);
        }
    }

    private async Task OnInputChangedAsync(ChangeEventArgs args)
    {
        await ValueChanged.InvokeAsync(args.Value?.ToString() ?? string.Empty);
    }

    private async Task OnKeyDownAsync(KeyboardEventArgs args)
    {
        if (OnKeyDown.HasDelegate)
        {
            await OnKeyDown.InvokeAsync(args);
        }
    }

    private async Task OnFileUploadChangedAsync(InputFileChangeEventArgs args)
    {
        if (Disabled)
        {
            return;
        }

        var selected = args.GetMultipleFiles(MaxImages);
        var incoming = new List<WorkspaceImageInput>(selected.Count);

        foreach (var file in selected)
        {
            if (!s_allowedMimeTypes.Contains(file.ContentType))
            {
                await NotifyValidationErrorAsync($"Unsupported image type '{file.ContentType}'.");
                continue;
            }

            if (file.Size > MaxImageBytes)
            {
                await NotifyValidationErrorAsync($"Image '{file.Name}' exceeds {MaxImageBytes / (1024 * 1024)} MB.");
                continue;
            }

            await using var read = file.OpenReadStream(MaxImageBytes);
            await using var memory = new MemoryStream();
            await read.CopyToAsync(memory);
            var bytes = memory.ToArray();
            var payload = Convert.ToBase64String(bytes);
            var dataUrl = $"data:{file.ContentType};base64,{payload}";

            incoming.Add(new WorkspaceImageInput(
                Id: Guid.NewGuid().ToString("N"),
                FileName: file.Name,
                MimeType: file.ContentType,
                SizeBytes: bytes.Length,
                DataUrl: dataUrl));
        }

        await AppendImagesAsync(incoming);
    }

    [JSInvokable]
    public async Task OnComposerImagesPastedFromJs(string bridgeKey, IReadOnlyList<PastedImagePayload> pastedImages)
    {
        if (Disabled ||
            !string.Equals(bridgeKey, PasteBridgeKey, StringComparison.Ordinal) ||
            pastedImages.Count == 0)
        {
            return;
        }

        var incoming = new List<WorkspaceImageInput>(pastedImages.Count);
        foreach (var pasted in pastedImages)
        {
            var mimeType = pasted.MimeType ?? string.Empty;
            if (!s_allowedMimeTypes.Contains(mimeType))
            {
                await NotifyValidationErrorAsync($"Unsupported image type '{mimeType}'.");
                continue;
            }

            if (pasted.SizeBytes > MaxImageBytes)
            {
                await NotifyValidationErrorAsync($"Image '{pasted.FileName}' exceeds {MaxImageBytes / (1024 * 1024)} MB.");
                continue;
            }

            if (string.IsNullOrWhiteSpace(pasted.DataUrl))
            {
                continue;
            }

            incoming.Add(new WorkspaceImageInput(
                Id: string.IsNullOrWhiteSpace(pasted.Id) ? Guid.NewGuid().ToString("N") : pasted.Id,
                FileName: string.IsNullOrWhiteSpace(pasted.FileName) ? "pasted-image" : pasted.FileName,
                MimeType: mimeType,
                SizeBytes: pasted.SizeBytes,
                DataUrl: pasted.DataUrl,
                Width: pasted.Width,
                Height: pasted.Height));
        }

        await AppendImagesAsync(incoming);
        await InvokeAsync(StateHasChanged);
    }

    private async Task AppendImagesAsync(IReadOnlyList<WorkspaceImageInput> incoming)
    {
        if (incoming.Count == 0)
        {
            return;
        }

        var availableSlots = Math.Max(0, MaxImages - _images.Count);
        if (availableSlots == 0)
        {
            await NotifyValidationErrorAsync($"Maximum of {MaxImages} images reached.");
            return;
        }

        var accepted = incoming.Take(availableSlots).ToList();
        if (accepted.Count < incoming.Count)
        {
            await NotifyValidationErrorAsync($"Only {accepted.Count} image(s) were added due to limit {MaxImages}.");
        }

        _images.AddRange(accepted);
        await ImagesChanged.InvokeAsync(_images.ToList());
    }

    private async Task RemoveImageAsync(string imageId)
    {
        if (Disabled)
        {
            return;
        }

        var removed = _images.RemoveAll(image => string.Equals(image.Id, imageId, StringComparison.Ordinal));
        if (removed > 0)
        {
            await ImagesChanged.InvokeAsync(_images.ToList());
        }
    }

    private async Task ClearImagesAsync()
    {
        if (Disabled || _images.Count == 0)
        {
            return;
        }

        _images.Clear();
        await ImagesChanged.InvokeAsync(_images.ToList());
    }

    private async Task InsertImageReferenceAsync(WorkspaceImageInput image)
    {
        if (Disabled)
        {
            return;
        }

        var reference = $"[Image: {image.FileName} ({image.MimeType})]";
        var current = Value ?? string.Empty;
        var insertion = string.IsNullOrWhiteSpace(current)
            ? reference
            : $"\n{reference}";

        if (_workspaceJsModule is null)
        {
            await ValueChanged.InvokeAsync(string.Concat(current, insertion));
            return;
        }

        var selection = await _workspaceJsModule.InvokeAsync<int[]>("getInputSelection", InputId);
        if (selection is not [var start, var end])
        {
            await ValueChanged.InvokeAsync(string.Concat(current, insertion));
            return;
        }

        var safeStart = Math.Clamp(start, 0, current.Length);
        var safeEnd = Math.Clamp(end, safeStart, current.Length);
        var updated = string.Concat(
            current[..safeStart],
            reference,
            current[safeEnd..]);

        await ValueChanged.InvokeAsync(updated);
    }

    private async Task NotifyValidationErrorAsync(string message)
    {
        if (OnValidationError.HasDelegate)
        {
            await OnValidationError.InvokeAsync(message);
        }
    }

    private static string FormatSize(long sizeBytes)
    {
        if (sizeBytes < 1024)
        {
            return $"{sizeBytes} B";
        }

        var kiloBytes = sizeBytes / 1024d;
        if (kiloBytes < 1024)
        {
            return $"{kiloBytes:F1} KB";
        }

        return $"{kiloBytes / 1024d:F1} MB";
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_workspaceJsModule is not null && _pasteBridgeHandle is not null)
            {
                await _workspaceJsModule.InvokeVoidAsync("unregisterComposerImagePasteBridge", _pasteBridgeHandle);
            }
        }
        catch
        {
        }

        _dotNetRef?.Dispose();

        if (_workspaceJsModule is not null)
        {
            try
            {
                await _workspaceJsModule.DisposeAsync();
            }
            catch
            {
            }
        }
    }

    public sealed class PastedImagePayload
    {
        public string Id { get; set; } = string.Empty;
        public string FileName { get; set; } = string.Empty;
        public string MimeType { get; set; } = string.Empty;
        public long SizeBytes { get; set; }
        public string DataUrl { get; set; } = string.Empty;
        public int? Width { get; set; }
        public int? Height { get; set; }
    }
}
